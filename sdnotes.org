* Useful links
** github
https://github.com/ericaygriffith/A1
** trello
** params
https://docs.google.com/spreadsheets/d/1JoIkf02TWzEXbAA_sfRN8o1VPNi_ai6ZDeBJ5JiRy_o/edit#gid=0 
https://docs.google.com/spreadsheets/d/1rXU6ujzg6TBG59XEFuyE1HTJ6VWM-Jr9XIjMMOxvU1g/edit#gid=972301607
** data
https://drive.google.com/drive/u/0/folders/1InN1hUhVfw20JJ8EuyYell4X3ojgMhGu
** paperpile papers
https://paperpile.com/shared/OfX9NI

* R01 Grant relevant text
** Aim 1 
c.3.1.4 Computational modeling:  We will model flexible cortical oscillations that likely occur in the delta/theta ranges (1-9 Hz) and support auditory information representation, as well as more rigid default oscillations that likely occur at alpha (9-14 Hz) frequencies and higher. This will reveal specific network and cellular properties supporting distinct oscillatory dynamical profiles. For example, rigidity in the alpha oscillations may arise from the strong bidirectional interactions between cortex and thalamus197,198, making it difficult to perturb their properties. We will test this by altering the bidirectional connectivity between cortex and thalamus. We will also stimulate thalamic core/matrix in the model selectively and in combination with pairs of inputs with systematically varied inter-stimulus intervals. We predict that long interstimulus intervals greater than 100 ms will allow the circuitry to adjust its oscillation wavelength to match because sufficient numbers of cortical cells will have time to recover from initially strong stimulation associated with the first input. However, short interstimulus intervals (< 100 ms) will not allow the circuitry sufficient time to adjust its oscillation period, instead only allowing phase resets. This would prohibit the efficient tracking of stimulus structures at these higher rates.

** Aim 2
c.3.2.4 Computational modeling:  We will use our detailed thalamocortical model to investigate mechanisms of phase reset. The model consists of several thalamic nuclei (MGB, pulvinar), each of which contain core and matrix neurons, and thalamic reticular nucleus (TRN). The auditory cortex model contains multiple neuron types (low-threshold and fast-spiking interneurons, pyramidal neurons, spiny stellate neurons) arranged in 6 cortical layers. Neurons are wired using GABAA/GABAB and AMPA/NMDA synapses with appropriate time constants and connection densities based on the literature150,213,214. Importantly, thalamic matrix neurons primarily project to the supragranular cortical layers while thalamic core neurons project to granular and infragranular layers. Our preliminary modeling suggests that thalamic matrix neurons target supragranular dendrite-targeting interneurons, allowing them to contribute to long-lasting inhibition critical for effective phase reset203. We will use our model to test basic mechanisms of phase reset, including the transition from tonic to burst firing, which could be modeled by adjusting the synaptic gain of thalamic matrix neurons. These manipulations would act as a correlate of changes in attention or pharmacological manipulation and will offer predictions on effective neuromodulation strategies for inducing/preventing phase reset through specific pharmacological manipulation of the matrix.


** Aim 3
c.3.3.4 Computational modeling: We will use our model of the thalamocortical system to investigate mechanisms of auditory stream segregation and parsing and their role in auditory information processing. As a correlate of auditory function, we will test auditory decoding fidelity using model LFP/CSD activity to recover auditory signals15  under conditions hypothesized to contribute to more or less effective stream segregation and parsing. We hypothesize that stream segregation and parsing occur through a process of dynamic competition between distinct neuronal ensembles that represent specific auditory information and those that do not, through dynamically regulated inhibition from MGB and pulvinar. To test mechanisms of stream segregation, we will present two competing streams to the MGB neurons with systematically varying gain levels. We predict that the recovered fidelity of the attended signal will depend on the amplitude ratios of stimulus streams and synaptic gains of MGB neurons. We will also test if tonic activation of pulvinar matrix enhances auditory stimulus parsing, enabling better auditory decoding by inserting strong inhibitory periods in A1 activity between repetitive patterns in sound clouds or words in speech218. We will test under which conditions hyperpolarizing pulvinar matrix neurons causes them to burst and reset phase. This reset would presumably activate supragranular interneurons and suppress cortical activation, creating a neural pause corresponding to auditory stimulus stream related activity, improving stimulus encoding/decoding. Depending on the auditory stimulus spectrotemporal characteristics, our model may not accurately encode auditory information. To compensate for this, model synapses will include inhibitory time constants over a broad range of values within physiological limits, enabling variable-pause durations. We will test whether this manipulation will enhance flexible decoding under attention.



** Methods
c.2.4 Computational modeling:  Modeling is performed in the NEURON simulation environment233. Detailed computational modeling methods can be found in our previous publications234-240 and the “Facilities and other resources” section for Brown University.  
* 19Sep19 NKI poster day
** Include mostly data sources for cell types, distribution and connectivity
** Sim diameter=400, densityScale = 0.05
Creating network of 34 cell populations on 4 hosts...
  Number of cells on node 0: 606 
  Number of cells on node 3: 605 
  Done; cell creation time = 8.15 s.
Making connections...
  Number of cells on node 1: 606 
  Number of cells on node 2: 605 
  Number of connections on node 0: 262101 
  Number of synaptic contacts on node 0: 521366 
  Number of connections on node 2: 261122 
  Number of synaptic contacts on node 2: 519362 
  Number of connections on node 1: 262258 
  Number of synaptic contacts on node 1: 521567 
  Number of connections on node 3: 261192 
  Number of synaptic contacts on node 3: 519517 
  Done; cell connection time = 87.65 s.
Adding stims...
  Number of stims on node 1: 1212 
  Number of stims on node 0: 1212 
  Number of stims on node 2: 1210 
  Number of stims on node 3: 1210 
  Done; cell stims creation time = 0.39 s.
Recording 2 traces of 1 types on node 2
Recording 3 traces of 1 types on node 1
Recording 0 traces of 0 types on node 3
Recording 26 traces of 1 types on node 0

Running simulation for 500.0 ms...
  Done; run time = 1747.12 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 60.30 s.

Analyzing...
>>> >>> 

>>> 
  Cells: 2422
  Connections: 1049095 (433.15 per cell)
  Synaptic contacts: 2086656 (861.54 per cell)
  Spikes: 14431 (11.92 Hz)
  Simulated time: 0.5 s; 4 workers
  Run time: 1747.12 s
Saving output as model_output.pkl ... 
Finished saving!
Saving output as model_output.json  ... 
Finished saving!
  Done; saving time = 0.91 s.

- depolarization block



** Sim diameter=400, densityScale = 0.025

Creating network of 34 cell populations on 4 hosts...
  Number of cells on node 0: 301 
  Done; cell creation time = 3.91 s.
  Number of cells on node 1: 301 
  Number of cells on node 2: 301 
  Number of cells on node 3: 301 
Making connections...
  Number of connections on node 2: 64832 
  Number of synaptic contacts on node 2: 128982 
  Number of connections on node 0: 64584 
  Number of synaptic contacts on node 0: 128422 
  Number of connections on node 1: 65322 
  Number of synaptic contacts on node 1: 129939 
  Number of connections on node 3: 64826 
  Number of synaptic contacts on node 3: 129008 
  Done; cell connection time = 14.51 s.
Adding stims...
  Number of stims on node 2: 602 
  Number of stims on node 1: 602 
  Number of stims on node 3: 602 
  Number of stims on node 0: 602 
  Done; cell stims creation time = 0.11 s.
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 0
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 2

Running simulation for 500.0 ms...
  Done; run time = 747.24 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 10.84 s.

Analyzing...
>>> >>> 

>>> 
  Cells: 1204
  Connections: 260768 (216.58 per cell)
  Synaptic contacts: 518759 (430.86 per cell)
  Spikes: 12939 (21.49 Hz)
  Simulated time: 0.5 s; 4 workers
  Run time: 747.24 s
Saving output as model_output.pkl ... 
Finished saving!
Saving output as model_output.json  ... 
Finished saving!
  Done; saving time = 0.32 s.
Plotting raster...
  Done; plotting time = 8.38 s

Total time = 785.50 s
* 1Oct2019 Preparing SfN poster
** added thalamic pops and conn
** run sim at scale=0.05, size=400um

Creating network of 39 cell populations on 1 hosts...
  Number of cells on node 0: 2518 
  Done; cell creation time = 18.45 s.
Making connections...
  Number of connections on node 0: 231802 
  Number of synaptic contacts on node 0: 420622 
  Done; cell connection time = 83.43 s.
Adding stims...
  Number of stims on node 0: 5036 
  Done; cell stims creation time = 0.58 s.
Recording 31 traces of 1 types on node 0

Running simulation for 500.0 ms...
exp(910.62) out of range, returning exp(700)
  Done; run time = 4276.86 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 13.35 s.

Analyzing...
  Cells: 2518
  Connections: 234320 (93.06 per cell)
  Synaptic contacts: 425658 (169.05 per cell)
  Spikes: 4011 (3.19 Hz)
  Simulated time: 0.5 s; 1 workers
  Run time: 4276.86 s

- raster shows activity and osc in all layers
- many cells show depol block
* 28oct2019 Feedback from Peter on poster
L5 CT
SOM fire antiphase to PV
Thalamus 30% inhibitors local (disinhibit)
TC->L4 cx FF inh Zador lab (which cell types) - wider projection
TC->low L3 as well
TC -> L5 prob not
TC -> L6 science paper
TCM -> L1(sure) 3 (don’t know) - discuss with lady in 2 weeks
Matrix (whole A1) more broadly tuned than core (1-2mm) - can simulate far away region (no core)
A1 = 8mm wide; core only 1mm; matrix all 
Low freq vs high freq A1 circuits - different 
Cx -> thalamus ok
Dendritic spikes - larkum
L1 flatter, L3 more oscillator
Layerwise data  for csd - and spike data but need to sort;  
Mountain sort - py tool
Email asking for firing rates papers 
— supra granular low firing but high gamma (subthres)
* 05nov2019 Issues with conn from sfn
** discrepancy between conn rules and conn matrix
was due to not using plotConn(synOrConn = 'conn') -- was counting eg AMPA+NMDA, so 2x prob
** extremely high probs NGF4->VIP5B and NG5B->VIP4
due to tesiting on very small net, with just 1 or 2 cells in each pop
* 29dec2019 Discuss next steps with same

a1 connectivity looks good

that part mostly done now? next to constrain with data or want to put in auditory signals first?
salvadord 12:02 PM
y mostly done, I think just missing some cell types that erica was working on
salvadord 12:03 PM
could do pulvinar, auditory inputs or constraining
samn 12:03 PM
i like auditory inputs
since that's more rarely done and brings perception into the picture
salvadord 12:03 PM
auditory inputs - me too!
samn 12:04 PM
yeah, she's good with grants
salvadord 12:04 PM
au inputs also allows to compare better to experiments hopefully
samn 12:04 PM
y
same input so can test outputs, etc.
salvadord 12:05 PM
right… though will raise the question of needing A1 tonotopy tuned to different freqs etc
samn 12:05 PM
yeah, can pick a best frequency seen from the recordings to start
salvadord 12:06 PM
sg
could also assume sparse density so representing larger region with ~same num cells
samn 12:06 PM
good idea
* 07jan2020 Playing with Brian Hears
** installed and did intro tuts
https://brian2hears.readthedocs.io/en/stable/introduction.html
https://brian2hears.readthedocs.io/en/stable/brian.html

A common model of cochlear filtering is to apply a bank of gammatone filters, and then half wave rectify and compress it (for example, with a 1/3 power law). This can be achieved in Brian hears as follows (for 3000 channels in the human hearing range from 20 Hz to 20 kHz):

cfmin, cfmax, cfN = 20*Hz, 20*kHz, 3000
cf = erbspace(cfmin, cfmax, cfN)
sound = Sound('test.wav')
gfb = GammatoneFilterbank(sound, cf)
ihc = FunctionFilterbank(gfb, lambda x: clip(x, 0, Inf)**(1.0/3.0))

** need brian2 to generate the spiking output
- extract python code?
- just extract spike times to start with:
In [33]: M.i
Out[33]: <spikemonitor.i: array([2691, 2788, 2813, ..., 1803, 2045, 2183], dtype=int32)>

In [34]: M.t
Out[34]: 
<spikemonitor.t: array([ 0.74829932,  0.79365079,  0.79365079, ..., 99.97732426,
       99.97732426, 99.97732426]) * msecond>
** auditory nerve spiking questions:
- provides direct input to thalamus? or through inferior colliculus? or other?
- how many cells / netstims do we need? 
- what frequency range to cover?
* 27jan2020 Understanding pathway from cochlea to thalamus
** pathway
Cochlea -> superior olivary complex -> inferior colliculus -> thalamus (MGB) (-> A1)

transform sound to spiking activity arriving at MGB
** Ruben auditory brainstem model
https://github.com/rat-h/auditory-brainstem-model/blob/master/mainmodel.cfg - has some conn info between SBC->LSO
https://sites.google.com/site/auditorybsmodel/home
https://github.com/rat-h/auditory-brainstem-model/blob/master/wiki/HOWTO.md

*** Cell types / populations
Cochlea:
- auditory hair cells (AN)
- ventral cochlear nucleus (VCN):
-- spherical bushy cells (SBC); type II and type I-c
-- globular bushy cell (GBC); type I-c

Superior olivary complex:
- medial nuclei of the trapezoid body (MNTB)
- lateral superior olive (LSO)

Note: missing inferior colliculus

** paper on auditory nerve model
https://www.jneurosci.org/content/30/31/10380.long

** Function of areas
*** Auditory nerve
- there are around 30,000 auditory nerve fibres in each of the two auditory nerves. 
- Each fiber is an axon of a spiral ganglion cell that represents a particular frequency of sound, and a particular range of loudness. 
- Information in each nerve fibre is represented by the rate of action potentials as well as the particular timing of individual action potentials. 

*** cochlear nucleus
- The particular physiology and morphology of each cochlear nucleus cell type enhances different aspects of sound information.
- Several tasks are performed in the cochlear nuclei. 
- By distributing acoustic input to multiple types of principal cells, the auditory pathway is subdivided into parallel ascending pathways, which can simultaneously extract different types of information. 
- VCN: The cells of the ventral cochlear nucleus extract information that is carried by the auditory nerve in the timing of firing and in the pattern of activation of the population of auditory nerve fibers. 
- DCN: The cells of the dorsal cochlear nucleus perform a non-linear spectral analysis and place that spectral analysis into the context of the location of the head, ears and shoulders and that separate expected, self-generated spectral cues from more interesting, unexpected spectral cues using igh-level. 

*** Superior olivary complex
- MTO and LSO
-- The medial superior olive (MSO) is a specialized nucleus that is believed to measure the time difference of arrival of sounds between the ears (the interaural time difference or ITD).
-- The lateral superior olive (LSO) is believed to be involved in measuring the difference in sound intensity between the ears (the interaural level difference or ILD).

- MNTB 
-- neurons plays essentials roles in the localization of sound sources and encoding temporal features of complex sounds
-- https://www.ncbi.nlm.nih.gov/pubmed/25873865

*** Inferior colliculus
- Has 3 subdivisions: the central nucleus, the dorsal cortex by which it is surrounded, and an external cortex which is located laterally
- Receives input from: braistem, MGB, A1, basal ganglia, superior colliculus and otherwise; outputs to MGB
- Integrative station and switchboard. 
- Involved in the integration and routing of multi-modal sensory perception, mainly the startle response and vestibulo-ocular reflex. 
- Responsive to specific amplitude modulation frequencies and this might be responsible for detection of pitch. 
- Also related to spatial localization by binaural hearing.
- The receptive fields in inferior colliculus can be seen adapted to handling natural sound transformations.

** email to Sue and Emili
Hi Sue and Emili,
 
As you know we are developing an auditory thalamocortical model with Peter Lakatos. We are trying to figure out what would be an appropriate model to transform an arbitrary sound input signal to the inputs arriving at thalamus (MGB), including processing at cochlea, superior olivary complex and inferior colliculus.
 
We started looking at Brian Hears (http://www.briansimulator.org/docs/hears), which does some cochlea-like filtering, but we are not sure its output can be directly used as input to MGB. We are also looking at this model of auditory brainstem implemented in NEURON, but this might be too detailed and computationally expensive. Ideally, we are looking for some fast phenomenological model that captures the input pathway transformations and outputs spike that can be fed to MGB.
 
Do you have any insights or suggested models ?
 
Thanks!
Salva
** email from Emili
from Emili: “With regards to your model, in our recent paper, we used a peripheral implementation which is relatively up to date, and pretty fast, not sure if is what you are after but perhaps it is useful.
https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1006820”

I checked the model and it’s in Python (compatible with 2 and 3) … and seems to capture more details than Brian Hears

https://github.com/qtabs/moch 

** email from Sue Denham
Sue Denham: “Regarding the peripheral model .. there are many out there .. but to be honest i do not think the processing much beyond the cochlea and small aspects in the cochlear nucleus and IC have been modelled well yet. Emili’s suggestion is probably a good one. It depends though on how realistic you want to be. And of course there are also massive feedback projections which are largely ignored .. good luck :-)”

** Emili's model
https://github.com/qtabs/moch
https://github.com/mrkrd/cochlea
https://github.com/mrkrd/thorns
https://link.springer.com/article/10.1007%2Fs00441-015-2202-z

*** installing cochlea
[error:fatal error: 'numpy/arrayobject.h' file not found; solved by adding path to CFLAGS]
setenv CFLAGS "-I/usr/local/lib/python3.7/site-packages/numpy/core/include/"
pip install cochlea (or git clone and python setup.py install)

** Convergence of cochelar auditory nerve fibers onto MGB (indirect, )
- from  https://sites.google.com/site/auditorybsmodel/home): 

Table 2.

                        lSBC        sSBC        GBS     D-SC

N                      36600        36600       6300    6300    

Converging ANFs, n      2-3        2-3          ~23     10



Table 3.
                        MNTB-PC    LSO-PC

N                       2000-6000  75% of the population

Excitatory  Inputs, n       1      10

- conn: SBC -> LSO and GBC -> LSO
- convergence ANF to LSO cells = 2-3 * 10 = 20-30 or 23 * 10 = 230; assume first, so 25 ANF inputs per LSO cell  


- convergence between LSO cells to MGB cells (Oliv18; chapter 2)
-- Almost all of the ascending projections to the MG arise in the ipsilateral IC with a small contribution from the contralateral IC
-- LSO / inferior colliculus has complex circuitry with multiple layers and several morphologically distinct cell populations 
-- 10-30% of inhibitory projections 

- number of ANFs:
-- human: 30,000
-- cat: 50,000
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3198376/

- similar tuning in macaques as in humans:
-- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3198376/
* 6Feb2020 Carney model for Auditory nerve fibers (ANF) and Inferior Colliculus (IC)
** email from slava
Hi Everyone,
Thanks for your interest in the 'auditory-brainstem-model' description. I think, it might also be good to check e.g. the Auditory Modeling Toolbox (AMT) and maybe some implementations might be useful for your project. The AMT collection contains many models for different stages of the auditory system ( + description/documentation and references).
http://amtoolbox.sourceforge.net/models.php
>>a low to moderate complexity circuit model 
Regarding the IC stage and (functional) input transmission to higher centers, maybe it would be interesting to check Nelson and Carney (2004) as a first step for your project. This is a phenomenological CN-IC model with the same-frequency inhibition and excitation implementation, which can be stimulated by the AN model. It is better to use filter implementation (Python or Matlab) which is faster than convolution.
https://www.urmc.rochester.edu/labs/carney/publications-code/auditory-models.aspx
Best regards,
Slava
** chat with sam
so I’m gonna check the SOC,IC reduced models he suggested here
3:22
and if makes sense probably used those (maybe in combination with the Cochlea package, if they dont have a cochlea built in)

samn  3:22 PM
ic, sg ... i looked at that page briefly but not at the code it lists
3:24
by cns/sfn will prob be able to compare nhp data and model output under speech input

salvadord  4:37 PM
yes, in theory once I connect the cochlea/SOC/IC, the next step would be to tune the network params to reproduce some physio data… so could start using some data for that

samn  4:44 PM
sg

salvadord  1:01 PM
the model suggested by Slava (not Salva!) transforms .wav file to IC output spikes … so looks perfect, except that it’s in Matlab and C++
image.png 
image.png


1:02
in theory they say works with Octave, so could potentially just call code from netpyne at start, generate spikes and save the to file, and then read from netpyne

samn  1:02 PM
ah, wonder if can convert to py or just use to produce spikes
1:02
if works in octave sg

salvadord  1:02 PM
other option would be to convert to py … right … but that might take more time as code doesnt look simple, and has the C++ code embedded
1:02
ok, I’ll try the octave option for now

samn  1:02 PM
sg
1:02
thx
1:03
want wav files? or just testing first anyway

salvadord  1:03 PM
if find a brave student could be a nice project to convert to py, and useful for others…

samn  1:03 PM
yeah

salvadord  1:03 PM
sure if have experiment wav can share, but not urgent
** links to Matlab code
https://www.urmc.rochester.edu/labs/carney/publications-code/auditory-models.aspx
https://www.urmc.rochester.edu/MediaLibraries/URMCMedia/labs/carney-lab/codes/UR_EAR_v2_1.zip
** Conversion to Octave
- installed Octave 4.4.1 for mac (bundled dmg)
- https://github.com/joyofdata/octave-matlab

- pkg install -forge control
- pkg install -forge signal
- pkg load control
- pkg load signal

- UR_EAR_v2_1.m - doesn't work -- many missing functions, specially for GUI

- extracted code from UR_EAR_v2_1.m; removing all of GUI components
- Used the following models:
-- Which_IC = 2 AN_ModFilt model (Mao et al., 2016)
-- Which_AN = 1 (Zilany et al., 2014)

** Progress but now stuck (chat)
installed Octave and tried code but lots of missing functions, specially for GUI stuff which is all mixed in code


5:22
been working on extracting the essential code (without GUI) and replacing missing funcs etc
5:23
have first stages working now, but now have issue with some of the C code and compiled mex version, which not working in Octave

billl  5:23 PM
octave generally a disaster and think has fallen further and further behind -- in fact i asked about it at the review last week and everyone said fuggedaboutit

salvadord  5:24 PM
will see if can find work around … unfortunately the simple IC model (filter version recommended by Slava) doesnt include the .c code, just the compiled versions, which don’t seem to be recognized by Octave
5:26
octave disaster - I was actually quite impressed with how advanced was since last time I tried … version 4.4 and nice GUI, plus many packages available … but yeah, still not matlab
5:26
I will keep trying to find solution … otherwise guess potentially could use matlab to generate inputs for now, since available at NKI
** installed Matlab - all works
** output of IC is avg firing rate -- how to input in NEURON?
- vec.play stim into NetStim
- eg:
init_amp = 0.0
peak_amp = 0.24
ramp_up = np.linspace(init_amp, peak_amp, simConfig.duration/(simConfig.dt))
t = h.Vector(np.arange(0,simConfig.duration, simConfig.dt))
amp = h.Vector(ramp_up)
for cell in sim.net.cells:
    try:
        amp.play(cell.stims[0]['hObj']._ref_amp, t, True)
    except:

* 18Feb2020 Preparing to tune model
** consolidated all cell params in .json files
including 3d pt morphologies and weightNorm
** select network size
diam 200 um = 12856 cells
diam 300 um = 28897 cells
diam 400 um = 51344 cells 
** feedback from blake on evol param optimization (suggest using delfi; param sensitivity)
Thank you, Salva. Those comments are very helpful!

That sounds like a tough problem for M1. I think with HNN we were lucky that the parameter space for each round was constrained to <8 parameters and we knew the timing was most critical. My thoughts go to what I’ve been experimenting lately with for the initial optimization (“bootstrapping”). Another PhD student and I have been looking at Delfi, which does inference by using neural networks for density estimation. I’m still learning about the choices involved in constructing the neural network, but I feel it’s a promising direction for these types of problems.
https://github.com/mackelab/delfi/

I’ve run Delfi with HNN and the results are interesting. We were able to run 1M simulations because of the shorter runtime with HNN and it gave us a narrow posterior for the input timings, and acceptable ranges for most synaptic strengths. It also correctly identified parameters that have a minimal impact—their posteriors broad were extremely broad. 

Thinking about how to get the most information out of each simulation, training a neural network seems to be a good fit for your problem. Our HNN test with Delfi was really just a sensitivity analysis. We only ran a single round, where the priors were uniform distributions. However, instead of running a single round, I think you’d benefit from fewer simulations, but more rounds. Each of the algorithms implemented in Delfi can run sequential batches (like evolutionary methods), but they also derive value from all previous simulations by using the complete data set for network training. They iteratively update the model in contrast to evolutionary algorithms that are elucidating relationships (successful progeny) from scratch at each round and throwing out the same bad fits over and over.

You may not be looking for an entirely new approach, but just wanted to share this. I’d love to talk more about it.

Best,
** response to blake (explain what we need)
Hi Blake, thanks, this is really interesting.
 
We recently went through the delfi biorxiv paper in our journal club, and were not totally convinced of it's usefulness, particularly due to the number of sims required. But great to hear you tried it and produced useful results.
 
In the M1 model we have a relativey good idea of the params we are happy to optimize: ~10 connectitvity-related params, within boundaries that were not totally constrained by literature. The main concern is what method to use to find the right parameter values, e.g. multiobjective optim vs evolution strategy, what metaparameters, possibly using some method like the latin hypercube to better explore the param space, …. That said this delfi method seems very useful to verify whether we are selecting suitbale parameters and value ranges; and generally to explore param sensitivity, which we are also interested in doing.
 
Do you have time to chat about this some time on Thursday (Feb 27) ?

** response from blake (suggest other method)

Oh yes, I can see that you may not get a lot of additional value from Delfi beyond a sensitivity analysis. The “amortization” feature was most interesting to us—can we train a model on a bunch of simulations and provide users with reasonable parameter guesses.

I’m happy to chat Thursday! I’m open any time before 2:30pm.

Another possible consideration that comes to mind is MLSL, but I don’t know if it is implemented in a parallel version anywhere. Here’s the NLopt version:
https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage

** potential list of parameters to tune
# overall weights gains 
cfg.EEGain = 1.0 
cfg.EIGain = 1.0 
cfg.IEGain = 1.0 
cfg.IIGain = 1.0 

# I->E/I weights gains for each layer (L2/3+4, L5, L6)
cfg.IEweights = [1.0, 1.0, 1.0] 
cfg.IIweights = [1.5, 1.0, 1.0]

# Weight and rate of background inputs to thal
cfg.weightBkg = {'E': 3.5, 'I': 2.0, 'ThalE': 1.0*1e-2, 'ThalI': 1.0*1e-2}  
cfg.rateBkg = {'E': 80, 'I': 80, 'ThalE': 15, 'ThalI': 15}

# weight and prob conn of cochlear+IC inputs to thal
cfg.weightInput = {'ThalE': 0.5, 'ThalI': 0.5}  
cfg.probInput = {'ThalE': 0.25, 'ThalI': 0.25}  

** fitness function
# fitness is exponential that increases with difference between target and population firing rate
# parameter 'width' controls sensitivity 
# parameter 'maxFitness' set the maximum (worst) allowed fitness value
# parameter v['min'] sets minimum value; if rate is below, then fitness becomes maxFitness
# perfect fitness = 0
    fitness = np.mean([min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.iteritems()])

# for each population can then set 'target' firing rate, 'width' (~sensitivity), and 'min' value e.g.
    pops = {} 
    Etune = {'target': 10, 'width': 5, 'min': 0.5}
    pops['IT2'] = Etune
    pops['IT4'] = Etune
    pops['IT5A'] = Etune 
    pops['IT5B'] = Etune  
    pops['PT5B'] = Etune 
    pops['IT6'] =  Etune
    pops['CT6'] =  Etune

    Itune = {'target': 20, 'width': 15, 'min': 0.25}
    pops['PV2'] = Itune
    pops['SOM2'] = Itune
    pops['PV5A'] = Itune
    pops['SOM5A'] = Itune
    pops['PV5B'] = Itune
    pops['SOM5B'] = Itune
    pops['PV6'] = Itune
    pops['SOM6'] = Itune

** options for optimization method
*** custom evol optim (inspyred)
- using for M1
- requires deciding metaparameters
- seems to sometimes get stuck on local minima (but haven't tested this systematically; or compared to others)

-    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 50,
        'num_elites': 5,
        'mutation_rate': 0.4,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 100,
*** 'evolutionary strategy' evol optim (inspyred)
- used in the past; similar results as custom
*** multiobjective evol optim (inspyred)
- used for single cell
- not integrated into netpyne; but could add
*** multi-level single-linkage (NLopt)
- suggested by blake
- uses NLOpt py package: https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage
- not integrated into netpyne
*** preliminary analysis of param sensitivity/impact (delfi)
- http://www.mackelab.org/delfi/
- used by blake on hnn 
- might be useful to select suitable params and value ranges
- I think could potentially use existing sims to train
*** param space sampling using latin hypercube

- used by Tim Rumbell for single cell optim
- more homogeneous sampling of the param space 

* 23Mar2020 Tuning model
** tune 1st bkg
- agreed with sam should tune first bkg to each cell type: maybe ~1 Hz for E and ~4-5 Hz for I
- add bkg GABAA input - sometimes helps to desynchronize the cells if it's noisy
- add bkg E and I inputs for each cell type
- can do this manually since quick sims
* 4May2020 bkg tuning
** latest update
reduced the target E rates from 2 to 1.5 hz and that gives better results (eg less depol block)
9:07
also when using apical inputs to E, I was thinking the low flat response of PT5B is not necessarily a bad thing (edited) 
9:08
just means it’s kind of balanced in the sense that increasing both E and I proportionally results in the same low firing rate … which is reasonable
9:09
so have two decent options for bkg inputs
9:09
E 40 hz soma, I 40 hz soma — problems: 2 pops have depol block, 1 pop doesn’t fire
E 40 hz apical, I 40 hz basal — problems: 1 pops have depol block, 2 pop doesn’t fire
for either case can just adjust a bit the bkg weights for the 3 problematic pops
9:12
so will do that tomorrow and then submit a param sweep for conn params to see if can find good solution (with cortical + thalamic conn)
** add hand tuned scaling factors
- finetuning for pops not firing or in dep block
- follow from v22_sim3 - apical E 40 hz apical, I 40 hz basal 
 
   ITP4 : 0.001 Hz
   ITS4 : 0.000 Hz
   IT6 - depol
** checked bkg (only long-range) rates in M1 model
* 19Oct2020 Tuning by layers

** Allen V1 paper
"Optimizing a full recurrent network at once was very challenging; instead, we followed a stepwise, layer-by-layer procedure. 
We first optimized the recurrent weights within L4, with all recurrent connections outside L4 removed. 
Then we added L2/3 recurrent connections and optimized the weights in both L4 and L2/3. 
This approach was repeated by adding L5, then L6, and finally L1 (see Methods for details). "


Optimization of Full V1 Models

As described in the Main Text, running simulations after the above optimization did not yield suitable network behaviors in either of our V1 models. 
Thus, we used an iterative grid search method (Arkhipov et al., 2018), where weights were uniformly scaled for every class (e.g. scaling weights of excitatory layer
 4 to excitatory layer 5 connections all by the same amount, as one iteration). We searched in discrete increments weight changes across connection classes and 
 selected the best result before moving on to the next connection class (although there was still a need to revisit connections classes during this process). 
 The optimization employed a small training set consisting of a two 0.5-second-long simulations: one of gray screen, and the other of a single drifting grating. 
 We aimed to satisfy three criteria: (i) match spontaneous firing rates (gray screen stimulus) to experimental observations, (ii) match peak firing rates for the 
 drifting grating, and (iii) avoid epileptic-like activity where the network would ramp up to have large global bursts and then enter a period of silence until 
 the next very rapid burst. The weight adjustments were kept in a strict range where, for example, the LGN to L4 excitatory weights were not adjusted at all 
 given that they were fit to direct in vivo experimental measurements (Lien and Scanziani, 2013). Other LGN connections were restricted to be scaled only in 
 the range [0.5, 2] from the target net input current as those were scaled from optogenetics experiments (Ji et al., 2015). 
 The optimization was performed starting from L4 only and adding successive layers one by one. First, all interlayer connections were set to zero and only the 
 intra-layer connections in L4 were optimized. Once our criteria were met, we added L2/3 to the optimization, including the interactions between the two layers. 
 This procedure simplified the optimization process even though weights optimized at one step had to be readjusted at the next step (typically minor). 
 This process was continued for layer 5, followed by layer 6, and finally layer 1. During our optimization, the weight scaling was restricted in the 
 range of [0.2, 5]. In the deeper layers (layers 5 and 6), this rule had to be expanded to reach the net adjustment range of [0.12, 18] for the 
 biophysical model and [0.17, 6.0] for the GLIF model. Note that adjusting the synaptic weights in the biophysical model did not translate directly to 
 scaling the PSP (see the Layer 1 description in Matching Target Post Synaptic Potentials).

** Allen emails
Hi Salva,
 
Anton explained everything perfectly. The one minor detail is that the grid search was done in the interval [0.5*w0; 2*w0] for the LGN input because those were measured so well experimentally. For the recurrent weights, we tried to stay in [0.2*w0; 5*w0] since the experimental data was less ideal.
 
Thanks,
 
Yazan
 
On Sat, Oct 17, 2020 at 10:48 PM Anton Arkhipov <antona@alleninstitute.org> wrote:
Hi Salva,
 
The approach was basically as described in the paper… Go layer-by-layer, starting from L4, and then adding gradually more. I would say it’s very important to get just the L4 working well. Once that’s stable, adding more layers is not as difficult… though certainly requires quite a bit of iterative work.
 
Another thing of note is that there were way too many cell types to work with. So, when we did optimization, we typically operated with connection types grouped into 4 categories: E-to-E, E-to-I, I-to-E, I-to-I (typically, focusing on one layer).
 
The grid searches were typically done in the interval [0.5*w0; 2*w0], where w0 is the starting weight. We would start with this broad interval and then gradually narrow it down in iterative searches. In most cases we did each grid search in just one dimension, sampling, say, 10 points within the currently selected interval. It was all done mostly by hand, we didn’t use optimization code.
 
And regarding the values mentioned in the paper – I assume you mean Fig. 4? Those are original ones from the literature (based on the slice experiments). So, those were our starting values w0, and then we explored around those values.
 
The final values – and the whole model – are all available here:
https://portal.brain-map.org/explore/models/mv1-all-layers
 
By the way, you included Yazan on your email, but he has actually moved on to new adventures in industry 😉. I’m CC’ing his non-work email here. Yazan, please feel free to chime in – you’ve done all of that optimization work!
 
Finally, Salva, if you have more questions or would like to discuss this more, please let me know, I’m always happy to chat.
 
Best,
 
Anton.
 
 
From: Salvador Dura <salvadordura@gmail.com>
Date: Saturday, October 17, 2020 at 10:19 AM
To: Anton Arkhipov <antona@alleninstitute.org>, Kael Dai <kaeld@alleninstitute.org>, Yazan Billeh <yazanb@alleninstitute.org>
Subject: Model tuning
 
CAUTION: This email originated from outside the Allen Institute. Please do not click links or open attachments unless you've validated the sender and know the content is safe.
Hi guys… hope you are all doing great!
 
We are building a model of auditory thalamocortical circuits and using different optimization algorithms to tune connectivity, but haven’t yet been successful and we are struggling a bit.
 
I saw that for V1 you had used a layer-by-layer approach, with cell-type specific weights and grid search. We are thinking of trying this approach and wanted to ask if there are any more details (e.g. values for grid search) and/or source code available?
 
Also, are the weights mentioned in the paper the original ones taken from literature or those after tuning?
 
Thanks!
Salva

  Spikes: 23790 (2.24 Hz)
   IT2 : 40.600 Hz
   SOM2 : 76.400 Hz
   PV2 : 0.000 Hz
   IT4 : 26.600 Hz
   IT5A : 54.600 Hz
   SOM5A : 84.400 Hz
   PV5A : 0.000 Hz
   IT5B : 43.800 Hz
   PT5B : 1.600 Hz
   SOM5B : 63.200 Hz
   PV5B : 0.000 Hz
   IT6 : 30.200 Hz
   CT6 : 18.600 Hz
   SOM6 : 48.200 Hz
   PV6 : 0.000 Hz
   TPO : 2.524 Hz
   TVL : 1.156 Hz
   S1 : 2.541 Hz
   S2 : 2.542 Hz
   cM1 : 1.259 Hz
   M2 : 1.158 Hz
   OC : 2.462 Hz

* 18Nov2021 Paper result figs

- multiscale output: raster, stats, voltage traces, LFP/CSD, current dipoles, EEG

model validation:
- comparison of laminar LFP/CSD exp vs model
- comparison of osc events; examples for supra, gran, infra (Cosyne poster)

model predictions:
- select example LFP signal from single electrode from examples above (model and exp), 
and show contributions from each population: raw LFP and potentially spectrogram; can include spike raster and spectrogram (for comparison with LFP)

other easy/fast potential model predictions:
- lesion different popuations and/or core vs thal matrix and show effects on dynamics (raster, LFP/CSD)
* 19Nov20201 Exp data
** noelle response
I also just got part of a response from noelle (have a couple follow-up questions and need to look closer at some figs she sent), 
but basically she thinks the two weird monkeys I showed you yesterday are actually "real" (the very "regular" one, and the one with the blips in the lower layers). 
she thinks the lower-layer blips aren't an artifact and that they might have pierced a white matter tract right there by accident 
(and still reading her response about the regularity of the that other one). but at least we can know that she also sees 
/ saw the same things with those monkeys too! the figs she sent had diff timescales than mine so going to plot them myself w/ her timescales and just make sure they look the same.
** 2-rb04 
very regular CSD data across all 50 secs -- gamma (50-70 Hz) across most channels; occasional beta ~10 Hz
** 2-rb03
- longer osc events - ~75-175ms (~7-15 Hz) 
- Most common: only red/blue in L1/2 (top electrodes) - top-down cortical feedback?? artifact? what if remove top 2 electrodes?
- 2nd most common: top layer + some red/blue bands above granular; and/or below granular
- some coupled osc? gamma over beta?
- similar to model??
** 1-bu3
- shows more differences across layers than 2-rb03 and 2-rb04
- infragranular - stroner and faster (gamma); supragran+gran - longer events (50ms to >200ms)
- some similar to model - long (~200-1000 ms) of strong activation of same channe/layer, including L4
** 2-ma03
- weird blips at infragran electrode (white matter tract??)
** model
- most peaks happen at L4/L5A and L1; variable durations

** Exp data analysis code
ericaygriffith  7 hours ago

okay so I put the .mat files and a .csv file w/ the layer-channel info (necessary for plotting NHP csds) into a subdir called 'data' (https://drive.google.com/drive/folders/14b85qqGjeLwCd5q4FiLNnVa2d43yHXB-?usp=sharing)

I also have the script I used to plot large numbers of the spontaneous CSDs here on repro branch : https://github.com/NathanKlineInstitute/A1/blob/repro/analysis/NHPdataAnalysis.py

the way it's set up now is to do that, but I've used it for other things as well (e.g. sorting .mat files, looking at the average CSD of click files, etc. so it can do other stuff too!)

in the main code block at the bottom, there are some variables that can be changed (e.g. origDataDir is path to the directory w/ the .mat and .csv layer file, 
'test' is an option to either iterate over all of the .mat files in a directory or look at a specific monkey, and dbpath is the path to the .csv file that has the layer info)

the .csv file is used by the getflayers() function

I import functions from two other files, both of which are also in A1/analysis (downsample.py and filter.py -- for downsampling and bandpass filtering respectively)

let me know if anything isn't working / doesn't make sense and of course if you have any suggestions! I aspire to code with your efficiency and organizational skills!! lol
** code to plot CSD
if __name__ == '__main__':

  # Parent data directory containing .mat files
  origDataDir = '../data/NHPdata/spont/contproc/'   # LOCAL DIR 
  
  ## Sort these files by recording region 
  # DataFiles = sortFiles(origDataDir, [1, 3, 7]) # path to data .mat files  # recording regions of interest

  ## Delete or move unwanted / unworted .mat data files 
  # moveDataFiles(origDataDir,'move')

  ############### 
  recordingArea = 'A1/' # 'MGB/' 
  
  test = 1 # set to 1 if testing a particular monkey, 0 if going through all files in data dir
  testFiles =  ['1-bu031032017@os_eye06_20.mat']    #['2-bu037038046@os.mat']   # CHANGE FILE HERE IF LOOKING AT SPECIFIC MONKEY
  
  if test:
    dataFiles = testFiles
  else:
    dataPath = origDataDir + recordingArea
    dataFilesList = os.listdir(dataPath) 
    dataFiles = []
    for file in dataFilesList:
      if '.mat' in file:
        dataFiles.append(file)


  for dataFile in dataFiles: 
    fullPath = origDataDir + recordingArea + dataFile      # Path to data file 

    [sampr,LFP_data,dt,tt,CSD_data,trigtimes] = loadfile(fn=fullPath, samprds=11*1e3, spacing_um=100)
            # sampr is the sampling rate after downsampling 
            # tt is time array (in seconds)
            # trigtimes is array of stim trigger indices
            # NOTE: make samprds and spacing_um args in this function as well for increased accessibility??? 

    ##### SET PATH TO .csv LAYER FILE ##### 
    dbpath = '/Users/ericagriffith/Desktop/NEUROSIM/A1/data/NHPdata/spont/contproc/A1/21feb02_A1_spont_layers.csv' 

    ##### GET LAYERS FOR OVERLAY #####
    s1low,s1high,s2low,s2high,glow,ghigh,i1low,i1high,i2low,i2high = getflayers(fullPath,dbpath=dbpath,getmid=False,abbrev=False) # fullPath is to data file, dbpath is to .csv layers file 
    lchan = {}
    lchan['S'] = s2high
    lchan['G'] = ghigh
    lchan['I'] = CSD_data.shape[0]-1 #i2high
    print('s2high: ' + str(s2high))


    ##### LFP #####
    # plotLFP(dat=LFP_data,tt=tt,timeRange=[7500,8500], plots=['spectrogram'],electrodes=[2,8,13,18],maxFreq=80,saveFig=True, fn=fullPath,dbpath=dbpath) # fn=fullPath,dbpath = dbpath,  # 16,19 #[4,12]


    ##### CSD #####

    ### Plot batches of CSDs:
    ## Set up time ranges for loop
    tranges = [[x, x+200] for x in range(2000, 3000, 200)] # bring it down to 175-250 if possible
    for t in tranges:
      plotCSD(fn=fullPath,dat=CSD_data,tt=tt,
            trigtimes=None,timeRange=[t[0], t[1]],
            showFig=False, figSize=(6,9), 
            layerLines=True, layerBounds=lchan, 
            overlay='LFP', LFP_data=LFP_data, smooth=33,
            saveFig=dataFile[:-4]+'_CSD_%d-%d' % (t[0], t[1]))

** LFP electrode depths
It would be 2200microns from ch1 (uppermost contact) to ch23 (deepest contact), but yes you are correct. 
For presentation purposes we exclude ch1 and ch23 of the MUA and LFP so that it aligns nicely with the 21chs of the CSD. 
You are probably aware of this but in some experiments (but not usually) we may use an electrode that has an inter-contact distance of 150microns instead of 100microns.
Hope this was helpful,
Noelle.
 

* CELL TYPES
** Budinger et al 2018
- Budinger 2018 also mentions few stellates in A1 compared to V1 or S1 (in most species), and also few pyramidal
- large, intrinsically bursting, non adapting pyramidal cells (~PT) found in L5A and L5A/B border
- medium size pyramidals, regular spiking and adapting (~IT) found throughout L5A and 5B
- CT cells projecting to thalamus found in both L5 and L6
- (several differences compared to mouse M1)
** Excitatory types
- IT2,	ITP4 (pyramidal),	ITS4 (stellate),	IT5A,	IT5B,	PT5B,	IT6,	CT6
- maybe add star pyramidal: they are present in L3,L4,L6 and have different physiol, different axonal projs, more radial dends, shorter apical dends
- split IT2 and IT3 - since different connection
** Inhibitory types
- NGF1, PV2/3, PV4, PV5A, PV5B, PV6, SOM2/3,	SOM4,	SOM5A,	SOM5B,	VIPL2/3,	VIP4,	VIP5A,	VIP5B,	VIP6
** Allen Brain V1
http://portal.brain-map.org/explore/models/mv1-all-layers

exc frac	inh frac	PV 	SST	5HT3a	Total
0.85	0.15				
0.85	0.15	0.295918367	0.214285714	0.489795918	1
0.85	0.15	0.552380952	0.295238095	0.152380952	1
0.85	0.15	0.485714286	0.428571429	0.085714286	1
0.85	0.15	0.458333333	0.458333333	0.083333333	1
** total number of neurons in A1
1.6 million (https://www.pnas.org/content/107/36/15927)
** revisiting macaque A1 L4 stellate cells
*** SUMMARY
A1 L4 stellate:
- charlie commented in paper:  "don't think the layer 4 cells in A1 are spiny stellate. They are called granule cells, 
and are considered to be excitatory interneurons like SS, but are structurally different (not sure that is important)"

- literature shows stellate are present in A1 L4 (though scarce compared to V1) of mice, rabbit, birds, bats, cats and humans

- no direct evidence in macaque A1 except several papers from the 90s (coauthored by Charlie) which mention macaque A1 L4 stellate cells receiving input from TC.

*** charlie (No); macaque
don't think the layer 4 cells in A1 are spiny stellate. 
They are called granule cells, and are considered to be excitatory interneurons like SS, but are structurally different (not sure that is important)

*** Krause 2014 (weak); multispecies
https://www.frontiersin.org/articles/10.3389/fnsys.2014.00170/full

"However, spiny stellate cells are rare in auditory cortex, 
their role likely being occupied by pyramidal cells (Smith and Populin, 2001; Barbour and Callaway, 2008; Sakata and Harris, 2009). "

*** Smith 2001 (No); cat
https://onlinelibrary.wiley.com/doi/abs/10.1002/cne.1084

"No such spiny stellate population is encountered in the middle layers of the auditory cortex. Spiny cells that are not stellate or pyramidal are occasionally encountered 
but, as a group, do not display consistent anatomical or physiological features that might allow them to function as auditory cortical versions of the visual spiny stellates. 
Rather, pyramidal cells in the lower half of layer 3 and layer 4 appear to have assumed this role.""

*** Meyer 1989 (Yes); human
https://www.sciencedirect.com/science/article/abs/pii/0306452289904016?via%3Dihub - The spiny stellate neurons in layer IV of the human auditory cortex  

"The spiny stellate neurons have been studied by the Golgi method in the auditory koniocortex and parakoniocortex of man. S
piny stellate cells are a consistent though not very common component of layer IV. 
They are not confined to specific sublayers but occur at all depths of layer IV, and also in layer IIIc. 
Spiny stellate cells in the auditory areas show a great variety of their dendritic arborization pattern. 
The presence of all intermediate forms between small pyramidal cells—which constitute the dominant cell type in layer IV 
and which display an extraordinary heteromorphism—and spiny stellate cells shows the close kinship between both neuronal types."

*** Oliv 2018 chapter 8 (Yes); multispecies
https://link.springer.com/chapter/10.1007/978-3-319-71798-2_8

Fig 8.2 example of L4 spiny stellate in the cat

Fig 8.3 circuit diagram shows L4 spiny stellate

"In cat ACX, there are also two types of star pyramidal cells (Fig. 8.2Ac) with more radiate dendrites: one with spiny and one with rather smooth dendrites (Winer 1984a). 
Together with the sparsely spinous stellate cells (Winer 1984b), they could form a group of neurons having more or less equivalent functions like the classical L4 spiny stellate cells 
of the visual cortex (Lund 1984) (see also Sect. 8.2.4)."

"However, compared to the visual (da Costa and Martin 2011) and somatosensory cortex (Staiger et al. 2004), 
spiny stellate cells are relatively rare in the ACX of bats (Fitzpatrick and Henson 1994), 
rabbits (McMullen and Glaser 1982), 
cats (Winer 1984c; Mitani et al. 1985; one study found none: Smith and Populin 2001), 
and humans (Meyer et al. 1989). 
In these species, spiny stellate cells primarily occur in sublayers 4a and 3b (Fig. 8.2Ad). 
In cat ACX, spiny stellate cells, which have a small spherical dendritic field and an axon targeting L3–5, are driven by thalamic, 
corticocortical, and commissural stimulation; other physiological properties are unknown (Mitani et al. 1985). "

"Together, there is considerable evidence for species- and modality-specific dif- ferences in L4 organization. 
In addition to the near absence of pyramidal and spiny stellate cells in ACX, the weak sublamination (particularly compared to the visual cortex) hints at a reduced intralaminar circuitry. 
A related question is that of the putative target cells of the massive, mainly lemniscal, thalamic inputs to auditory L4 and L3b (Huang and Winer 2000). 
Certainly, the few principal cells are located among the targets, thereby serving thalamocortical feedforward excitation, but these inputs most likely also terminate on the GABAergic interneurons, 
providing strong feedforward inhibition (Verbny et al. 2006; Lee and Sherman 2008)."

*** Steinschneider, Fishman, Schroeder and Arezzo, 1998 (Yes); monkey
https://sci-hub.se/10.1121/1.423877 - "Click train encoding in primary auditory cortex of the awake monkey: Evidence for two mechanisms subserving pitch perception"

"Initial current sinks are located in the thalamorecipient zone of lamina 4 and lower lamina 3 (depths 5 and 6). 
The location and timing of these sinks and surrounding current sources are consistent with the initial depolarization of lamina 4 stellate cells, 
basilar regions of lower lamina 3 pyramidal cells and terminal portions of thalamocortical afferents (Steinschneider et al., 1992 [visual]; Tenke et al., 1993)."


re: cat A1: "An additional population of cortical neurons, characterized by short duration action potentials ~‘‘thin spikes’’! and thought to represent lamina 4 stellate cells, 
is able to phase-lock to click trains at rates up to 400 Hz."

*** Steinschneider, ..., Schroeder et al (1991) (Yes); monkey
https://sci-hub.se/10.1016/0168-5597(92)90026-8 - "Cellular generators of the cortical auditory evoked potential initial component"

"Findings indicate that thalamocortical afferents are a generator of N8 and support a role for lamina 4 stellate cells."

"Elements implicated are lamina 4 stellate cells, which receive monosynaptic input from TC fibers
(Smith and Moskowitz 1979). Many of these cells are characterized
by an asymmetrical and vertical orientation of their dendritic trees
that ascend into lamina 3 (McMillen and Glaser 1982). Because
stellate cells in auditory cortex receive TC afferents mainly on
dendritic branches (Smith and Moskowitz 1979) concentrated in
lower lamina 3 and upper lamina 4 (Jones and Burton 1976), the
initial stetlate cell depolarization would lead to an open-field configuration with a sink surrounding the dendrites and a source near the
cell bodies, resulting in a surface-negative potential. "

"We also hypothesize that the initial negative component in the monkey
cortical AEP is partially generated by lamina 4 stellate cells. Stellate
cells with a vertical dendritic orientation also occur in middle cortical
laminae of the human auditory cortex (Seldon 1981)."

"These data and the present findings support a role for stellate cells in the generation of
the initial auditory cortical component."

*** Fishman 2000
https://sci-hub.se/10.1121/1.429460 - "Complex tone processing in primary auditory cortex of the awake monkey. I. Neural ensemble correlates of roughness"

"It is likely that MUA recordings, particularly in the thalamorecipient zone, include contributions from thalamo-cortical
axons and stellate cells, in addition to pyramidal cells."

*** Wang 2010 (yes); avian
https://www.pnas.org/content/pnas/107/28/12676.full.pdf

*** Harris and Shepherd 2015 (yes); mice
- L4 spiny stellate is one of the 3 types of L4 IT neurons in sensory cortical circuits

*** check allen brain atlas

only human and mouse

** revisiting macaque A1 PT5B cells
*** SUMMARY
- Cortical excitatory neurons are classified into intratelencephalic (IT), pyramidal tract (PT) and corticothalamic (CT), 
based not only on their projection target but also on their morphology, laminar location, physiology and genetic markers.

- PT cells are characterized by being large L5B pyramidal neurons with thick apical tufts, intrinsically bursting and non-adapting, and express genes distinct from IT and CT.

- Shepherd and Yamawaki, 2021: "PT cells are named (loosely, by tradition) for the most common route of their projection to subcerebral destinations in the brainstem and spinal cord.
(The terminology of these neurons is a perennial source of confusion; in adult animals, not all PT neurons retain their PT axon branch, 
owing to area-specific developmental pruning — for example, those in the primary visual cortex (V1) lose their PT branches, but form branches to the midbrain and pons. 
An equivalent term for PT neurons is ‘subcerebral projection neurons’. 
The term ‘extratelencephalic’ has also been introduced22, but as both CT and PT neurons project outside the telencephalon, 
this entails a further distinction between extratelencephalic neurons of layers 5 and 6.)" 

- Therefore PT neurons are not limited to motor corterx, but generally applied by convention to all neocortical regions, including sensory cortices (V1, S1, A1) (Harris and Shepherd 2015; Shepherd and Yamawaki 2021, Baker 2018; Bakken 2021)

- In A1, L5 neurons identified as 'large pyramidal cells' share several features of PT type neurons: thick tufts, mostly in L5B, instrinsically bursting, 
and project to brainstem, including inferior colliculus, superior olivary complex (SOC), and the cochlear nuclear complex (CN) (Budinger, 2018; 2020; Winer and Prieto, 2001; Winer et al 2002; Baker 2018; Malmierca 2010). 
Distinct subsets of A1 L5 neurons also match the description of IT and CT neurons.
 

*** charlie (No); macaque
Pyramidal tract in A1?

*** Harris and Shepherd 2015 (yes); mice sensory (canonical)
IT, PT, CT common to cortical circuits (based mostly on mouse)

*** Billeh 2019 / Allen Brain (No); mice V1
no distinction of L5 excitatory cells

*** Budinger 2018; 2020 (similar); multispecies
- large, intrinsically bursting, non adapting pyramidal cells (~PT) found in L5A and L5A/B border (fig 8.2A shows ~thick tuft)
- medium size pyramidals, regular spiking and adapting (~IT) found throughout L5A and 5B (fig 8.2A shows ~thin tuft)
- CT cells projecting to thalamus found in both L5 and L6

2018:
Physiologically, the large pyramidal cells correspond to intrinsically bursting, mostly nonaccommodating, nonadapting cells as described in rat and mouse A1 (Hefti and Smith 2000; Sun et al. 2013). 
The smaller pyramidal cells are regular spiking and nonaccommodating but sometimes adapting (Hefti and Smith 2000). 
Together, the different L5 pyramidal cells are a main source of corticofugal pro-jections to the striatum, thalamus, midbrain, and brainstem.

2020:
- The axons of the very large and large pyramidal cells arborize locally in the subgranular and granular
layers (Fig. 4); however, their main targets are subcortical structures like the MGB and the inferior colliculi (IC) but also the contralateral ACX (Ojima, 1994; Winer and Prieto, 2001). 
The small and medium pyramidal cells are abundant throughout L5 (Fig. 3Af). 
Their apical dendrites hardly reach L1; their axons have widespread branches in the supragranular layers (Fig. 4) and project subcortically and interhemispherically (Winer and Prieto, 2001).
 
- Descending projections are primarily oriented toward the MGB and other structures of the auditory pathway but also to non-auditory nuclei of the telencephalon, 
 thalamus, midbrain, and hindbrain (e.g. claustrum, striatum, superior colliculus, pons); these projections mainly originate from L5 and L6 pyramidal neurons subserving different connectional systems

- The cortico- collicular projections are strongest for the A1 fields and they arise from several populations of L5 and L6 pyramidal neurons, 
which, however, are largely different from those that project to the MGB.

- The auditory corticobulbar system includes projections from the ACX to the nuclei of the lateral lemniscus (NLL), superior oli- vary complex (SOC), and the cochlear nuclear complex (CN) 

- Taken together, the auditory corticocollicular and corticobulbar connections are largely organized in segregated channels (Lee et al., 2011). 
Accordingly, their specific functions may be diverse as their targets but overall they might serve the modulation ofauditory response properties 
of neurons in the midbrain and hindbrain leading to an adaptation of their sensitivity to sound frequency, intensity, and location; 
which in turn may enhance the attention, orienting behavior, and learning of the individual

*** Steiner and Tseng 2016
Handbook of Basal Ganglia Structure and Function. (2016). Handbook of Basal Ganglia Structure and Function, Second Edition, i. doi:10.1016/b978-0-12-802206-1.00050-7 

"Secondly, long-range corticofugal neurons that project ipsilaterally to the brainstem or spinal cord, from which a striatal projection arises as a collateral from the descending axon, 
are called pyramidal tract neurons (PT). It is currently thought that there are no exclusively corticostriatal cells, but that the cortical afferents are collaterals of other projections (i.e., IT and PT neurons)."

*** Winer and Prieto, 2001; cat
"Layer V in Cat Primary Auditory Cortex (AI): Cellular Architecture and Identification of Projection Neurons" - https://sci-hub.se/10.1002/cne.1183

Large pyr cells: 
- They were concentrated in layer Vb (Fig. 1B: 1a) and dispersed in Va.  
- it formed elaborate local tufts in the layer Ia neuropil
- It entered the white matter (Fig. 4: 1a, AXON) and local branches projected toward layers III and IV andperhaps beyond (not shown). 
All layer V pyramidal cells with a prominent apical dendrite and a corticofugal axon shared these features [corticofugal; extratelencelphalic]


Medium pyr cells: 
- apical dendrites up to 500 mm long that ended as simple tufts in layer II
- local branches reascended as far as layer II . Collaterals projected obliquely (across layers) or laterally (within a layer) for 200–300 mm on each side, 
so that their local domain might extend 500 mm [corticocortical]

Projections:
- re: corticocortical conn: Medium (Fig. 13A: 1b) and small (Fig. 13A: 1c) pyramidal cells were often marked, whereas few large pyramidal neurons were labeled

- re: commisural (contralateral) conn:  Those identified reliably are medium (Fig. 14A: 1b) and small (Fig. 14A: 1c) pyramidal cells; 
Few large pyramidal neurons (Fig. 4: 1a) were labeled, despite the involvement of layer Vb, where they concentrate (Fig. 1B)

- re: corticothalamic (MGB thalamus): The corticogeniculate cells filled layer VI and involved sublayers Va and Vc (Fig 15B: V). 
Layer VI corticothalamic neurons were smaller than layer V cells (Prieto and Winer, 1999). 
Layer V projection neurons included many medium (Fig. 15A: 1b), small (Fig. 15A: 1c), and a few large (Fig. 15A: 1a) pyramidal cells.  

- re: corticollicular (inferior colliculus / midbrain): These were the largest corticofugal neurons (Fig. 17E) and almost all
were pyramidal (Fig. 16A). They were in layer V alone. Corticocollicular neurons occupied the part of layer V nearly devoid of corticothalamic retrograde labeling (compare Figs. 15B, 16B). 
Large (1a) and medium (1b) pyra- midal cells predominated.  

- perhaps sublaminar origins of the corticofugal systems coordinates the dis- charges of inferior colliculus and medial geniculate body neurons. 

- The larger corticocollicular neurons (Table 2) with thicker axons might compensate for the spatiotem- poral offset between the auditory midbrain and thalamus, intervals that would presumably require fine intracortical timing. 
The large corticofugal neurons may influence motor-related functions that place conduction velocity at a premium. Since many midbrain targets have a premotor function (Huffman and Henson, 1990), a rapid input is not unexpected. 

- Thus, hooded rat corticotectal [tectum includes superior and inferiro colliculus] cells resemble the cells classified here as large pyramidal cells, whereas the callosal neuron types include medium, small, and fusiform pyramidal cells.

- These data suggest that (1) the correlation between cell morphology, laminar position, and extracortical target is highly specific; 
and (2) a cell type may participate in more than one connection, with the proviso that functional sub- classes could target different postsynaptic sites. 
Finally, (3) the intracortical projections support the sublaminar partition of layer V proposed here.

- Cells were intrinsi- cally bursting or regular spiking. Bursting cells have a large soma and an apical dendrite that reached layer I (like AI large pyramidal cells), whereas the latter resem- bled AI medium pyramidal cells.

*** Winer 2002 (Yes); monkey
"Descending projections to the inferior colliculus from the posteriorthalamus and the auditory cortex in rat, cat, and "
The corticocollicular labeling was exclusively fromlayer V neurons in primary auditory cortex (AI), and consisted of 
small (V10Wm in diameter; Fig. 3E: 13,16), medium sized (V15Wm; Fig. 3E: 1, 3), and large(s25Wm; Fig. 3E: 6, 15) pyramidal cells.


*** Baker 2018 (Yes); multispecies
"Specialized Subpopulations of Deep-Layer Pyramidal Neurons in the Neocortex: Bridging Cellular Properties to Functional Consequences" - https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6001033/

Additionally, in auditory cortex, L6 IT neurons participate in multimodal integration and L5 ET neurons in learning-induced plasticity of sound localization.

PT also used in visual system

*** Shepherd and Yamawaki 2021 (Yes); rodent/multispecies
"Untangling the cortico-thalamo-cortical loop: cellular pieces of a knotty circuit puzzle"

"The other component of the cortical projection to the thalamus arises as branches of ‘pyramidal tract’ (PT) neurons, 
located in layer 5B and so named (loosely, by tradition18,19) for the most common route of their projection to subcerebral destinations in the brainstem and spinal cord. 
(The terminology of these neurons is a perennial source of confusion; in adult animals, not all PT neurons retain their PT axon branch, 
owing to area-specific developmental pruning — for example, those in the primary visual cortex (V1) lose their PT branches, but form branches to the midbrain and pons20. 
An equivalent term for PT neurons is ‘subcerebral projection neurons’21. 
The term ‘extratelencephalic’ has also been introduced22, but as both CT and PT neurons project outside the telencephalon, 
this entails a further distinction between extratelencephalic neurons of layers 5 and 6.)"

"Recent findings define thalamus-projecting PT neurons as a distinct subtype tending to lack branches to the medulla and PT."

"Primary auditory cortex
The primary auditory cortex (A1) receives a core-type projection from the ventral subdivision of the medial geniculate body (MGB). 
These axons form functional excitatory synaptic contacts mainly onto layer 4 pyramidal neurons, with additional weaker innervation of cortical pyramidal neurons across all layers86. 
This pattern resembles that of other core-type projections to the cortex, with branches ramifying most densely in layer 4, and to a lesser extent around the layer 5/6 border. 
The extent to which CT and PT neurons in A1 receive direct input from the auditory thalamus is not yet clear, but laminar profiles of the MGB input suggest relatively weak excitation, 
consistent with patterns seen in other areas. In the other direction, the CT and PT innervation of TC neurons in the subdivisions of the MGB has also not been fully determined, b
ut the available anatomical data indicate reciprocity, with auditory cortical projections overlapping extensively with auditory thalamic subregions projecting back to auditory cortical areas87,88.""

*** Bakken 2020
"Evolution of cellular diversity in primary motor cortex of human, marmoset monkey, and mouse"

"The L5 extratelencephalic-projecting (ET) types (also known as pyramidal tract, PT, or subcerebral types),"

*** Malmierca 2010
"Descending projections of auditory cortex to the midbrain and brain stem"

Fig 9.9 showing  AC cells projecting to the inferior colliculus (IC), superior olivary complex (SOC), and cochlear nucleus [mostly from L5; some IC from L6]

At least two types of layer V pyramidal neurons with different morphologies participate in the AI corticocollicular
pathway (Figs. 9.8 and 9.9); these are tufted and nontufted pyramidal neurons. The morphological range of terminal
fields in the IC after anterograde injections in AI also supports the notion of two separate populations (Bajo and Moore
2005). Two populations of projecting neurons in layer V in rat AC have been described (Hefti and Smith 2000). Regular
spiking neurons resemble the nontufted type and the intrinsic bursting neurons correspond to tufted neurons noted in gerbil (Bajo and Moore 2005). It has been suggested that only
the intrinsic bursting neurons project to the IC, whereas the regular spiking neurons project to other cortical areas and to the putamen (thalamus)
[i.e. L5B thicktufted bursting PT neurons project to IC]

* CONNECTIVITY
** Budinger et al 2018
- mentions ‘massive thalamic inputs’ target the few pyramidal cells but also interneurons, ‘providing strong FF inhibition’
** Allen Brain mouse V1
- http://portal.brain-map.org/explore/models/mv1-all-layers
- mentions most conn comes from rat S1 (Thomson & Lamy, 2007)
- https://www.dropbox.com/sh/xb7xasih3d8027u/AAAbKXe0Zmk86o3_y1iPVPCLa?dl=0
- I’m thinking this is better option than using mouse M1 since sensory
- they have nice table with all the prob conn valuesand weights, measured as somatic PSP amp (mV), same as we use
- Distance-dependent probabilities

** BBP mouse S1
*** link
https://bbp.epfl.ch/nmc-portal/downloads
*** cell type acronyms
- List of m-types:

DAC	Descending Axon Cell
NGC-DA	Neurogliaform Cell with dense axonal arborization
NGC-SA	Neurogliaform Cell with slender axonal arborization
HAC	Horizontal Axon Cell
LAC	Large Axon Cell
SAC	Small Axon Cell
MC	Martinotti Cell
BTC	Bitufted Cell
DBC	Double Bouquet Cell
BP	Bipolar Cell
NGC	Neurogliaform Cell
LBC	Large Basket Cell
NBC	Nest Basket Cell
SBC	Small Basket Cell 
ChC	Chandelier Cell
PC	Pyramidal Cell
SP	Star Pyramidal Cell
SS	Spiny Stellate Cell
TTPC1	Thick-tufted Pyramidal Cell with a late bifurcating apical tuft
TTPC2	Thick-tufted Pyramidal Cell with an early bifurcating apical tuft
UTPC	Untufted Pyramidal Cell
STPC	Slender-tufted Pyramidal Cell
TPC_L4	Tufted Pyramidal Cell with apical dendrites terminating in layer 4
TPC_L1	Tufted Pyramidal Cell with apical dendrites terminating in layer 1
IPC	Pyramidal Cell with inverted apical-like dendrites
BPC	Pyramidal Cell with bipolar apical-like dendrites

- List of e-types:

cADpyr	continuous Accommodating (Adapting) for pyramidal cells
cAC	continuous Accommodating
bAC	burst Accommodating
cNAC	continuous Non-accommodating
bNAC	burst Non-accommodating
dNAC	delayed Non-accommodating
cSTUT	continuous Stuttering
bSTUT	burst Stuttering
dSTUT	delayed Stuttering
cIR	continuous Irregular
bIR	burst Irregular

*** cell type correspondence
- see https://bbp.epfl.ch/nmc-portal/web/guest/glossary
- Markram et al 2004
- Markram et al 2015
- Tremblay et al 2016

    # set correspondence between A1 pops and BBP S1 pops  
    data['BBP_S1']['pops'] = {
        'NGF1': 'L1_NGC',                                                                                                                              # L1
        'IT2':  'L2_PC',                                              'PV2':  'L23_LBC',   'SOM2': 'L23_MC',  'VIP2': 'L23_BP', 'NGF2':  'L23_NGC', # L2
        'IT3':  'L3_PC',                                              'PV3':  'L23_LBC',   'SOM3': 'L23_MC',  'VIP3': 'L23_BP', 'NGF3':  'L23_NGC', # L3
        'ITP4': 'L4_PC',     'ITS4': 'L4_SS',                         'PV4':  'L4_LBC',    'SOM4': 'L4_MC',   'VIP4': 'L4_BP',  'NGF4':  'L4_NGC',  # L4
        'IT5A': 'L5_UTPC',   'CT5A': 'L6_TPC_L4',                     'PV5A': 'L5_LBC',   'SOM5A': 'L5_MC',  'VIP5A': 'L5_BP',  'NGF5A': 'L5_NGC',  # L5A
        'IT5B': 'L5_UTPC',   'CT5B': 'L6_TPC_L4', 'PT5B': 'L5_TTPC2', 'PV5B': 'L5_LBC',   'SOM5B': 'L5_MC',  'VIP5B': 'L5_BP',  'NGF5B': 'L5_NGC',  # L5B
        'IT6':  'L6_TPC_L1', 'CT6':  'L6_TPC_L4',                     'PV6':  'L6_LBC',    'SOM6': 'L6_MC',   'VIP6': 'L6_BP',  'NGF6':  'L6_NGC'}  # L6

- IT L2,3,4 = PC (=regular pyramidal cell)
- IT5A,5B = UTPC (=thin-tufted)
- PT5B = TTPC2 (=thick-tufted with bifurcation, as our PT cell; other thick-tufted TTPC2 would also probably work)
- CT L5A,5B,6 = TPC_L4 (= CT cell; paper showed CT cells apical only reaches L4; seems they don't have CT cells in L5A,5B)
- IT6 = TPC_L1 (assume this one to differentiate from CT6)
- PV = LBC (=large basket; most abundant PV based on Markram 2004)
- SOM = MC (=martinotti; most abundaant SOM based on Makram 2004)
- VIP = BP (=bipolar cell; based on Tremblay 2015 classification)
- NGF = NGC (=neurogliaform)

*** comparison to Allen
- not distance-dependent
- more cell-type specificity (different exc types from L4,L5,L6 -- ITP,ITS,PT,CT; and 1 more inh types -- VIP)

** E-E 
- Use Allen V1 as base, and then update with any specific A1

*** probability
- L3,4 E -> L3,4 E (Levy & Reyes, 2012)
 
*** weight
- L3,4 E -> L3,4 E (Levy & Reyes, 2012)

** E->I
- Use Allen V1 as base, and then update with any specific A1

- Apicella 2012 (mouse M1)
-- E -> intralaminar I
-- L2/3 E -> L5 LTS (strong)
-- L5 E -> L5 LTS (weak)
-- L5 E -> L5 FS (strong)
-- L2/3 E -> L5 FS (weak)

- Tremblay 2016 (many species):
-- unclear if L2/3 E -> NGF
-- callosal and thalamic matrix -> NGF

- Sohn 2016 (mouse A1)
-- E -> L2/3 VIP (apical+basal)

- Budinger et al 2018 (A1)
-- L2-5 E -> NGF
-- thalamic -> VIP (bipolar)
-- thalamic + cortical -> VIP (bitufted)

- Garcia et al 2015 ()
-- E -> NGF

- Naka 2016 (fig 1,2) (L5):
-- E do not target VIP or NGF (only PV+SOM)

- CONCLUSION:
-- NGF: 
--- L2-5 E inputs
--- thalamic matrix inputs (to L1)
--- thalamic inputs to L2-L5

-- VIP:
--- E -> VIP
--- thalamic -> VIP
** I->E
- currently distance-dependent

- Tremblay 2016:
-- NGF -> local E and I
-- L1 NGF -> L2/3+L5 tuft
-- L2/3 NGF -> L2/3+L5 distal apical
-- L5 NGF -> L5 prox apical

- Naka 2016 (fig 1,2) (L5):
-- L2/3 VIP -> L5 apical trunk (?)
-- NGF -> L5 apical tuft (same as SOM)

- Budinger 2016 (A1):
-- L2 NGF -> L2 E (prox apic); L6 E (tuft)
-- VIP? (not clear which are)

- Pi 2013
-- VIP -> E (very low; 3/42)

- Kato 2017
-- upper SOM -> deeper E strong (graph decay with dist)
 
** I->I
- currently distance-dependant

- Tremblay 2016:
-- L2/3 VIP -> L2/3+L5 SOM
-- L5 VIP -> L5 SOM
-- NGF -> local E and I
-- L1 NGF -> L1 NGF
-- L2/3 NGF -> L2/3 I
-- L5/6 NGF -> L5/6 I
-- L2/3 PV -> L2/3 PV 
-- L5/6 PV -> L5/6 PV 
-- L2/3 PV -> L2/3 I except SOM 
-- L5/6 PV -> L5/6 I except SOM

- Sohn 2016:
-- PV -> L2/3 VIP (soma)
-- SOM -> L2/3 VIP (basal, apical)
-- VIP -> L2/3 VIP (low overall)
-- similar to PV/SOM -> E

- Naka 16 (fig1,2) (L5):
-- all to all (changes in weights)
-- depends on layer and area
-- VIP -> VIP (weak); FS,SOM (strong)
-- SOM -> SOM (weak); FS,VIP (strong)
-- FS -> FS (strong); SOM,VIP (weak)

- Pi 2013
-- VIP -> SOM (strong; 14/18)
-- VIP -> PV (weak; 4/15)

- Overstreet-Wadiche 2015 (mostly CA1)
** Discussion with Sam of I->E/I 
salvadord 9:55 AM
in the original M1 we had I->E/I as intralaminar, with distance-dep probability and fixed weight

for A1 I’ve improved several things:
1) I->E can target deeper layers as well (eg. L2/3 I -> L5 E) since synapsing at apical dends
2) VIP -> E set to very low prob
samn 9:59 AM
#1 very important
so now not all weights are fixed?
salvadord 10:00 AM
3) I -> I adapted probs based on cell type: VIP -> SOM (strong), PV (weak), VIP (very weak); SOM -> FS+VIP (strong); SOM (weak); FS -> FS (strong); SOM+VIP (weak); NGF -> I (medium) (Naka et al 2016;Tremblay, 2016; Sohn, 2016; Pi et al 2013)
samn 10:00 AM
thx, i like the level of detail in the interneuron circuitry...important too
salvadord 10:01 AM
for now weights are fixed but probs are different
samn 10:01 AM
sg
later on will want to vary the gabaa taus
(that's discussed in grant), but don't have to for first draft
salvadord 10:02 AM
note using the same interpretation of weight as in M1 model, ie. somatic PSP amplitude (mV) in response to single cell input
gabaa taus - sounds good … we can have a base model to start with and then improve iteratively
samn 10:03 AM
so that's good since constrained to the exptl lit
somatic PSP vs conductance change since more interested in effect at output?
salvadord 10:05 AM
harder to get conductance values, specially for dendrite syns
this is how implemented in Allen V1 model and Solstez CA1 too
samn 10:05 AM
ic
salvadord 10:06 AM
netpyne then has weightNormalization value that converts ‘weight’ (somatic PSP) to conductance required at each syn
(need to calculate previously for each cell type and store with cellParasm — weightNorm)
samn 10:06 AM
ic, and that's calculated via sim
in a preprocessing step
salvadord 10:07 AM
I have batch netpyne to calcualte for all M1 cell types … will need to adapt for A1 (in future should automate more)

** Discussion with erica


The IPSC values in [9] are in response to optogenetic stim, which I believe activate >1 presyn neurons, so the IPSC value is conflating both conn prob and weight (weight understood as response to single presyn cell, or unitary connection).
For M1 I did use IPSC values as strengths to derive conn probs, i.e. strength =  conn prob x weight. By obtaining weights (unitary conn somatic epsp values) from a different source, I was able to obtain prob conns from the the IPSC values (strengths). 
So, in essence, these values don't represent weights, but the overall conn strength, and so can be used potentially derive the prob conns (by fixing the weight) or the weight (by fixing the prob conn).

salvadord 4:34 PM
in essence as you can see we are missing most values for I->E and I->I so strategy we used before (M1) is to keep more generic and use intralaminar conn with distance-dep prob conn — for A1 I’ve added several more features based on the data we have (see #auditory) but still quite generic

ericaygriffith:speech_balloon: 4:34 PM
I see, okay that is good to know
intralaminar conn w/ distance-dep prob conn -- is there a "generic" source that we use?
salvadord 4:38 PM
many papers describing dist-dep (including some used in excel sheet) … one I cited for M1 is this: https://paperpile.com/app/p/a9dea0e7-7075-0628-958a-8e4f5be45ac5
ericaygriffith:speech_balloon: 4:39 PM
oh I think I see -- you just mean that non-celltype-specific dist-dep conn data is easier to come by than cell-specific? so going to use that as substitute where we don't have cell-specific data?
sry if I'm misunderstanding you!
salvadord 4:42 PM
yeah… so dist-dep is a feature whether we have cell-type specific data or not
the little cell-type specific data we have I’ve tried to incorporate on top of the dist-dep
so e.g. ‘strong’ will be 1.0*exp(-d/L) and ‘weak’ will be 0.35*exp(-d/L)
anyway you can have a look at the excel, conn.py and netParams.py and let me know what you think
** Comparison to BBP and Allen conn
do you have a recommendation based on those differences?
i'm ok with just using allen since has distant dependent. any strong reason to also incorporate BBP?
salvadord 12:58 PM
well there’s 2 diff things to consider: E->E/I and I->E/I
for E-> E/I (currently using Allen), BBP has advantage of differentiating E pops
for I->E/I (currently using our own custom based on papers), both Allen and BBP provide alternatives and show weaker probs from upper I (SOM,NGF) to deeper E — which I had increased since papers showed targeting apical dends
samn 1:00 PM
OK, so I->E/I custom better than either of Allen/BBP for our purposes?
and E->E/I, BBP differentiation of E pops - how much of that is based on cortical layer? macro from Allen might be good enough for our purposes
salvadord 1:03 PM
I->E/I better - maybe, but fact that allen + bbp so different makes me wonder if I’m misinterpreting papers — I’ll recheck and stick to ours if makes sense (or maybe reduce a bit those strong conns to match allen/bbp better)
samn 1:03 PM
sg
thx
& E->E/I BBP - large diffs there too compared to what currently have? (on nki network so google drive blocked...only could look via phone)
I->E/I plan sg anyway, can do 1 step at a time, thx for update
salvadord 1:21 PM
PDF 
A1 conn comparison.pdf
2 MB PDF — Click to view


samn 1:22 PM
thx
salvadord 1:26 PM
btw all conn matrices generated from A1 instantiated model (400 um diameter column; 12k neurons; 25% cell density) so there’s some randomness involved
samn 1:35 PM
for E -> E/I is there a way to adjust to take into account the known/existing subtypes we have from BBP and otherwise leave as is?
one problem then is macro-probabilities could be increased/decreased from what they should be...
salvadord 2:03 PM
adjust E subtypes - yeah I was thinking about that; maybe scale based on BBP
what do u mean by macro-probabilities?
samn 2:03 PM
i mean the probabilities from allen that don't take into account the sub-types
salvadord 2:04 PM
ok y makes sense
samn 2:04 PM
if one population gets more inputs due to bbp then another one might need to get less

** Updating E->E/I conn based on BBP subcelltypes
- Allen does not distinguish E subtypes; and VIP cell type
- Updated VIP, ITS4, CT, PT based on BBP:
*** code in conn.py

# List of pops to update based on BBP ratios of cell subtypes (key = pop to update; value = pop to use as reference)
    updatePopConnUsingBBP = {'VIP2': 'PV2', 'VIP3': 'PV3', 'VIP4': 'PV4', 'VIP5A': 'PV5A', 'VIP5B': 'PV5A', 'VIP6': 'PV6',
                            'ITS4': 'ITP4',
                            'CT5A': 'IT5A',
                            'CT5B': 'IT5B',
                            'PT5B': 'IT5B',
                            'CT6': 'IT6'}
    
    basedOnBBPCT6 = [] #'CT5A', 'CT5B']  # pops based on BBP CT6 (since BBP doesn't have CT5A and CT5B) so treated differently (NOT USED)

    fixVerbose = True  # print info messages
    
    ## update all fix pop (e.g. VIP) by making proportional to ref pop (e.g. PV): e.g. VIP_Allen = (VIP_BBP/PV_BBP) * PV_Allen
    for fixpop, refpop in updatePopConnUsingBBP.items():
        if fixVerbose:
            print('\nUpdating conn probability of pop %s using as reference BBP conn probability ratio of %s:%s ...' % (fixpop, fixpop, refpop))
        
        # E -> fixpop
        for pre in Epops:
            projAllen_ref = '%s-%s' % (data['Allen_V1']['pops'][pre], data['Allen_V1']['pops'][refpop])
            if fixpop in basedOnBBPCT6:
                ## Make CT5A <-> L5A E/I and CT5B <-> L5B E/I == CT6 <-> L6 E/I (so based on local conn) (NOT USED)
                projPre = pre.replace('5A', '6').replace('5B', '6').replace('PT6', 'PT5B')
            else:
                projPre = pre
            projBBP_ref = '%s:%s' % (data['BBP_S1']['pops'][projPre], data['BBP_S1']['pops'][refpop])
            projBBP_fix = '%s:%s' % (data['BBP_S1']['pops'][projPre], data['BBP_S1']['pops'][fixpop])

            # conn probs 
            ref_Allen = data['Allen_V1']['connProb'][projAllen_ref]['A0'] if projAllen_ref in data['Allen_V1']['connProb'] else 0.
            ref_BBP = data['BBP_S1']['connProb'][projBBP_ref]['A0'] if projBBP_ref in data['BBP_S1']['connProb'] else 0.
            fix_BBP = data['BBP_S1']['connProb'][projBBP_fix]['A0'] if projBBP_fix in data['BBP_S1']['connProb'] else 0.
            if ref_BBP > 0. and fix_BBP > 0.:
                if fixVerbose:
                    print(' Prob %s->%s:'%(pre, fixpop), 'ref_BBP: %.2f'%(ref_BBP), 'fix_BBP: %.2f'%(fix_BBP), 'ref_Allen: %.2f'%(ref_Allen), 'fix_Allen: %.2f'%((fix_BBP/ref_BBP) * ref_Allen))
                pmat[pre][fixpop] = (fix_BBP / ref_BBP) * ref_Allen
 
        # fixpop -> E/I
        for post in Epops+Ipops:
            projAllen_ref = '%s-%s' % (data['Allen_V1']['pops'][refpop], data['Allen_V1']['pops'][post])
            if fixpop in basedOnBBPCT6:
                ## Make CT5A <-> L5A E/I and CT5B <-> L5B E/I == CT6 <-> L6 E/I (so based on local conn)  (NOT USED)
                projPost = post.replace('5A', '6').replace('5B', '6').replace('PT6', 'PT5B')
            else:
                projPost = post
            projBBP_ref = '%s:%s' % (data['BBP_S1']['pops'][refpop], data['BBP_S1']['pops'][projPost])
            projBBP_fix = '%s:%s' % (data['BBP_S1']['pops'][fixpop], data['BBP_S1']['pops'][projPost])

            # conn probs 
            ref_Allen = data['Allen_V1']['connProb'][projAllen_ref]['A0'] if projAllen_ref in data['Allen_V1']['connProb'] else 0.
            ref_BBP = data['BBP_S1']['connProb'][projBBP_ref]['A0'] if projBBP_ref in data['BBP_S1']['connProb'] else 0.
            fix_BBP = data['BBP_S1']['connProb'][projBBP_fix]['A0'] if projBBP_fix in data['BBP_S1']['connProb'] else 0.
            if ref_BBP > 0. and fix_BBP > 0.:
                if fixVerbose:
                    print(' Prob %s->%s:'%(fixpop,post), 'ref_BBP: %.2f'%(ref_BBP), 'fix_BBP: %.2f'%(fix_BBP), 'ref_Allen: %.2f'%(ref_Allen), 'fix_Allen: %.2f'%((fix_BBP/ref_BBP) * ref_Allen))
                pmat[fixpop][post] = (fix_BBP / ref_BBP) * ref_Allen

** Updating I->E/I based on Allen
- L2/3 PV and SOM -> L5 Pyr probability is low; <0.05 (based on Jiang et al 2015, Science -- Tolias) -- table S7 and S8 
- CHECK REFS I USED AND WHETHER THEY ARE FROM A1 OR MACAQUE
- REDUCE BASED ON ALLEN?

*** E->I
## Update L2/3 SOM,PV -> deeper E depth-dependent (Kato 2017; Fig 8B); supported by L2/3 PV -> L5 E (Naka 2016, Fig 2)

## Update VIP -> E very low (3/42; Pi et al 2013); but L2/3 VIP -> L5 (Naka 2016, Fig 2)
## make same as SOM but multiply by ration of VIP3->E5 (Pi 2013) / SOM3->E5 (Kato 2017)

*** I -> I
- Allen consistent with 'custom_A1'; with minor diffs:
-- PV -> NGF (0.22) higher than PV -> SOM (0.3); but both lower than PV->PV (0.451) so good
-- SOM -> NGF (0.77), almost as high as SOM -> PV (0.857)
-- interlaminar probs very low (~0.03) but not 0
-- missing VIP (so will use custom_A1 based on existing numbers)

    # VIP uses by default PV weights; need to change the following:
    # VIP -> SOM = strong (but PV -> SOM = weak)    
    # VIP -> PV = weak (but PV -> PV = strong)   
    # VIP -> VIP = weak/veryweak (but PV -> PV = strong) 
** Checking / fixing diffs between empirical and network instantiated conn matrix
- bug in netParams.py (II rules)
- bug in conn.py (avoid double counting BBP adaptation)
** thalamocortical conn 
*** current conn (mostly from Bonj12 and Lakatos comments)
- current TC conn comes from the bazhenov paper (https://www.jneurosci.org/content/32/15/5250.full ; Bonj12) but I don’t see any actual prob or weight values there… @samn do you know how was derived? (edited) 

- only values I see are in a table, which seem to be divergence

*** !Constantinople & Bruno, 2015 (Science); rat S1 (TC->L5/6 pmat+wmat)
- prob of conn between thalamus and cortical layers / cell type:
-- L5 thintufted (IT): 17%
-- L5 thicktufted (PT/CT?): 44%
-- L6: 9% 

- weight (epsp):
-- 0.2 - 1.2 mV
*** !Bruno and Constantinople, 2006; rat S1 (TC->L4)
- L2/3: 0%
- L4: 42.5% / 42.8%

- weight (epsp):
-- 0 - 1. mV

*** !Ji 2016 (mouse A1 MGB -> layers/cell types)
- no distinction core vs matrix (but most input from MGBv=core; same as allen)
- normalized amplitude
- % innervated

% innervated [~= proxy for probability; many presyn axons innervated]
- L1 cell (12/ 22);
- Pyramidal cell (11/15 in L2/3; 18/18 in L4; 12/12 in L5; 8/10 in L6); 
- PV cell (11/14 in L2/3;13/13 in L4; 15/15 in L5; 8/8 in L6); 
- VIP cell (0/17 in L2/3; 6/16 in L4; 0/10 in L5; 0/6 in L6); 
- SOM cell (1/12 in L2/3; 5/14 in L4; 0/10 in L5; 0/6 in L6)


A1  (adjusted amplitude pA [~= strength = prob * weight]):
L1 
L1 22 425 

Pyr 
L2/3 15 129
L4 18 418 
L5 12 195  
L6 10 132  

PV L2/3 14 269 
L4 13 962 
L5 15 426 
L6 8 426 

SOM L4 14 20 

VIP L4 16 24 


*** !check Allen V1 (LGN -> diffrent layers RS/PV; based on Ji2016)
- LGN -> V1
- ~18k units
- no core and matrix

table 2: conns from LGN
celltype    prob    num syns
i1Htr       0.588   10

E2/3        0.789   15
i2/3Pvalb   0.824   15
VIP/SOM     0

E4          1.000   80
i4Pvalb     1.0     75
VIP         0.32
SOM         0.32

E5          1.0     15
i5Pvalb     1.0     20 
VIP/SOM2    0

E6          0.778   15
i6Pvalb     0.818   10
VIP/SOM     0
*** !Cruishcanck 2010 (mouse VB/TRN <-> Barrel cortex L4/5 RS/FS/LTS)
https://www.sciencedirect.com/science/article/pii/S0896627309010435

- strong T -> RS and PV but not SOM
- C -> VB and ITRN; ITRN -> VB (but not -> TRN) i.e. "CT activation produced strong inhibition in VB but not in TRN cells"

- "CT projections outnumber TC projections and that CT synapses provide major input to thalamic neurons"

- Data from fig 6B (avg EPSP amplitudes to optogen stim): 
- L4: 
-- RS: 11 mV
-- FS: 20 mV
-- LTS: 2 mV

- L5: 
-- RS: 15 mV
-- FS: 25 mV
-- LTS: 1 mV

TRN -> TRN: 2.8% prob
TRN -> VB: 8% prob


*** Slater 2019 (A1 L5/6 -> IC; IC->MGB->A1 L5/6; only corticollicular; proportion of L5 vs L6)
*** Viaene 2011 (nothing) 
- checked papers but not useful conn data

*** check BBP S1 (peter's rule)
- VPM based on targeting of fibers (cortical neurons epr fiber)
- found bruno paper

*** Amsalem segev thalamus (nothing on thalamus)
*** Allen new database/papers (anatomical; region level; hard to extract)
- connectivity.brain-map.org ; Harr19
- anatomical - tracing of axons
- thalamic vs auditory regions but not cell-type specific
- general layer info:
-- core -> L4,5,6a
-- matrix -> 1,6a (some 2/3,5)

*** check Elisabetta iavarone (nothing)
- only thalamic cell models
*** Traub thalamocortical model (convergence values; loosely based on data)
- no core vs matrix

INPUTS FROM THALAMOCORTICAL RELAY (TCR) CELLS. 
- Each nRT cell receives input from 40 TCR cells. 

- The following cells each receive input from 10 TCR cells: superficial pyramids (RS, FRB),
superficial basket and axoaxonic cells, tufted pyramids (RS, IB),
nontufted RS pyramids, deep axoaxonic cells. 

- Each of the following cells receives input from 20 TCR cells: spiny stellates,
deep baskets. LTS interneurons do not receive input from TCR
cells (Gibson et al. 1999). 

INPUTS FROM NUCLEUS RETICULARIS (NRT) CELLS. 
- TCR cells each receive input from 30 nRT cells; nRT cells each receive input from 10
nRT cells. 

*** Knox model (oversimplified)
*** Bhattacharya neural mass model (oversimplified conn; eg 1 pyr pop)
- https://www.sciencedirect.com/science/article/abs/pii/S0893608011000839?via%3Dihub
- https://senselab.med.yale.edu/modeldb/ShowModel?model=138970#tabs-1
*** Budinger 2018 (cites other refs; havent' checked)
- Huang and Winer 2000
- Verbny et al. 2006; Lee and Sherman 2008
- Oviedo et al. 2010; Meng et al. 2015
** subcellular conn (dendritic distribution of syns)
*** A1 E/I->E/I
**** Allen V1 (fig 4F)
LGN -> E: dendrites >150um
E -> E2/3,4: soma,dendrites <200um
E -> E5,6: soma,dendrites (all)
E -> I: soma, dendrite (all)
PV -> E,I: soma, dendrites (<50um)
SOM -> E,I: dendries (>50um)
NGF -> E,I: apical dends
NGF2-6 -> E,I: dendrites (50-350um)
***** Note from Allen: didn't get epsps if target only apical -- take into account for model!
Note, however, that during our post-synaptic-potential optimization (see below), we had to change the rules of synaptic placement when L1 was the source onto excitatory cells. Our optimization methodology would create 100 target cells of a specific cell model that receive 1 spike at 0.5 seconds and we would record the generated postsynaptic potential (PSP). The weight would be scaled until we were within 1% of the target PSP. We observed that the when L1 was the source impinging on excitatory cells, the targets sections were so far away that the somatic PSP would reach a maximum and never match the target PSP regardless of how strongly the weight was scaled. This was due to the most distal compartments reaching their maximum membrane deviation that is equal to the reversal potential of the synaptic drive. With these distal compartments being at their maximum, and the attenuation that occurs due to dendritic filtering (recall dendrites in our model are passive), the soma would reach a maximum PSP that did not match our target values.
Thus, to address this issue, we changed the synaptic placement rules for all L1-to-Excitatory neurons so that synapses were placed on dendrites at 50 μm or further from the soma. This is just a highly simplified approximation, but, in terms of reaching closer to the soma than our original rules, it is reasonable since L1 neurogliaform cells are known to bulk release GABA into large volumes and not form well-targeted synapses with post-synaptic cells (Szabadics, Tamás and Soltesz, 2007; Oláh et al., 2009; Tremblay, Lee and Rudy, 2016).
**** Tremblay 2016 (fig 3)
- NGF1 -> E2,3,4: apic_tuft
- NGF2,3,4 -> E2,3,4: apic_trunk
- SOM2,3,4 -> E2,3,4: all_dend (not close to soma)
- PV2,3,4 -> E2,3,4: close to soma 
- SOM5,6 -> E2,3,4: all_dend (not close to soma)

- NGF1 -> E5,6: apic_tuft
- NGF2,3,4 -> E5,6: apic_uppertrunk
- NGF5,6 -> E5,6: apic_lowertrunk
- SOM5,6 -> E5,6: all_dend (not close to soma)
- PV5,6 -> E5,6: close to soma 

*** TC -> soma + non-apical dends
*** TCM -> E apical dends
** Thalamic interneuron conn
*** convert data on %syn but not prob conn
- need total num syns and number of cells on each pop 
*** num syn contacts (SC) in cat MGBv interneurons
A "standard" interneuron possesses about
11,000 SC. Among them, about 5500 SC (1200 of RL
group, 2600 of RS group, 1200 of F group, and 400 of
UT group) are localized on the soma and dendrites of
this cell, while about the same number (5500) of SC are
the contacts distributed on the P-PST, which are the
dendritic terminals of the interneuron. Within the latter
SC population, 1400 SC belong to the RL group, 1000
to the RS, 200 to the F, 2700 to the P, and 200 to the
UT group. 

RL --> inferior colliculus: 1200+1400=2600 (24%)
RS --> axon terminals from A1 neurons: 2600+1000=3600 (33%)
F --> reticular: 1200+200=1400 (13%)
P--> thal interneurons: 2700=2700 (25%)
UT --> unidentified: 400+200=600 (5%)
TOTAL: 10,900

*** num cells in model with diam 200um; total 12958
**** cortex - 12187
NGF1 151
IT2 338
SOM2 5
PV2 13
VIP2 16
NGF2 11
IT3 4461
SOM3 70
PV3 176
VIP3 211
NGF3 150
ITP4 837
ITS4 837
SOM4 24
PV4 93
VIP4 13
NGF4 14
IT5A 359
CT5A 359
SOM5A 43
PV5A 73
VIP5A 10
NGF5A 8
IT5B 471
CT5B 471
PT5B 471
SOM5B 112
PV5B 134
VIP5B 17
NGF5B 24
IT6 1009
CT6 1009
SOM6 63
PV6 84
VIP6 12
NGF6 38
**** thal - 721
TC 116
TCM 155
HTC 38
IRE 155
IREM 155
TI 102
IC 50

*** prob conn
equations:
IC->TI_prob * 50 = 0.24 * TOTAL
CT->TI_prob * (359+471+1009) = 0.33 * TOTAL
RE->TI_prob * (155+155) = 0.13 * TOTAL
TI->TI_prob * 102 = 0.25 * TOTAL 

solving for probs:
IC->TI_prob = 0.24 * TOTAL / 50
CT->TI_prob = 0.33 * TOTAL / (359+471+1009)
RE->TI_prob = 0.13 * TOTAL / (155+155)
TI->TI_prob = 0.25 * TOTAL / 102

assuming, TOTAL1 = 10900 / 5 contacts/syn * 0.5 (only modeling 200um) = 1090
IC->TI_prob = 0.24 * 1090 / 50 = 5.2 (!! increase IC to >= 262)
CT->TI_prob = 0.33 * 1090 / (359+471+1009) =  0.20
RE->TI_prob = 0.13 * 1090 / (155+155) = 0.46
TI->TI_prob = 0.25 * 1090 / 102 = 2.67 (!! increase TI >= 273)

assuming, TOTAL2 = 10900 / 5 contacts/syn * 0.2 (only modeling 200um) = 436:
IC->TI_prob = 0.24 * 436 / 50 = 2.1 (!! increase IC to >=105)
CT->TI_prob = 0.33 * 436 / (359+471+1009) = 0.078
RE->TI_prob = 0.13 * 436 / (155+155) = 0.18
TI->TI_prob = 0.25 * 436 / 102 = 1.06 (!! increase TI to >= 109)

assuming, TOTAL3 = 10900 / 5 contacts/syn * 0.1 (only modeling 200um) = 218:
IC->TI_prob = 0.24 * 218 / 50 = 1.046 (!! increase IC to >= 53); if increase IC to 200 cells --> 0.26
CT->TI_prob = 0.33 * 218 / (359+471+1009) = 0.039
RE->TI_prob = 0.13 * 218 / (155+155) = 0.091
TI->TI_prob = 0.25 * 218 / 102 = 0.534

note eqns hold for single cell:
prob = avg_syns_in_single_post_cell / pre_pop_size = (total_syns / post_pop_size) / pre_pop_size = total_syns / (pre_pop_size * post_pop_size)

*** conclusions
- potentially need to increase ratio of thal cells to conn
- for A1 column of diam 200um we have 12187 cortical cells and only 721 thal cells 
- our current ratio of thal:A1 = 16.9:1
- “Our results suggest an LGN-V1 expansion ratio between 17:1 and 40:1, similar to values reported previously for visual cortex, and other sensory pathways [refs include A1]” (Coen-Cagli et al 2017; F1000Res)

Resulting prob conns with current assumptions:
- IC->TI: 26%
- CT->TI: 4%
- RE->TI: 9%
- TI->TI: 53%

*** calculate TI -> TC
calculate:
TI -> TC based on above num syns TI->TI and following TI outputs:
- TC relay cell: 92%
- Thalamic interneurons: ~8% (7+1) 

TI->TI prob = 0.534 -> divergence = 

- prob = nconn / (preN * postN)
- nconn = 0.534 * (102*102) = 5,556
- conv = nconn / postN = 5,556 / 102 = 55
- div = nconn / preN = 55

TI outputs:
- to TI = 8% = 55
- to TC = 92% = 55 / 0.08 = 688 (=divergence)
- note: TC includes TC+TCM+HTC

- TI->TC nconn = div * 102 = 688 * 102 = 70,176
- TI->TC prob   = nconn / (preN * postN) 
                = 70,176 / (102 * (116+38+155)) 
                = 70,176 / (102*309) 
                = 70,176 / 31,518 
                = 2.22

*** TI -> TC method 2:
- From Serkov 1996:
9100 SC of different groups are distributed on a single
"standard" relay neuron of the MGBv of the cat.
Among them, about 1200, 5200, 1200, 1100, and 400
SC are formed by RL-, RS-, F-, P-, and UT-terminals,
respectively. A "standard" interneuron possesses about
11,000 SC. Among them, about 5500 SC (1200 of RL
group, 2600 of RS group, 1200 of F group, and 400 of
UT group) are localized on the soma and dendrites of
this cell, while about the same number (5500) of SC are
the contacts distributed on the P-PST, which are the
dendritic terminals of the interneuron. Within the latter
SC population, 1400 SC belong to the RL group, 1000
to the RS, 200 to the F, 2700 to the P, and 200 to the
UT group.

RL --> inferior colliculus: 1200 (13%)
RS --> axon terminals from A1 neurons: 5200 (57%)
F --> reticular: 1200 (13%)
P--> thal interneurons: 1100 (12%)
UT --> unidentified: 400 (5%)
TOTAL = 9100 syns

IC->TC_prob * 50 = 0.13 * TOTAL
CT->TC_prob * (359+471+1009) = 0.57 * TOTAL
RE->TC_prob * (155+155) = 0.13 * TOTAL
TI->TC_prob * 102 = 0.12 * TOTAL 

assuming, TOTAL3 = 9100 / 5 contacts/syn * 0.1 (only modeling 200um) = 182:
IC->TC_prob = 0.13 * 182 / 50 = 0.47  if increase IC to 200 cells --> 0.12
CT->TC_prob = 0.57 * 182 / (359+471+1009) = 0.056
RE->TC_prob = 0.13 * 182 / (155+155) = 0.076
TI->TC_prob = 0.12 * 182 / 102 = 0.21

- Calculated values approx match what we already had in model:
RE -> TC = 0.1 (~=0.076)
CT -> TC = 0.1 (~=0.056)
IC -> TC = we made it up (~=0.12) :slightly_smiling_face:


* VERSIONS
** v7 - Added template for connectivity
** v8 - Added cell types
** v9 - Added local connectivity
** v10 - Added thalamic populations from prev model
** v11 - Added thalamic conn from prev model
** v12 - Added CT cells to L5B
** v13 - Added CT cells to L5A
** v14 - Fixed L5A & L5B E cell densities + added CT5A & CT5B to 'Epops'
** v15 - Added cortical and thalamic conn to CT5A and CT5B 
** v16 - Updated multiple cell types
** v17 - Changed NGF -> I prob from strong (1.0) to weak (0.35)
** v18 - Fixed bug in VIP cell morphology
** v19 - Added in 2-compartment thalamic interneuron model 
** v20 - Added TI conn and updated thal pop
** v21 - Added exc+inh bkg inputs specific to each cell type
** v22 - Made exc+inh bkg inputs specific to each pop; automated calculation
** v23 - IE/II specific layer gains and simplified code (assume 'Allen_custom')
** v24 - Fixed bug in IE/II specific layer gains
** v25 - Fixed subconnparams TC->E and NGF1->E; made IC input deterministic
** v26 - Changed NGF AMPA:NMDA ratio 
** v27 - Split thalamic interneurons into core and matrix (TI and TIM)
** v28 - Set recurrent TC->TC conn to 0
** v29 - Added EI specific layer gains
** v30 - Added EE specific layer gains; and split combined L1-3 gains into L1,L2,L3
** v31 - Added EI postsyn-cell-type specific gains; update ITS4 and NGF
** v32 - Added IE presyn-cell-type specific gains
** v33 - Fixed bug in matrix thalamocortical conn (were very low)
** v34 - Added missing conn from cortex to matrix thalamus IREM and TIM
** v35 - Parametrize L5B PT Ih and exc cell K+ conductance (to simulate NA/ACh modulation) 
* SIMS
** v11_manualTune/sim1
- scale 0.05
- x,z = 400um
- tuning params for sfn19 
- reduced bkg inputs weight and rate since before depol block

- results:
-- plotting of cell traces based on (pop,index) not working for multiple cores
-- still some depol block in E and SOM

** v11_manualTune/sim2
- test only bkg inputs
- use single core for now to avoid plotting issue
- voltage traces look better
- suggests maybe reducing local conn weights

** v11_manualTune/sim3
- reduced local conn weights by 50%
- set weightNorm of CT and TC
- reduced bkg from 50 to 40hz

-results:
-- still dep block and weird voltage shapes

** v11_manualTune/sim4
- reduced even more weightNorm (from 0.0025 to 0.001)

- getting better

** v11_manualTune/sim5
- reduced even more weightNorm (from 0.001 to 0.0005)
** v11_manualTune/sim6
- reduced even more weightNorm (from 0.0005 to 0.0001)
** v11_manualTune/sim7
- reduced EE/EI gain to 0.25
** v11_manualTune/sim8
cfg.EEGain = 1.0 * 0.25
cfg.EIGain = 1.0 
cfg.IEGain = 1.0 
cfg.IIGain = 1.0 
cfg.weightBkg = {'E': 0.5*0.025, 'I': 0.5*0.025, 'ThalE': 0.5*0.025, 'ThalI': 0.5*0.025}

- better, got some real oscillations

** v11_manualTune/sim9
cfg.weightBkg = {'E': 0.5*0.01, 'I': 0.5*0.01, 'ThalE': 0.5*0.01, 'ThalI': 0.5*0.01}

** v11_manualTune/sim10
cfg.EEGain = 1.0 * 0.25
cfg.EIGain = 1.0 * 0.5
cfg.IEGain = 1.0 * 1.5
cfg.IIGain = 1.0 * 1.5

worse looking shapes

** v11_manualTune/sim11
sim9 with 0.05 density, recordLFP and 1 sec

Cells: 2518
  Connections: 234320 (93.06 per cell)
  Synaptic contacts: 425658 (169.05 per cell)
  Spikes: 9685 (3.85 Hz)
  Simulated time: 1.0 s; 4 workers
  Run time: 7274.30 s
Saving output as data/v11_manualTune//v11_sim11.pkl ... 
Finished saving!
Saving output as data/v11_manualTune//v11_sim11.json  ... 
Finished saving!
  Done; saving time = 1.59 s.
Total time = 7370.49 s

- all depol block and many traces blank (not sure why)!
- should try to calcualte weightNorm


** v11_batch1-6 - weightNorm for all cells

# ----------------------------------------------------------------------------------------------
# Weight Normalization 
# ----------------------------------------------------------------------------------------------
def weightNorm(pops=[], rule = None, segs = None, allSegs = True, weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg import cfg
    from netParams import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 1.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg[('analysis','plotTraces','include')] = []
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    
    ## turn off components not required
    #initCfg[('analysis', 'plotRaster')] = False
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['addBkgConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = 0
 
    ## set netstim params
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 1.0]
    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)

    return b

    popsWeightNorm =    {'IT2_A1': ['IT2', 'IT3', 'ITP4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6'],
                        'ITS4_reduced': ['ITS4'],
                        'PV_reduced': ['PV2', 'SOM2'],
                        'VIP_reduced': ['VIP2'],
                        'NGF2': ['NGF2'],
                        'RE_reduced': ['RE', 'TC', 'HTC']}
 
    batchIndex = 1
    for k, v in popsWeightNorm: 
        b = weightNorm(pops=v, rule=k)
        b.batchLabel = 'v11_batch'+str(batchIndex) 
        b.saveFolder = 'data/'+b.batchLabel
        b.method = 'grid'  # evol
        setRunCfg(b, 'mpi_bulletin')
        b.run()  # run batch
        batchIndex += 1


    then run analysis/wscale.py

** v11_batch7 - EI balance
def EIbalance():
    params = specs.ODict()

    params['EEGain'] = [0.5, 1.0, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5]
    params[('weightBkg', 'E')] = [2.0, 3.0]
    params[('weightBkg', 'I')] = [2.0, 3.0]
    
    groupedParams =  []

    # initial config
    initCfg = {}
    initCfg['duration'] = 1.0 * 1e3
    initCfg['scaleDensity'] = 0.05
    
    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    return b

*** results
reasonable rates for most pops (no osc):
- 10 00 10
- 11 01 10
- 12 02 10
- 22 02 11
- 22 00 10 - slow osc
** v11_batch8 - weightNorm for thalamic cells after fixing
*** note on version
this should have been v15, not v11
*** code
def weightNorm(pops=[], rule = None, segs = None, allSegs = True, weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg_cell import cfg
    from netParams_cell import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 1.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['removeWeightNorm'] = True
    initCfg[('analysis','plotTraces','include')] = []
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    
    ## turn off components not required
    #initCfg[('analysis', 'plotRaster')] = False
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['addBkgConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = 0
 
    ## set netstim params
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 2.0]
    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)
*** results
generated new weightNorm pkl files
now values are reasonable -- not negative as before

** v16_batch1 - Small parameter on full net 200x200 um (12k cells); to get baseline
*** code
def custom():
    params = specs.ODict()

    params[('weightBkg', 'E')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'I')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'ThalE')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'ThalI')] = [1.0] #[0.1, 0.5, 1.0]
    
    params[('weightInput', 'ThalE')] = [0.0, 1.0] #[0.0, 0.5, 1.0]
    params[('weightInput', 'ThalI')] = [0.0, 1.0] # [0.0, 0.5, 1.0]
    
    groupedParams = []

    # initial config
    initCfg = {}
    initCfg['duration'] = 2.0*1e3
    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b 

*** memory error 
slurmstepd: error: Detected 700 oom-kill event(s) in step 5304.batch cgroup. Some of your processes may have been killed by the cgroup out-of-memory handler.
*** try running on 2*96 cores
memory error
*** try running on 4*96 cores
memory error
*** try running 200um (12k cells) on 4*96 cores
worked but subconn bug
*** fixed subconn and added weightNorm
*** tried running 250um (20k cells) on 4*96 cores
memory error
*** tried running 250um (20k cells) on 8*96 cores
memory error
*** running 200um (12k cells) on 4*96 cores - results ok
- ITS4 really high 250hz
- ngf pops firing weirdly

*** if not try highmem-96
*** if not try smaller net
** v16_batch2 - Small parameter on 200x200 um (12k cells); to get baseline; after fixing bursting
*** fixed bugs
- ITS4 v_init
- weighNorm of multiple cell types; including NGF with wrong filename
*** tuned params
- increased bkg weights * 5
- reduced ITS4 weightNorm * 5
** v20_batch1 - Added TI; testing only bkg and with conn
*** notes
- failed in g1 -- saturated with params?
- rerunning on g2 (non-preempt)
*** code
def custom():
    params = specs.ODict()

    # bkg inputs
    factor = 5
    
    params['addConn'] = [0, 1]

    params[('weightBkg', 'E')] = [0.5*factor]
    params[('weightBkg', 'I')] = [0.5*factor]
    params[('weightBkg', 'ThalE')] = [0.5*factor]
    params[('weightBkg', 'ThalI')] = [0.5 * factor]

    # params[('rateBkg', 'E')] = [40] #[20, 60]  
    # params[('rateBkg', 'I')] = [40] #
    # params[('rateBkg', 'ThalE')] = [40] #
    # params[('rateBkg', 'ThalI')] = [40] #

    # auditory inputs (cochlea+IC) to thalamus (remove for tuning??)
    # params[('weightInput', 'ThalE')] = [0.5] # [0.25,  0.75] # 0.5 somatic PSP mV 
    # params[('weightInput', 'ThalI')] = [0.5] # [0.25,  0.75] # 0.5 somatic PSP mV 
    # params[('probInput', 'ThalE')] = [0.0] # [0.1, 0.4] # 0.25 probability of conn  
    # params[('probInput', 'ThalI')] = [0.0] # [0.1, 0.4] # 0.25 probability of conn  

    # # conn gains
    # params['EEGain'] = [1.0] #[0.5, 1.5] 
    # params['EIGain'] = [1.0] 
    # params['IEGain'] = [1.0] 
    # params['IIGain'] = [1.0] 

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = False  # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b

*** results
**** only bkg
Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 31237 (1.59 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 13.400 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.688 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.000 Hz
   SOM3 : 12.229 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.611 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.000 Hz
   ITS4 : 17.613 Hz
   SOM4 : 13.125 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.231 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 13.047 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.600 Hz
   NGF5A : 0.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5B : 13.473 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.941 Hz
   NGF5B : 0.000 Hz
   IT6 : 0.012 Hz
   CT6 : 0.000 Hz
   SOM6 : 13.159 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.583 Hz
   NGF6 : 0.000 Hz
   TC : 0.207 Hz
   TCM : 0.077 Hz
   HTC : 0.158 Hz
   IRE : 5.665 Hz
   IREM : 6.000 Hz
   TI : 2.029 Hz
   IC : 14.725 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 85.57 s
Saving output as data/v20_batch1/v20_batch1_0_0_0_0_0.json  ... 
Finished saving!
  Done; saving time = 1.75 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 22.17 s
Total time = 202.84 s
**** with bkg+conn
Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 445787 (22.67 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 173.125 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.000 Hz
   SOM3 : 0.000 Hz
   PV3 : 0.000 Hz
   VIP3 : 174.678 Hz
   NGF3 : 13.647 Hz
   ITP4 : 0.000 Hz
   ITS4 : 265.471 Hz
   SOM4 : 0.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 93.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   VIP5A : 154.800 Hz
   NGF5A : 468.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.000 Hz
   VIP5B : 157.471 Hz
   NGF5B : 487.375 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 7.905 Hz
   PV6 : 1.440 Hz
   VIP6 : 10.083 Hz
   NGF6 : 0.000 Hz
   TC : 0.043 Hz
   TCM : 0.510 Hz
   HTC : 0.026 Hz
   IRE : 6.826 Hz
   IREM : 6.581 Hz
   TI : 1.863 Hz
   IC : 14.480 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 785.08 s
Saving output as data/v20_batch1/v20_batch1_1_0_0_0_0.json  ... 
Finished saving!
  Done; saving time = 3.98 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 202.85 s
Total time = 1798.94 s
**** conclusions
looks like generally need more bkg
and there might be some issue with ITS4 + VIP + NGF conn … I’ll check
good thing is was pretty fast to run … on 96 cores took 3 min for only bkg, and 30 min for bkg+conn
** v21_batch1 - Evol optim full net; conn params
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.75, 1.25]
    params['EIGain'] = [0.75, 1.25]

    params[('IEweights', 0)] = [0.75, 1.25]
    params[('IEweights', 1)] = [0.75, 1.25]
    params[('IEweights', 2)] = [0.75, 1.25]

    params[('IIweights', 0)] = [0.75, 1.25]
    params[('IIweights', 1)] = [0.75, 1.25]
    params[('IIweights', 2)] = [0.75, 1.25]
    
    params['thalamoCorticalGain'] = [0.75, 1.25]  
    params['intraThalamicGain'] = [0.75, 1.25] 
    params['corticoThalamicGain'] = [0.75, 1.25]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 5, 'min': 0.5}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 15, 'min': 0.25}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 100,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 12, # (5h20) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b
*** results
- 10 generations
- pops always 0 Hz (14/42): IT2, IT3, ITP4, NGF4, PT5B, CT6, PV2, PV3, PV4, PV6, SOM2, SOM3, SOM4 
- pops always too high >200Hz (3/42): ITS4, NGF5A, NGF5B 
- pops sometimes too high >100Hz (6/42): NGF2, NGF3, VIP2, VIP3, VIP5A, VIP5B

cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
                'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
                'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
** v21_batch2 - Param sweep with 5 conn params
*** results
raw results - https://console.cloud.google.com/storage/browser/salvadord_data/v21_batch2/?forceOnBucketsSortingFiltering=false&organizationId=728762063943&project=ecas-2019

firing rate as a func of 4 conn params for each of the 41 pops: https://drive.google.com/open?id=1lZQe3YjX2lGCQsLF_lzc3_FKqTImK-sg

so problematic ones are IT2, IT3 and ITP4 since 0 in most, except a couple with 0.00075 Hz
the trend suggests need to lower more EEGain and increase IIGain
also noticed the IEGain param is not doing anything, so maybe a bug… I’ll check
** v21_batch3 - Param sweep 6 conn params; adjusted EEGain and IIGain; fixed bug IEGain

*** code
params = specs.ODict()

    # bkg inputs
    
    #params['addConn'] = [0, 1]

    params['EEGain'] = [0.25, 0.5, 1.0, 1.5] #[0.5, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5, 2.0]
    params['thalamoCorticalGain'] = [0.5, 1.0, 1.5]  #2.5
    #params['intraThalamicGain'] = [0.5, 1.0, 1.5] #0.5
    params['corticoThalamicGain'] = [0.5, 1.0, 1.5]



    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = False  # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results

- unfortunately no param combination yet that gives decent firing rates in all… 
- the problematic ones still IT2, IT3 and ITP4 (upper layer ITs), with close to 0hz rates 
— I had similar issue with M1 and fixed by tuning gains separate for upper vs lower layers, so will try that next
- there is one param combination >0, but only ~0.1 hz
- 0.01 hz in the case of ITP4

- NGF2-6 too high - also possibly and issue; could be affecting E spiking
- could be result of higher background? 
-- cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
                'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
                'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
-- enhanced sensitivity 
-- maybe tuned based on L1, but L2-6 different, more conn inputs

things to try:
-- tune NGF L2-6 differently
-- tune weights of upper IT separately 
-- VIP 
** v21_tune - adjusting bkg weights
- run for 10 sec instead of 1 -- better stats; avoids depending on initial 500ms
- included all IT cells since different dend lengths
- included all NGF cells to see variability
- v21_tune8:
   NGF1 : 6.100 Hz
   IT2 : 0.000 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 8.300 Hz
   IT3 : 0.000 Hz
   NGF3 : 7.000 Hz
   ITP4 : 7.800 Hz
   ITS4 : 3.000 Hz
   NGF4 : 8.500 Hz
   NGF5A : 6.600 Hz
   PT5B : 0.700 Hz
   NGF5B : 7.400 Hz
   IT6 : 0.200 Hz
   CT6 : 0.700 Hz
   NGF6 : 8.900 Hz
   TC : 22.100 Hz
   HTC : 19.900 Hz
   IRE : 4.400 Hz
   TI : 12.600 Hz
- clearly some fixes required:
-- reduce NGF a bit (80->60)
-- increase IT (except ITP4 low) (12->20)
-- reduce TC (1.8->1.5)
-- reduce HTC (1.55->1.4)
-- reduce TI (3.6->3)

- v56_tune10
-   NGF1 : 0.500 Hz
   NGF1 : 0.500 Hz
   IT2 : 2.300 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 0.700 Hz
   IT3 : 3.300 Hz
   NGF3 : 0.500 Hz
   ITP4 : 14.200 Hz (dep block)
   ITS4 : 3.000 Hz
   NGF4 : 1.100 Hz
   IT5A : 0.800 Hz (dep block)
   NGF5A : 0.300 Hz
   IT5B : 0.400 Hz (dep block)
   PT5B : 1.100 Hz
   NGF5B : 1.300 Hz
   IT6 : 1.500 Hz (dep block)
   CT6 : 1.700 Hz (dep block)
   NGF6 : 1.400 Hz
   TC : 19.300 Hz
   HTC : 18.400 Hz
   IRE : 5.500 Hz
   TI : 6.300 Hz
- changes:
-- IT down (20->16)
-- NGF up a bit (60->65)
-- reduce TC (1.5 -> 1)
-- reduce HTC  (1.55 -> 1)

- v56_tune11
   NGF1 : 1.500 Hz
   IT2 : 0.400 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 2.300 Hz
   IT3 : 0.800 Hz
   NGF3 : 1.800 Hz
   ITP4 : 14.600 Hz (Dep block)
   ITS4 : 3.000 Hz
   NGF4 : 2.400 Hz
   IT5A : 0.200 Hz (dep block)
   NGF5A : 1.100 Hz
   IT5B : 0.200 Hz
   PT5B : 1.100 Hz
   NGF5B : 2.300 Hz
   IT6 : 0.500 Hz (dep block)
   CT6 : 1.700 Hz (dep block)
   NGF6 : 3.000 Hz
   TC : 17.000 Hz
   HTC : 14.100 Hz
   IRE : 5.500 Hz
   TI : 6.300 Hz

- tune automatically for each cell type
** v22_batch1 - bkg weights for all pops (E+I 40 hz)
*** code
def bkgWeights(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkg'] = weights

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
 

    b = Batch(params=params, netParamsFile='netParams_bkg.py', cfgFile='cfg_cell.py', initCfg=initCfg)

    return b
*** results
Calculating bkg weights for each pop ...
Bkg weight to get 2.0 Hz in pop IT2 = 19.5
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 18.1
Bkg weight to get 2.0 Hz in pop ITP4 = 9.4
Bkg weight to get 2.0 Hz in pop ITS4 = 0.2
Bkg weight to get 2.0 Hz in pop IT5A = 29.3
Bkg weight to get 2.0 Hz in pop CT5A = 15.8
Bkg weight to get 2.0 Hz in pop IT5B = 27.5
Bkg weight to get 2.0 Hz in pop PT5B = 17.2
Bkg weight to get 2.0 Hz in pop CT5B = 15.8
Bkg weight to get 2.0 Hz in pop IT6 = 19.5
Bkg weight to get 2.0 Hz in pop CT6 = 15.8
Bkg weight to get 2.0 Hz in pop TC = 0.4
Bkg weight to get 2.0 Hz in pop HTC = 0.5
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2


** v22_batch2 - bkg weights for all pops (only E 40hz)
*** results
** v22_batch3 - bkg weights for all pops (E 20hz apicdend, I 40 Hz perisom)
*** results
Calculating bkg weights for each pop ...
Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 11.6
Bkg weight to get 2.0 Hz in pop ITP4 = 5.4
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 2.2
Bkg weight to get 2.0 Hz in pop CT5A = 7.4
Bkg weight to get 2.0 Hz in pop IT5B = 29.9
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 7.4
Bkg weight to get 2.0 Hz in pop IT6 = 6.1
Bkg weight to get 2.0 Hz in pop CT6 = 7.4
Bkg weight to get 2.0 Hz in pop TC = 53.3
Bkg weight to get 2.0 Hz in pop HTC = -64.5
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3
** v22_batch4 - bkg weights for all pops (E 20hz apicdend 2*weight, I 40 Hz perisom)
Bkg weight to get 2.0 Hz in pop IT2 = 9.0
Bkg weight to get 4.0 Hz in pop PV2 = 19.7
Bkg weight to get 4.0 Hz in pop SOM2 = 2.9
Bkg weight to get 4.0 Hz in pop VIP2 = 5.5
Bkg weight to get 4.0 Hz in pop NGF2 = 42.2
Bkg weight to get 2.0 Hz in pop IT3 = 5.4
Bkg weight to get 2.0 Hz in pop ITP4 = 19.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 20.4
Bkg weight to get 2.0 Hz in pop CT5A = 3.2
Bkg weight to get 2.0 Hz in pop IT5B = 27.8
Bkg weight to get 2.0 Hz in pop PT5B = 24.5
Bkg weight to get 2.0 Hz in pop CT5B = 3.2
Bkg weight to get 2.0 Hz in pop IT6 = 6.3
Bkg weight to get 2.0 Hz in pop CT6 = 3.2
Bkg weight to get 2.0 Hz in pop TC = -9.3
Bkg weight to get 2.0 Hz in pop HTC = -8.8
Bkg weight to get 4.0 Hz in pop IRE = -0.1
Bkg weight to get 4.0 Hz in pop TI = 2.2
** v22_batch5 - bkg weights for all pops (E 40hz apicdend, I 40 Hz perisom 2*weight)
Bkg weight to get 2.0 Hz in pop IT2 = 25.0
Bkg weight to get 4.0 Hz in pop PV2 = 32.4
Bkg weight to get 4.0 Hz in pop SOM2 = 6.9
Bkg weight to get 4.0 Hz in pop VIP2 = 12.6
Bkg weight to get 4.0 Hz in pop NGF2 = 89.0
Bkg weight to get 2.0 Hz in pop IT3 = 8.6
Bkg weight to get 2.0 Hz in pop ITP4 = 3.3
Bkg weight to get 2.0 Hz in pop ITS4 = 1.4
Bkg weight to get 2.0 Hz in pop IT5A = 32.1
Bkg weight to get 2.0 Hz in pop CT5A = 5.1
Bkg weight to get 2.0 Hz in pop IT5B = 42.7
Bkg weight to get 2.0 Hz in pop PT5B = -inf
Bkg weight to get 2.0 Hz in pop CT5B = 5.1
Bkg weight to get 2.0 Hz in pop IT6 = 12.7
Bkg weight to get 2.0 Hz in pop CT6 = 5.1
Bkg weight to get 2.0 Hz in pop TC = -inf
Bkg weight to get 2.0 Hz in pop HTC = -54.5
Bkg weight to get 4.0 Hz in pop IRE = 6.5
Bkg weight to get 4.0 Hz in pop TI = 53.0
** v22_batch6- bkg weights for all pops (E 40hz apicdend, I 40 Hz perisom)

Bkg weight to get 2.0 Hz in pop IT2 = 19.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 6.4
Bkg weight to get 2.0 Hz in pop ITP4 = 2.2
Bkg weight to get 2.0 Hz in pop ITS4 = 0.2
Bkg weight to get 2.0 Hz in pop IT5A = 21.0
Bkg weight to get 2.0 Hz in pop CT5A = 4.2
Bkg weight to get 2.0 Hz in pop IT5B = 27.8
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 4.2
Bkg weight to get 2.0 Hz in pop IT6 = 10.2
Bkg weight to get 2.0 Hz in pop CT6 = 4.2
Bkg weight to get 2.0 Hz in pop TC = 0.4
Bkg weight to get 2.0 Hz in pop HTC = 0.5
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2
** v22_batch7 - fI curves for all cell types
** v22_batch8 - fI for new ITP4, IT5A
** v22_batch9 - fI with celsius=36
** v22_batch10 - fI with celsius=34
** v22_batch11 - fI for all cells with temp=36
** v22_batch12 - fI new cells with 37C tuned
** v22_batch13-17 - weightNorm all cells (Except 2) after retuning
*** notes
13 - ITs
16 - VIP
** v22_batch14 (overwrote) - fI for all cells
** v22_batch18-19 - weightNorm for TC and HTC and TI
** v22_batch20 - weightNorm for ITS4 (overwritten accidentally)
** v22_batch21 - bkg weights for all pops (E 20hz apicdend, I 40 Hz perisom) - bug, missing weightNorms
Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 11.6
Bkg weight to get 2.0 Hz in pop ITP4 = 5.0
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 2.0
Bkg weight to get 2.0 Hz in pop CT5A = 9.0
Bkg weight to get 2.0 Hz in pop IT5B = 1.3
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 9.0
Bkg weight to get 2.0 Hz in pop IT6 = 23.0
Bkg weight to get 2.0 Hz in pop CT6 = 9.0
Bkg weight to get 2.0 Hz in pop TC = 3.9
Bkg weight to get 2.0 Hz in pop HTC = 3.9
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3

** v22_batch22 - bkg weights for all pops (E 20hz soma, I 40 Hz soma) - bug, missing weightNorms

Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 21.2
Bkg weight to get 2.0 Hz in pop ITP4 = 2.8
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 7.8
Bkg weight to get 2.0 Hz in pop CT5A = 6.2
Bkg weight to get 2.0 Hz in pop IT5B = 7.8
Bkg weight to get 2.0 Hz in pop PT5B = 20.7
Bkg weight to get 2.0 Hz in pop CT5B = 6.2
Bkg weight to get 2.0 Hz in pop IT6 = 9.7
Bkg weight to get 2.0 Hz in pop CT6 = 6.2
Bkg weight to get 2.0 Hz in pop TC = 3.9
Bkg weight to get 2.0 Hz in pop HTC = 3.9
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3

** v22_batch23 - missing weightNorms for CT5A and CT5B 
** v22_batch24 - bkg weights for all pops (E 40hz soma, I 40 Hz soma) - bug, missing NGF weightNorm!
Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = -106.7
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.4
Bkg weight to get 2.0 Hz in pop CT5A = 16.8
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.8
Bkg weight to get 2.0 Hz in pop CT5B = 16.8
Bkg weight to get 2.0 Hz in pop IT6 = 26.0
Bkg weight to get 2.0 Hz in pop CT6 = 16.8
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

Note: but dynamic range looks better - can probably reduce to max weight 50 and have 0.5 intervals
** v22_batch25 - wnorm for missing NGF
** v22_batch26 - bkg weights for all pops (E 40hz soma, I 40 Hz soma); range 0,50,0.5

Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.6
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.9
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 4.0 Hz in pop NGF2 = inf
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.5
Bkg weight to get 2.0 Hz in pop ITS4 = 0.4
Bkg weight to get 2.0 Hz in pop IT5A = 28.2
Bkg weight to get 2.0 Hz in pop CT5A = 16.5
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.5
Bkg weight to get 2.0 Hz in pop CT5B = 16.5
Bkg weight to get 2.0 Hz in pop IT6 = 29.5
Bkg weight to get 2.0 Hz in pop CT6 = 16.5
Bkg weight to get 2.0 Hz in pop TC = 10.8
Bkg weight to get 2.0 Hz in pop HTC = 10.8
Bkg weight to get 4.0 Hz in pop IRE = 8.7
Bkg weight to get 4.0 Hz in pop TI = 48.2

range not enough to get spikes in NGF

** v22_batch27 - bkg weights for all pops (E 40hz soma, I 40 Hz soma); range 0,100
--> v22_sim1 (still depol block)
Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.4
Bkg weight to get 2.0 Hz in pop CT5A = 16.8
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.8
Bkg weight to get 2.0 Hz in pop CT5B = 16.8
Bkg weight to get 2.0 Hz in pop IT6 = 26.0
Bkg weight to get 2.0 Hz in pop CT6 = 16.8
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

  NGF1 : 5.331 Hz
   IT2 : 2.621 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 2.921 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 2.499 Hz
   ITS4 : 0.006 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 5.437 Hz
   CT5A : 2.535 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 2.335 Hz
   CT5B : 2.584 Hz
   PT5B : 2.575 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 1.679 Hz
   CT6 : 2.454 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 2.405 Hz
   TCM : 2.729 Hz
   HTC : 2.342 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


Calculating bkg weights for each pop ...
Bkg weight to get 1.5 Hz in pop IT2 = 16.5
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.5 Hz in pop IT3 = 15.5
Bkg weight to get 1.5 Hz in pop ITP4 = 13.5
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 18.0
Bkg weight to get 1.5 Hz in pop CT5A = 15.8
Bkg weight to get 1.5 Hz in pop IT5B = 13.0
Bkg weight to get 1.5 Hz in pop PT5B = 15.7
Bkg weight to get 1.5 Hz in pop CT5B = 15.8
Bkg weight to get 1.5 Hz in pop IT6 = 21.2
Bkg weight to get 1.5 Hz in pop CT6 = 15.8
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

-- v22_sim4 (still depol block)
 NGF1 : 5.331 Hz
   IT2 : 1.763 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 1.972 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 2.152 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 9.359 Hz
   CT5A : 1.825 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 3.231 Hz
   CT5B : 1.932 Hz
   PT5B : 1.807 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 2.618 Hz
   CT6 : 1.796 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


- adapted method to gradually increase num points used (avoids depol block)
Bkg weight to get 1.5 Hz in pop IT2 = 16.5
Bkg weight to get 4.0 Hz in pop PV2 = 32.3
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 4.0 Hz in pop NGF2 = 85.0
Bkg weight to get 1.5 Hz in pop IT3 = 15.5
Bkg weight to get 1.5 Hz in pop ITP4 = 13.5
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 9.2
Bkg weight to get 1.5 Hz in pop CT5A = 15.8
Bkg weight to get 1.5 Hz in pop IT5B = 11.1
Bkg weight to get 1.5 Hz in pop PT5B = 15.7
Bkg weight to get 1.5 Hz in pop CT5B = 15.8
Bkg weight to get 1.5 Hz in pop IT6 = 19.6
Bkg weight to get 1.5 Hz in pop CT6 = 15.8
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 2.6

-- v22_sim5
   NGF1 : 10.225 Hz
   IT2 : 1.763 Hz
   SOM2 : 4.800 Hz
   PV2 : 17.692 Hz
   VIP2 : 5.125 Hz
   NGF2 : 11.545 Hz
   IT3 : 1.972 Hz
   SOM3 : 4.400 Hz
   PV3 : 15.500 Hz
   VIP3 : 4.299 Hz
   NGF3 : 10.060 Hz
   ITP4 : 2.152 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 14.495 Hz
   VIP4 : 3.385 Hz
   NGF4 : 8.071 Hz
   IT5A : 1.830 Hz
   CT5A : 1.825 Hz
   SOM5A : 5.186 Hz
   PV5A : 15.356 Hz
   VIP5A : 3.400 Hz
   NGF5A : 9.875 Hz
   IT5B : 3.000 Hz
   CT5B : 1.932 Hz
   PT5B : 1.807 Hz
   SOM5B : 4.938 Hz
   PV5B : 14.478 Hz
   VIP5B : 5.353 Hz
   NGF5B : 9.875 Hz
   IT6 : 3.820 Hz
   CT6 : 1.796 Hz
   SOM6 : 5.095 Hz
   PV6 : 17.690 Hz
   VIP6 : 3.583 Hz
   NGF6 : 9.658 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 4.088 Hz

** v22_batch28 - bkg weights for all pops (E 40hz apic/adend1, I 40 Hz proximal)

*** E 2hz
Bkg weight to get 2.0 Hz in pop IT2 = 17.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 6.2
Bkg weight to get 2.0 Hz in pop ITP4 = 2.3
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.1
Bkg weight to get 2.0 Hz in pop CT5A = 4.3
Bkg weight to get 2.0 Hz in pop IT5B = 31.8
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 4.4
Bkg weight to get 2.0 Hz in pop IT6 = 10.0
Bkg weight to get 2.0 Hz in pop CT6 = 4.3
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

*** if aim for E at 1 Hz then ok: --> v22_sim2
Bkg weight to get 1.0 Hz in pop IT2 = 14.7
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.0 Hz in pop IT3 = 6.0
Bkg weight to get 1.0 Hz in pop ITP4 = 2.2
Bkg weight to get 1.0 Hz in pop ITS4 = 0.1
Bkg weight to get 1.0 Hz in pop IT5A = 12.5
Bkg weight to get 1.0 Hz in pop CT5A = 4.2
Bkg weight to get 1.0 Hz in pop IT5B = 16.4
Bkg weight to get 1.0 Hz in pop PT5B = 23.0
Bkg weight to get 1.0 Hz in pop CT5B = 4.2
Bkg weight to get 1.0 Hz in pop IT6 = 9.0
Bkg weight to get 1.0 Hz in pop CT6 = 4.2
Bkg weight to get 1.0 Hz in pop TC = 9.7
Bkg weight to get 1.0 Hz in pop HTC = 9.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

  NGF1 : 5.331 Hz
   IT2 : 1.086 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.130 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.000 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 18.184 Hz
   CT5A : 1.978 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 13.231 Hz
   CT5B : 2.047 Hz
   PT5B : 0.692 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 20.595 Hz
   CT6 : 1.986 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.155 Hz
   TCM : 1.310 Hz
   HTC : 1.079 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


*** if aim for E at 1.5 Hz then also ok: --> v22_sim3
Bkg weight to get 1.5 Hz in pop IT2 = 16.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.5 Hz in pop IT3 = 6.1
Bkg weight to get 1.5 Hz in pop ITP4 = 2.2
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 18.3
Bkg weight to get 1.5 Hz in pop CT5A = 4.2
Bkg weight to get 1.5 Hz in pop IT5B = 24.1
Bkg weight to get 1.5 Hz in pop PT5B = 34.0
Bkg weight to get 1.5 Hz in pop CT5B = 4.3
Bkg weight to get 1.5 Hz in pop IT6 = 12.0
Bkg weight to get 1.5 Hz in pop CT6 = 4.2
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

   NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.001 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 5.206 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz

*** v22_sim6 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 10% IT6, IPT4,ITS4
  NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.102 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 8.822 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz

   still depol block
*** v22_sim7 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 25% IT6, IPT4,ITS4
   ITP4 : 0.626 Hz
   ITS4 : 0.000 Hz
   IT6 : 20.710 Hz
*** v22_sim8 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 50% IT6, IPT4,ITS4
   ITP4 : 4.576 Hz
   ITS4 : 0.000 Hz
   IT6 : 35.489 Hz
*** v22_sim9 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

   {'ITP4': 1.35, 'ITS4': 2.0, 'IT6': 0.25} 

      ITP4 : 1.730 Hz - ok
   ITS4 : 0.139 Hz - getting there, increase more
   IT6 : 0.126 Hz - too low now, increase

*** v22_sim10 (overwrote sim9) - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

manualScaling = {'ITP4': 1.35, 'ITS4': 2.5, 'IT6': 0.3} 

   ITS4 : 0.980 Hz -- increase a but more: 3.0
   IT6 : 2.796 Hz -- decrease - 0.28

*** v22_sim11- bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

manualScaling = {'ITP4': 1.35, 'ITS4': 3.0, 'IT6': 0.28} 
   ITS4 : 2.202 Hz
   IT6 : 1.150 Hz

*** v22_sim12 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4
   manualScaling = {'ITP4': 1.35, 'ITS4': 2.75, 'IT6': 0.27} 

      ITS4 : 1.558 Hz - ok
   IT6 : 0.708 Hz

*** v22_sim13 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4
   manualScaling = {'ITP4': 1.35, 'ITS4': 2.75, 'IT6': 0.29} 
   IT6 : 1.733 Hz

*** v22_sim14 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); after manual tuning IT6, IPT4,ITS4

  Cells: 12908
  Connections: 12908 (1.00 per cell)
  Synaptic contacts: 38724 (3.00 per cell)
  Spikes: 57788 (2.98 Hz)
   NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 1.767 Hz
   ITS4 : 1.578 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 2.169 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz
  Simulated time: 1.5 s; 4 workers
  Run time: 852.08 s

-- took quite a bit of manual tuning to fix those 3 cell types, but got nice results now… all spiking ~1-5 hz and no depol block
-- NOT TRUE!!! - IT5A, IT5B higher!


** v22_batch29 - Param sweep for conn
*** code
    params = specs.ODict()

    # conn gains
    params['EEGain'] = [0.5, 1.0, 1.5] #[0.5, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5, 2.0]
    #params['thalamoCorticalGain'] = [0.5, 1.0, 1.5]  #2.5
    #params['intraThalamicGain'] = [0.5, 1.0, 1.5] #0.5
    #params['corticoThalamicGain'] = [0.5, 1.0, 1.5]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b
** v22_batch30 - explore NGF2+IT2 response to bkg inputs (4D params)
*** code

b = bkgWeights2D(pops = ['NGF2', 'IT2'], weights = list(np.arange(0,150,10)))

def bkgWeights2D(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkgE'] = weights
    params['weightBkgI'] = weights
    params[('rateBkg', 'exc')] = [20, 40, 60, 80]
    params[('rateBkg', 'inh')] = [20, 40, 60, 80]

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    initCfg[('rateBkg', 'exc')] = 40
    initCfg[('rateBkg', 'inh')] = 40

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
** v22_batch31 - evol optim network (IE, II bug)
*** notes
bug in IE,II params
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.5, 1.5]
    params['EIGain'] = [0.5, 1.5]

    params[('IEweights', 0)] = [0.5, 1.5]
    params[('IEweights', 1)] = [0.5, 1.5]
    params[('IEweights', 2)] = [0.5, 1.5]

    params[('IIweights', 0)] = [0.5, 1.5]
    params[('IIweights', 1)] = [0.5, 1.5]
    params[('IIweights', 2)] = [0.5, 1.5]
*** results
gen_0_cand9: 
- cell 151 (IT2), 489 (SOM2), 494 (PV2), 507 (VIP2) - depol
- cell 6439 (ITS4) - high rate 
** v22_batch32 - explore ITS4 response to bkg inputs (4D params)
*** code
b = bkgWeights2D(pops = ['ITS4'], weights = list(np.arange(0,150,10)))

def bkgWeights2D(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkgE'] = weights
    params['weightBkgI'] = weights
    params[('rateBkg', 'exc')] = [20, 40, 60, 80]
    params[('rateBkg', 'inh')] = [20, 40, 60, 80]

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    initCfg[('rateBkg', 'exc')] = 40
    initCfg[('rateBkg', 'inh')] = 40

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
** v23_batch1 - evol optim network 
*** note 
- running with scale density 50% 
-- small toy nets have all cells spiking
-- maybe issue is network scale -- cecilia's paper modifies weights by squared of scaling factor

- saving screen output to sim folder: https://stackoverflow.com/questions/54369613/cant-start-linux-screen-with-logging-to-specific-output-file
*** code

  # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.5, 1.5]
    params['EIGain'] = [0.5, 1.5]

    params[('IELayerGain', '1-3')] = [0.5, 1.5]
    params[('IELayerGain', '4')] = [0.5, 1.5]
    params[('IELayerGain', '5')] = [0.5, 1.5]
    params[('IELayerGain', '6')] = [0.5, 1.5]

    params[('IILayerGain', '1-3')] = [0.5, 1.5]
    params[('IILayerGain', '4')] = [0.5, 1.5]
    params[('IILayerGain', '5')] = [0.5, 1.5]
    params[('IILayerGain', '6')] = [0.5, 1.5]
    
    params['thalamoCorticalGain'] = [0.5, 1.5]  
    params['intraThalamicGain'] = [0.5, 1.5] 
    params['corticoThalamicGain'] = [0.5, 1.5]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 100,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 9, # (45) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b

** v23_batch2 - evol optim network - density 50%
*** note 
- running with scale density 50% 
-- small toy nets have all cells spiking
-- maybe issue is network scale -- cecilia's paper modifies weights by squared of scaling factor

- saving screen output to sim folder: https://stackoverflow.com/questions/54369613/cant-start-linux-screen-with-logging-to-specific-output-file
*** code


** v23_batch3 - evol optim network - lower EE (0.1-0.5); longer evol timeout
*** note 
noticed mostly spiking too high or depol blocks; reduce overall excitation
*** code

** v23_batch4 - evol optim network - lower EE+EI (0.1-0.5); longer evol timeout
*** note
- noticed mostly spiking too high or depol blocks; reduce overall excitation to inh cells too
- fitness 237
- error when running 2 evol at same time - jobs of longer duration one get cancelled when jobs submitted


** v23_batch5- evol optim network - density 50%; lower EE+EI (0.1-0.5); wider range for IE+II (0.25-2.0)
*** note
make more flexible the IE II
** v23_batch6 - empty
** v23_batch7 - best soln from v23_batch5; explored thal conn
*** code
    params['EEGain'] = [0.10928952347451457, 0.05]
    params['EIGain'] = [0.13089042807412776, 0.05]
    params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 3000
    initCfg['printPopAvgRates'] = [250, 3000] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371
    initCfg[('IELayerGain', '4')]=1.961577378323746
    initCfg[('IELayerGain', '5')]=0.73154575340036
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394
    initCfg[('IILayerGain', '4')]=0.5633033925996949
    initCfg[('IILayerGain', '5')]=1.674448267759582
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
** v23_batch8 - best soln from v23_batch5; explored thal conn (shorter sim)
*** code
    params['EEGain'] = [0.10928952347451457, 0.05]
    params['EIGain'] = [0.13089042807412776, 0.05]
    params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371
    initCfg[('IELayerGain', '4')]=1.961577378323746
    initCfg[('IELayerGain', '5')]=0.73154575340036
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394
    initCfg[('IILayerGain', '4')]=0.5633033925996949
    initCfg[('IILayerGain', '5')]=1.674448267759582
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
** v23_batch9 - evol optim
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.1, 1.0]
    params['EIGain'] = [0.1, 1.0]

    params[('IELayerGain', '1-3')] = [0.25, 2.0]
    params[('IELayerGain', '4')] = [0.25, 2.0]
    params[('IELayerGain', '5')] = [0.25, 2.0]
    params[('IELayerGain', '6')] = [0.25, 2.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
best fitness so far
of course as mentioned fitness only looks at avg rate across 1 sec so not always best measure
but interesting because starting to show some osc
if look at this fig it’s clear that best soln’s are for the lowr EE gains — in this case range was 0.1 - 1.0
since still want to reduce excitability more potentially could reduce range of EEgain explore more (eg. [0.05, 0.25]) … however to avoid scaling down EE so much from orig values, was thinking of also trying to increase the range of IE more — currently [0.5, 2.0] so maybe allowing up to 4.0 or 5.0 … which I think should have similar effect to lowering EE
** v23_batch10 - evol optim net - density 100%; EE (0.05-0.5); EI (0.5-5.0)
*** notes
best fitness so far
of course as mentioned fitness only looks at avg rate across 1 sec so not always best measure
but interesting because starting to show some osc
if look at this fig it’s clear that best soln’s are for the lowr EE gains — in this case range was 0.1 - 1.0
since still want to reduce excitability more potentially could reduce range of EEgain explore more (eg. [0.05, 0.25]) … however to avoid scaling down EE so much from orig values, was thinking of also trying to increase the range of IE more — currently [0.5, 2.0] so maybe allowing up to 4.0 or 5.0 … which I think should have similar effect to lowering EE
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 1.0]

    params[('IELayerGain', '1-3')] = [0.25, 5.0]
    params[('IELayerGain', '4')] = [0.25, 5.0]
    params[('IELayerGain', '5')] = [0.25, 5.0]
    params[('IELayerGain', '6')] = [0.25, 5.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


** v23_batch11 - evol optim test new fitness func
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 2.0]

    params[('IELayerGain', '1-3')] = [0.25, 5.0]
    params[('IELayerGain', '4')] = [0.25, 5.0]
    params[('IELayerGain', '5')] = [0.25, 5.0]
    params[('IELayerGain', '6')] = [0.25, 5.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k][(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k][(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness

    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 10,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 9, # max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b

** v23_batch12 - evol optim, new fitness func, 50% density; increased ranges
*** notes
- can increase weight ranges because not taking into account num syns / conn
- total weight = syn weight * num syns * electrotonic -- many unknown variables == allowed variability 
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 2.0]

    params[('IELayerGain', '1-3')] = [0.1, 10.0]
    params[('IELayerGain', '4')] = [0.1, 10.0]
    params[('IELayerGain', '5')] = [0.1, 10.0]
    params[('IELayerGain', '6')] = [0.1, 10.0]

    params[('IILayerGain', '1-3')] = [0.1, 10.0]
    params[('IILayerGain', '4')] = [0.1, 10.0]
    params[('IILayerGain', '5')] = [0.1, 10.0]
    params[('IILayerGain', '6')] = [0.1, 10.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]
*** results
gen_63_cand_19 - fitness 148.92

 EE 0.3303517319869238	
 EI 0.100023011	
 IE13 9.186950686 (1.0)
 IE4 6.160878748 (1.0)	
 IE5 1.729074111 (1.0)
 IE6 8.10671124 
 II1-3 8.454681919 (1.0)
 II4 9.44874377 (1.0)
 II5 2.310556658 (1.0)
 II6 1.578557048 
 TC 1.99495686	
 IT 0.521592918	 
 CT 1.6131164721326399]

 
** v24_batch1 - evol optim after fixing IE, II
*** note
only IE and II in L6 were working 
*** code
    # bkg inputs
    params['EEGain'] = [0.1, 1.0]
    params['EIGain'] = [0.2, 5.0]

    params[('IELayerGain', '1-3')] = [0.2, 5.0]
    params[('IELayerGain', '4')] = [0.2, 5.0]
    params[('IELayerGain', '5')] = [0.2, 5.0]
    params[('IELayerGain', '6')] = [0.2, 5.0]

    params[('IILayerGain', '1-3')] = [0.2, 5.0]
    params[('IILayerGain', '4')] = [0.2, 5.0]
    params[('IILayerGain', '5')] = [0.2, 5.0]
    params[('IILayerGain', '6')] = [0.2, 5.0]
    
    params['thalamoCorticalGain'] = [0.2, 5.0]  
    params['intraThalamicGain'] = [0.2, 5.0] 
    params['corticoThalamicGain'] = [0.2, 5.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
gen 38 cand 28 - fitness = 275.8

 EE 0.824146321526465	
 EI 0.200942767	
 IE13 3.751053243	
 IE4 4.780020172	
 IE5 0.200490707	
 IE6 4.742310303	
 II13 0.201356072	
 II4 1.846409498	
 II5 4.904555212	
 II6 2.374453718	
 TC 1.820561507	
 IT 0.852553584	 
 CT 3.077182476923463
** v24_batch2 -  evol optim with narrower range of params
*** code
    params['EEGain'] = [0.5, 2.0]
    params['EIGain'] = [0.5, 2.0]

    params[('IELayerGain', '1-3')] = [0.5, 2.0]
    params[('IELayerGain', '4')] = [0.5, 2.0]
    params[('IELayerGain', '5')] = [0.5, 2.0]
    params[('IELayerGain', '6')] = [0.5, 2.0]

    params[('IILayerGain', '1-3')] = [0.5, 2.0]
    params[('IILayerGain', '4')] = [0.5, 2.0]
    params[('IILayerGain', '5')] = [0.5, 2.0]
    params[('IILayerGain', '6')] = [0.5, 2.0]
    
    params['thalamoCorticalGain'] = [0.5, 2.0]  
    params['intraThalamicGain'] = [0.5, 2.0] 
    params['corticoThalamicGain'] = [0.5, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
gen 66 cand 8 - fitness = 311
 EE 1.7930365644528616	
 EI 1.301292631	
 IE 13, 4, 5, 6 
    1.9609935	
    1.973369532	
    0.547478256	
    0.817050621	
 II 13, 4, 5, 6
    0.575910457	
    0.506134474	
    1.140789303	
    1.999973065	
TC 1.434715802	
IT  1.987386358	 
CT 1.354024353042513


** v24_batch3 - param sweep starting from a good solution (run on my)
*** note
ran manually on my
modified param set 2, to be -0.3 instead of -0.2
*** code 
    # conn gains
    params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.3] 
    params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.3]
    params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.3]	
    params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.3]
    
    #params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    #params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    
    groupedParams = [('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain'] = 1.7930365644528616
    initCfg['EIGain'] = 1.301292631	
    
    initCfg[('IELayerGain', '1-3')] = 1.9609935	
    initCfg[('IELayerGain', '4')] = 1.973369532	
    initCfg[('IELayerGain', '5')] = 0.547478256	
    initCfg[('IELayerGain', '6')] = 0.817050621	

    initCfg[('IILayerGain', '1-3')] = 0.575910457
    initCfg[('IILayerGain', '4')] = 0.506134474	
    initCfg[('IILayerGain', '5')] = 1.140789303	
    initCfg[('IILayerGain', '6')] = 1.999973065	

    initCfg['thalamoCorticalGain'] = 1.434715802
    initCfg['intraThalamicGain'] = 1.987386358	
    initCfg['corticoThalamicGain'] = 1.354024353042513

*** results
**** 0 (IE orig)
  Cells: 6442
  Connections: 0 (0.00 per cell)
  Spikes: 28832 (2.98 Hz)
   NGF1 : 0.027 Hz
   IT2 : 0.000 Hz
   SOM2 : 26.000 Hz
   PV2 : 2.000 Hz
   VIP2 : 41.000 Hz
   NGF2 : 2.000 Hz
   IT3 : 0.016 Hz
   SOM3 : 23.714 Hz
   PV3 : 3.602 Hz
   VIP3 : 42.210 Hz
   NGF3 : 0.080 Hz
   ITP4 : 0.002 Hz
   ITS4 : 0.079 Hz
   SOM4 : 9.833 Hz
   PV4 : 2.326 Hz
   VIP4 : 72.667 Hz
   NGF4 : 0.857 Hz
   IT5A : 1.564 Hz
   CT5A : 10.894 Hz
   SOM5A : 35.286 Hz
   PV5A : 1.306 Hz
   VIP5A : 2.400 Hz
   NGF5A : 0.500 Hz
   IT5B : 1.260 Hz
   CT5B : 9.723 Hz
   PT5B : 0.072 Hz
   SOM5B : 35.714 Hz
   PV5B : 0.851 Hz
   VIP5B : 2.250 Hz
   NGF5B : 0.583 Hz
   IT6 : 4.020 Hz
   CT6 : 13.966 Hz
   SOM6 : 81.387 Hz
   PV6 : 0.548 Hz
   VIP6 : 11.833 Hz
   NGF6 : 63.737 Hz
   TC : 5.431 Hz
   TCM : 0.442 Hz
   HTC : 6.105 Hz
   IRE : 7.273 Hz
   IREM : 0.545 Hz
   TI : 2.647 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1269.69 s
Saving output as data/v24_batch3/v24_batch3_0_0_0_0.json  ... 
**** 1 (IE -0.1)
  Cells: 6442
  Connections: 0 (0.00 per cell)
  Spikes: 31700 (3.28 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 38.500 Hz
   PV2 : 3.667 Hz
   VIP2 : 33.000 Hz
   NGF2 : 1.200 Hz
   IT3 : 0.065 Hz
   SOM3 : 37.714 Hz
   PV3 : 5.489 Hz
   VIP3 : 34.181 Hz
   NGF3 : 0.067 Hz
   ITP4 : 0.002 Hz
   ITS4 : 0.100 Hz
   SOM4 : 14.250 Hz
   PV4 : 4.239 Hz
   VIP4 : 85.000 Hz
   NGF4 : 1.286 Hz
   IT5A : 1.564 Hz
   CT5A : 12.486 Hz
   SOM5A : 41.857 Hz
   PV5A : 1.417 Hz
   VIP5A : 2.000 Hz
   NGF5A : 0.500 Hz
   IT5B : 1.230 Hz
   CT5B : 12.460 Hz
   PT5B : 0.123 Hz
   SOM5B : 44.482 Hz
   PV5B : 0.955 Hz
   VIP5B : 2.250 Hz
   NGF5B : 0.500 Hz
   IT6 : 3.988 Hz
   CT6 : 15.157 Hz
   SOM6 : 85.161 Hz
   PV6 : 0.524 Hz
   VIP6 : 11.667 Hz
   NGF6 : 71.263 Hz
   TC : 7.517 Hz
   TCM : 0.442 Hz
   HTC : 8.105 Hz
   IRE : 8.091 Hz
   IREM : 0.870 Hz
   TI : 2.863 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1320.76 s
Saving output as data/v24_batch3/v24_batch3_1_1_1_1.json  ... 
Finished saving!
  Done; saving time = 2.22 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 101.98 s

Total time = 3079.45 s
**** 2 (IE -0.3)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 68.500 Hz
   PV2 : 0.333 Hz
   VIP2 : 8.250 Hz
   NGF2 : 0.400 Hz
   IT3 : 0.000 Hz
   SOM3 : 61.943 Hz
   PV3 : 0.864 Hz
   VIP3 : 12.143 Hz
   NGF3 : 0.013 Hz
   ITP4 : 0.000 Hz
   ITS4 : 0.000 Hz
   SOM4 : 19.000 Hz
   PV4 : 5.413 Hz
   VIP4 : 87.333 Hz
   NGF4 : 4.286 Hz
   IT5A : 1.380 Hz
   CT5A : 17.514 Hz
   SOM5A : 54.857 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   NGF5A : 0.000 Hz
   IT5B : 1.064 Hz
   CT5B : 18.817 Hz
   PT5B : 0.000 Hz
   SOM5B : 62.964 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 15.942 Hz
   SOM6 : 91.226 Hz
   PV6 : 0.000 Hz
   VIP6 : 5.167 Hz
   NGF6 : 84.789 Hz
   TC : 8.345 Hz
   TCM : 0.000 Hz
   HTC : 11.842 Hz
   IRE : 8.156 Hz
   IREM : 0.844 Hz
   TI : 3.392 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1261.80 s

** v24_batch4 - v24_batch3 with IC inputs; running 'manually' on NSG
*** code
**** v24_batch4_0
"""
cfg.py 

Simulation configuration for A1 model (using NetPyNE)
This file has sim configs as well as specification for parameterized values in netParams.py 

Contributors: ericaygriffith@gmail.com, salvadordura@gmail.com
"""


from netpyne import specs
import pickle

cfg = specs.SimConfig()

#------------------------------------------------------------------------------
#
# SIMULATION CONFIGURATION
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Run parameters
#------------------------------------------------------------------------------
cfg.duration = 1.5*1e3			## Duration of the sim, in ms -- value from M1 cfg.py 
cfg.dt = 0.05                   ## Internal Integration Time Step -- value from M1 cfg.py 
cfg.verbose = 0         	## Show detailed messages
cfg.hParams['celsius'] = 37
cfg.createNEURONObj = 1
cfg.createPyStruct = 1
cfg.printRunTime = 0.1

cfg.connRandomSecFromList = False  # set to false for reproducibility 
cfg.cvode_active = False
cfg.cvode_atol = 1e-6
cfg.cache_efficient = True
cfg.printRunTime = 0.1
cfg.oneSynPerNetcon = False
cfg.includeParamsLabel = False
cfg.printPopAvgRates = [500, cfg.duration]

#------------------------------------------------------------------------------
# Recording 
#------------------------------------------------------------------------------
cfg.allpops = ['NGF1', 'IT2', 'PV2', 'SOM2', 'VIP2', 'NGF2', 'IT3', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'PV4', 'SOM4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'PV5A', 'SOM5A', 'VIP5A', 'NGF5A', 'IT5B', 'PT5B', 'CT5B', 'PV5B', 'SOM5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'PV6', 'SOM6', 'VIP6', 'NGF6', 'TC', 'TCM', 'HTC', 'IRE', 'IREM', 'TI', 'IC']

alltypes = ['NGF1', 'IT2', 'PV2', 'SOM2', 'VIP2', 'ITS4', 'PT5B', 'TC', 'HTC', 'IRE', 'TI']

cfg.recordTraces = {'V_soma': {'sec':'soma', 'loc':0.5, 'var':'v'}}  ## Dict with traces to record -- taken from M1 cfg.py 
cfg.recordStim = False			## Seen in M1 cfg.py
cfg.recordTime = False  		## SEen in M1 cfg.py 
cfg.recordStep = 0.1            ## Step size (in ms) to save data -- value from M1 cfg.py 

#cfg.recordLFP = [[100, y, 100] for y in range(0, 2000, 400)]+[[100, 2500, 200], [100,2700,200]]

#------------------------------------------------------------------------------
# Saving
#------------------------------------------------------------------------------

cfg.simLabel = 'v24_batch3_0' 
cfg.saveFolder = '.'                	## Set file output name
cfg.savePickle = False         	## Save pkl file
cfg.saveJson = True           	## Save json file
cfg.saveDataInclude = ['simData', 'simConfig', 'netParams'] 
cfg.backupCfgFile = None 		
cfg.gatherOnlySimData = False	 
cfg.saveCellSecs = False		 
cfg.saveCellConns = False		 

#------------------------------------------------------------------------------
# Analysis and plotting 
#----------------------------------------------------------------------------- 

# cellGids = {'NGF1': 0, 'IT2': 45, 'SOM2': 146, 'PV2': 147, 'VIP2': 151, 'NGF2': 155, 'IT3': 158, 'SOM3': 1496, 'PV3': 1517, 'VIP3': 1569, 'NGF3': 1632, 'ITP4': 1677, 'ITS4': 1928, 'SOM4': 2179, 'PV4': 2186, 'VIP4': 2214, 'NGF4': 2218, 'IT5A': 2222, 'SOM5A': 2437, 'PV5A': 2450, 'VIP5A': 2472, 'NGF5A': 2475, 'IT5B': 2477, 'PT5B': 2689, 'SOM5B': 2901, 'PV5B': 2934, 'VIP5B': 2974, 'NGF5B': 2979, 'IT6': 2986, 'CT6': 3288, 'SOM6': 3590, 'PV6': 3609, 'VIP6': 3634, 'NGF6': 3637, 'TC': 3648, 'TCM': 3683, 'HTC': 3729, 'IRE': 3740, 'IREM': 3786}


# popGidRecord = [list(cellGids.values())[i] for i in [6,7,8,9,10,11,12,-1,-2,-3,-4,-5]]

cfg.analysis['plotTraces'] = {'include': [(pop, 0) for pop in alltypes], 'oneFigPer': 'trace', 'overlay': True, 'saveFig': True, 'showFig': False, 'figSize':(12,8)} #[(pop,0) for pop in alltypes]		## Seen in M1 cfg.py (line 68) 
cfg.analysis['plotRaster'] = {'include': cfg.allpops, 'saveFig': True, 'showFig': False, 'popRates': True, 'orderInverse': True, 'timeRange': [0,cfg.duration], 'figSize': (14,12), 'lw': 0.3, 'markerSize': 3, 'marker': '.', 'dpi': 300}      	## Plot a raster
#cfg.analysis['plotLFP'] = {'plots': ['timeSeries', 'PSD', 'spectrogram'], 'saveData': False, 'saveFig': True}
#cfg.analysis['plot2Dnet'] = True      	## Plot 2D visualization of cell positions & connections 


#------------------------------------------------------------------------------
# Cells
#------------------------------------------------------------------------------
cfg.weightNormThreshold = 5.0  # maximum weight normalization factor with respect to the soma

#------------------------------------------------------------------------------
# Synapses
#------------------------------------------------------------------------------
cfg.AMPATau2Factor = 1.0
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio
cfg.synWeightFractionNGF = [0.5, 0.5] # NGF GABAA to GABAB ratio


#------------------------------------------------------------------------------
# Network 
#------------------------------------------------------------------------------
## These values taken from M1 cfg.py (https://github.com/Neurosim-lab/netpyne/blob/development/examples/M1detailed/cfg.py)
cfg.singleCellPops = False
cfg.singlePop = ''
cfg.removeWeightNorm = False
cfg.scale = 1.0     # Is this what should be used? 
cfg.sizeY = 2000.0 #1350.0 in M1_detailed # should this be set to 2000 since that is the full height of the column? 
cfg.sizeX = 200.0 # 400 - This may change depending on electrode radius 
cfg.sizeZ = 200.0
cfg.scaleDensity = 0.5 #0.075 # Should be 1.0 unless need lower cell density for test simulation or visualization


#------------------------------------------------------------------------------
# Connectivity
#------------------------------------------------------------------------------
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionIE = [0.9, 0.1]  # SOM -> E GABAASlow to GABAB ratio (update this)
cfg.synWeightFractionII = [0.9, 0.1]  # SOM -> E GABAASlow to GABAB ratio (update this)

# Cortical
cfg.addConn = 1

cfg.EEGain = 1.7930365644528616 
cfg.EIGain = 1.301292631	
cfg.IEGain = 1.0 #0.75
cfg.IIGain = 1.0 #0.5

## I->E/I layer weights (L1-3, L4, L5, L6)
cfg.IELayerGain = {'1-3': 1.9609935, '4': 1.973369532, '5': 0.547478256, '6': 0.817050621}
cfg.IILayerGain = {'1-3': 0.575910457, '4': 0.506134474, '5': 1.140789303, '6': 1.999973065}

# Thalamic
cfg.addIntraThalamicConn = 1.0
cfg.addIntraThalamicConn = 1.0
cfg.addCorticoThalamicConn = 1.0
cfg.addThalamoCorticalConn = 1.0

cfg.thalamoCorticalGain = 1.434715802
cfg.intraThalamicGain = 1.987386358	
cfg.corticoThalamicGain = 1.354024353042513

cfg.addSubConn = 1


#------------------------------------------------------------------------------
# Background inputs
#------------------------------------------------------------------------------
cfg.addBkgConn = 1
cfg.noiseBkg = 1.0  # firing rate random noise
cfg.delayBkg = 5.0  # (ms)
cfg.startBkg = 0  # start at 0 ms

# cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
#                 'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
#                 'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
cfg.rateBkg = {'exc': 40, 'inh': 40}

## options to provide external sensory input
cfg.randomThalInput = True  # provide random bkg inputs spikes (NetStim) to thalamic populations 

cfg.cochlearThalInput = False #{'numCells': 200, 'freqRange': [9*1e3, 11*1e3], 'toneFreq': 10*1e3, 'loudnessDBs': 50}  # parameters to generate realistic  auditory thalamic inputs using Brian Hears 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 'startTime': 500, 'weightE': 0.5, 'weightI': 0.5, 'probE': 0.12, 'probI': 0.26}  # parameters to generate realistic cochlear + IC input ; weight =unitary connection somatic EPSP (mV)


#------------------------------------------------------------------------------
# Current inputs 
#------------------------------------------------------------------------------
cfg.addIClamp = 0

#------------------------------------------------------------------------------
# NetStim inputs 
#------------------------------------------------------------------------------

cfg.addNetStim = 0

## LAYER 1
cfg.NetStim1 = {'pop': 'NGF1', 'ynorm': [0,2.0], 'sec': 'soma', 'loc': 0.5, 'synMech': ['AMPA'], 'synMechWeightFactor': [1.0], 'start': 0, 'interval': 1000.0/60.0, 'noise': 0.0, 'number': 0.0, 'weight': 10.0, 'delay': 0}

# ## LAYER 2
# cfg.NetStim2 = {'pop': 'IT2',  'ynorm': [0,1], 'sec': 'soma', 'loc': 0.5, 'synMech': ['AMPA'], 'synMechWeightFactor': [1.0], 'start': 0, 'interval': 1000.0/60.0, 'noise': 0.0, 'number': 60.0, 	'weight': 10.0, 'delay': 0}






** v24_batch5 - result from v24_batch3 with IC inputs and LFP recording; manually on 'my'
*** code
params = specs.ODict()

    # conn gains
    # params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.2] 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    params['thalamoCorticalGain'] = [1.434715802, 2.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25]#, 0.5]
    #params[('ICThalInput', 'probI')] = [0.12, 0.25]#, 0.5]
    
    groupedParams = [('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain'] = 1.7930365644528616
    initCfg['EIGain'] = 1.301292631	
    
    initCfg[('IELayerGain', '1-3')] = 1.9609935 - 0.15
    initCfg[('IELayerGain', '4')] = 1.973369532	- 0.15
    initCfg[('IELayerGain', '5')] = 0.547478256	- 0.15
    initCfg[('IELayerGain', '6')] = 0.817050621	- 0.15

    initCfg[('IILayerGain', '1-3')] = 0.575910457
    initCfg[('IILayerGain', '4')] = 0.506134474	
    initCfg[('IILayerGain', '5')] = 1.140789303	
    initCfg[('IILayerGain', '6')] = 1.999973065	

    initCfg['thalamoCorticalGain'] = 1.434715802
    initCfg['intraThalamicGain'] = 1.987386358	
    initCfg['corticoThalamicGain'] = 1.354024353042513

    
** v24_batch6 - rerun v23_batch8 with fixed LFP
*** notes
1_1_1_1_0
1_1_1_1_1
1_1_1_1_2

had to go to prev commit cause bkg inputs had changed

*** params
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371 1.0
    initCfg[('IELayerGain', '4')]=1.961577378323746 1.0
    initCfg[('IELayerGain', '5')]=0.73154575340036 1.0
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394 1.0
    initCfg[('IILayerGain', '4')]=0.5633033925996949 1.0 
    initCfg[('IILayerGain', '5')]=1.674448267759582 1.0
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
*** code
    params = specs.ODict()

    # conn gains
    # params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.2] 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    #params['thalamoCorticalGain'] = [1.434715802, 2.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25]#, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    
    groupedParams = [] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    ''' from v23_batch8'''
    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]= 1.0
    initCfg[('IELayerGain', '4')]=1.0
    initCfg[('IELayerGain', '5')]=1.0
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.0
    initCfg[('IILayerGain', '4')]=1.0 
    initCfg[('IILayerGain', '5')]=1.0
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
    
** v24_batch7 - fI for ITS4 and VIP to check diam change didn't affect
*** results
OK, same fI, didn't affect.

** v24_batch8 - fI for ITS4 with old diam (3um)
*** results
pretty similar to new diam (25um); but steeper curve so keeping 25um

** v24_batch9 - asd optim on 'zn' 96 cores (6 gens) (bug: IC input)
*** notes
test with toy model first
*** code
def asdRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 1.973369532]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.575910457]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     200,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30, # max number of times to check if sim is completed (for each generation)
    }
*** results
stopped after 6 gens  -- not sure why

    "fvals": [
        323.4898722376168,
        323.4898722376168,
        293.7585341348848,
        293.7585341348848,
        293.7585341348848,
        293.7585341348848,
        0.0,
        0.0,
 "x": [
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.575910457,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.575910457,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ],
        [


set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=2.0
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.817050621
set ('IILayerGain', '1-3')=0.5183194113
set ('IILayerGain', '4')=0.506134474
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.999973065
set thalamoCorticalGain=1.434715802
set intraThalamicGain=1.987386358
set corticoThalamicGain=1.354024353042513


** v24_batch10 - asd optim on 'zn' 96 cores; continue from v24_batch9 (bug)
** v24_batch11 - asd optim on 'zn' 96 cores; continue from v24_batch9 (bug: IC input) 
*** notes
not reproducible cause was using IC input (should only be bkg), and turns out IC input is random every time

set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=2.0
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.817050621
set ('IILayerGain', '1-3')=0.5183194113
set ('IILayerGain', '4')=0.506134474
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.999973065
set thalamoCorticalGain=1.434715802
set intraThalamicGain=1.987386358
set corticoThalamicGain=1.354024353042513

using asd parallel implementation with single starting point
using psutil to cancel jobs

crashed because no try excpet around psutil (tried to stop nrniv from other user I guess)
*** code

ef asdRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 2.0]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.5183194113]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     100,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30, # max number of times to check if sim is completed (for each generation)
    }
*** results
zn% head -n 100 $models/A1/data/v24_batch11/v24_batch11_output.json
{
    "fvals": [
        [
            299.70709812373457,
            299.70709812373457,
            293.76296218967843,
            293.76296218967843,
            293.76296218967843,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.84085789123134,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.7895153611463,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,


params for 1st 281.8085323839038:

                1.7930365644528616,
                1.301292631,
                1.9609935,
                1.8666666666666667,
                0.547478256,
                0.8715206624,
                0.57015135243,
                0.506134474,
                1.140789303,
                1.999973065,
                1.2912442218,
                1.7886477222,
                1.4894267883467642
** v24_batch12 - asd optim on 'zn' 96 cores; continue from v24_batch11 (bug: IC input)
*** notes
not reproducible cause was using IC input, and turns out IC input is random every time


fixed parallel asd by adding try excpet around psutil
continue from v24_batch11:
                1.7930365644528616,
                1.301292631,
                1.9609935,
                1.8666666666666667,
                0.547478256,
                0.8715206624,
                0.57015135243,
                0.506134474,
                1.140789303,
                1.999973065,
                1.2912442218,
                1.7886477222,
                1.4894267883467642
*** code

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, [1.7930365644528616]]
    params['EIGain'] = [0.5, 2.0, [1.301292631]]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, [1.9609935]]
    params[('IELayerGain', '4')] = [0.5, 2.0, [1.8666666666666667]]
    params[('IELayerGain', '5')] = [0.5, 2.0, [0.547478256]]
    params[('IELayerGain', '6')] = [0.5, 2.0, [0.8715206624]]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, [0.57015135243]]
    params[('IILayerGain', '4')] = [0.5, 2.0, [0.506134474]]
    params[('IILayerGain', '5')] = [0.5, 2.0, [1.140789303]]
    params[('IILayerGain', '6')] = [0.5, 2.0, [1.999973065]]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, [1.2912442218]]  
    params['intraThalamicGain'] = [0.5, 2.0, [1.7886477222]]
    params['corticoThalamicGain'] = [0.5, 2.0, [1.4894267883467642]]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     100,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30,  # max number of times to check if sim is completed (for each generation)
        'popsize': 1
    }
*** results
params for gen 37 (last improvement):
set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=1.8666666666666667
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.9586727286400001
set ('IILayerGain', '1-3')=0.57015135243
set ('IILayerGain', '4')=0.5567479214
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.9110853732222222
set thalamoCorticalGain=1.2912442218
set intraThalamicGain=1.7886477222
set corticoThalamicGain=1.4894267883467642


            293.74052987739645,
            293.74052987739645,
            293.74052987739645,
            293.74052987739645,
            293.70094352945284,
            293.70094352945284,
            293.70094352945284,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786
** v24_batch13 - asd optim on 'zn' 96 cores; continue from v24_batch12 (bug: IC input)
not reproducible cause was using IC input (should only be bkg), and turns out IC input is random every time

set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=1.8666666666666667
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.9586727286400001
set ('IILayerGain', '1-3')=0.57015135243
set ('IILayerGain', '4')=0.5567479214
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.9110853732222222
set thalamoCorticalGain=1.2912442218
set intraThalamicGain=1.7886477222
set corticoThalamicGain=1.4894267883467642

** v24_batch14 - asd optimi on 'zn' 96 cores; from v24_batch2 (after removing IC)
*** notes
    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 1.973369532]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.575910457]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]
*** results
zn% grep ++ $models/A1/screenlog.0
    candidate 0, step 1 (1382.1 s) ++ (orig: 317.56 | best:317.56 | new:299.58 | diff:-17.980)
    candidate 0, step 7 (9801.1 s) ++ (orig: 317.56 | best:299.58 | new:293.65 | diff:-5.9316)
    candidate 0, step 9 (12627.5 s) ++ (orig: 317.56 | best:293.65 | new:275.77 | diff:-17.877)
    candidate 0, step 34 (47506.1 s) ++ (orig: 317.56 | best:275.77 | new:275.76 | diff:-0.014009)
    candidate 0, step 39 (54482.2 s) ++ (orig: 317.56 | best:275.76 | new:275.75 | diff:-0.0073418)
    candidate 0, step 46 (64224.4 s) ++ (orig: 317.56 | best:275.75 | new:275.73 | diff:-0.022605)

gen_46_cand_0
set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=1.973369532
set ('IELayerGain', '5')=0.6022260816
set ('IELayerGain', '6')=0.817050621
set ('IILayerGain', '1-3')=0.5183194113
set ('IILayerGain', '4')=0.506134474
set ('IILayerGain', '5')=1.0267103727
set ('IILayerGain', '6')=2.0
set thalamoCorticalGain=1.434715802
set intraThalamicGain=2.0
set corticoThalamicGain=1.4442926432453471
** v24_batch15 - asd continue from v24_batch15
*** code
def asdRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.5, 2.0, [1.7930365644528616]]
    params['EIGain'] = [0.5, 2.0, [1.301292631]]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, [1.9609935]]
    params[('IELayerGain', '4')] = [0.5, 2.0, [1.973369532]]
    params[('IELayerGain', '5')] = [0.5, 2.0, [0.6022260816]]
    params[('IELayerGain', '6')] = [0.5, 2.0, [0.817050621]]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, [0.5183194113]]
    params[('IILayerGain', '4')] = [0.5, 2.0, [0.506134474]]
    params[('IILayerGain', '5')] = [0.5, 2.0, [1.0267103727]]
    params[('IILayerGain', '6')] = [0.5, 2.0, [2.0]]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, [1.434715802]]  
    params['intraThalamicGain'] = [0.5, 2.0, [2.0]] 
    params['corticoThalamicGain'] = [0.5, 2.0, [1.4442926432453471]]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     200,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 1,  # max number of times to check if sim is completed (for each generation)
        'popsize': 1
    }

** v24_batch16 - parallel ASD on GCP; NEURON 8.0
*** notes
*** code
*** results
===  Maximum iterations reached (steps: 200) ===
  == candidate: 0 | orig: 578.66 | best: 375.49 | ratio: 0.64889 ==
  == candidate: 1 | orig: -1.0000 | best: -1.0000 | ratio: 1.0000 ==
  == candidate: 2 | orig: 619.55 | best: 489.84 | ratio: 0.79063 ==
  == candidate: 3 | orig: 475.22 | best: 406.03 | ratio: 0.85441 ==
  == candidate: 4 | orig: 655.22 | best: 441.70 | ratio: 0.67413 ==
  == candidate: 5 | orig: -1.0000 | best: -1.0000 | ratio: 1.0000 ==
  == candidate: 6 | orig: 637.05 | best: 508.97 | ratio: 0.79894 ==
  == candidate: 7 | orig: 639.17 | best: 475.23 | ratio: 0.74351 ==
  == candidate: 8 | orig: 577.88 | best: 477.15 | ratio: 0.82570 ==
  == candidate: 9 | orig: 661.17 | best: 465.06 | ratio: 0.70340 ==
  == candidate: 10 | orig: 441.48 | best: 310.98 | ratio: 0.70441 ==
  == candidate: 11 | orig: 502.72 | best: 382.09 | ratio: 0.76005 == 
  == candidate: 11 | orig: 702.78 | best: 549.61 | ratio: 0.78205 ==
  == candidate: 13 | orig: 667.11 | best: 632.18 | ratio: 0.94764 ==
  == candidate: 14 | orig: 401.70 | best: 372.27 | ratio: 0.92675 ==
  == candidate: 15 | orig: 667.11 | best: 477.47 | ratio: 0.71573 ==
  == candidate: 16 | orig: 696.83 | best: 655.22 | ratio: 0.94029 ==
  == candidate: 17 | orig: 607.66 | best: 370.02 | ratio: 0.60893 ==
  == candidate: 18 | orig: 702.78 | best: 405.74 | ratio: 0.57734 ==
  == candidate: 19 | orig: 608.01 | best: 463.25 | ratio: 0.76190 ==
  == candidate: 20 | orig: 503.06 | best: 485.75 | ratio: 0.96560 ==
  == candidate: 21 | orig: 574.45 | best: 539.32 | ratio: 0.93885 ==
  == candidate: 22 | orig: 708.73 | best: 673.06 | ratio: 0.94967 ==
  == candidate: 23 | orig: 667.11 | best: 396.65 | ratio: 0.59458 ==
  == candidate: 24 | orig: 690.89 | best: 604.63 | ratio: 0.87515 ==
  == candidate: 25 | orig: 690.89 | best: 489.01 | ratio: 0.70779 ==
  == candidate: 26 | orig: 619.55 | best: 423.47 | ratio: 0.68351 ==
  == candidate: 27 | orig: 684.95 | best: 655.22 | ratio: 0.95659 ==
  == candidate: 28 | orig: 690.89 | best: 655.22 | ratio: 0.94837 ==
  == candidate: 29 | orig: 679.00 | best: 631.44 | ratio: 0.92996 ==
  == candidate: 30 | orig: 381.21 | best: 350.80 | ratio: 0.92021 ==
  == candidate: 31 | orig: 643.33 | best: 607.66 | ratio: 0.94456 ==
  == candidate: 32 | orig: 631.44 | best: 489.11 | ratio: 0.77459 ==
  == candidate: 33 | orig: 425.21 | best: 376.33 | ratio: 0.88505 ==
  == candidate: 34 | orig: 520.17 | best: 430.15 | ratio: 0.82693 ==
  == candidate: 35 | orig: 732.50 | best: 562.90 | ratio: 0.76846 ==
  == candidate: 36 | orig: 720.61 | best: 461.09 | ratio: 0.63985 ==
  == candidate: 37 | orig: 702.78 | best: 552.11 | ratio: 0.78561 ==
  == candidate: 38 | orig: 447.70 | best: 323.26 | ratio: 0.72205 ==
  == candidate: 39 | orig: 481.03 | best: 456.27 | ratio: 0.94853 ==

  == Overall best: candidate: 10 | orig: 441.48 | best: 310.98 | ratio: 0.70441 ==


  Gen: 144, Cand: 10, Fitness: 310.98
Gen: 174, Cand: 38, Fitness: 323.26
Gen: 85, Cand: 30, Fitness: 350.80
Gen: 102, Cand: 17, Fitness: 370.02 - not so good 
Gen: 177, Cand: 14, Fitness: 372.27 - not so good
Gen: 173, Cand: 0, Fitness: 375.49
Gen: 111, Cand: 33, Fitness: 376.33
Gen: 30, Cand: 11, Fitness: 382.09
Gen: 161, Cand: 23, Fitness: 396.65
Gen: 79, Cand: 18, Fitness: 405.74
Gen: 116, Cand: 3, Fitness: 406.03
Gen: 184, Cand: 26, Fitness: 423.47
Gen: 1, Cand: 34, Fitness: 430.15
Gen: 66, Cand: 4, Fitness: 441.70
Gen: 83, Cand: 39, Fitness: 456.27
Gen: 1, Cand: 36, Fitness: 461.09
Gen: 126, Cand: 19, Fitness: 463.25
Gen: 1, Cand: 9, Fitness: 465.06
Gen: 179, Cand: 7, Fitness: 475.23
Gen: 1, Cand: 8, Fitness: 477.15
Gen: 1, Cand: 15, Fitness: 477.47
Gen: 119, Cand: 20, Fitness: 485.75
Gen: 1, Cand: 25, Fitness: 489.01
Gen: 1, Cand: 32, Fitness: 489.11
Gen: 1, Cand: 2, Fitness: 489.84
Gen: 195, Cand: 6, Fitness: 508.97
Gen: 67, Cand: 21, Fitness: 539.32
Gen: 1, Cand: 12, Fitness: 549.61
Gen: 1, Cand: 37, Fitness: 552.11
Gen: 1, Cand: 35, Fitness: 562.90
Gen: 1, Cand: 24, Fitness: 604.63
Gen: 185, Cand: 31, Fitness: 607.66
Gen: 1, Cand: 29, Fitness: 631.44
Gen: 1, Cand: 13, Fitness: 632.18
Gen: 1, Cand: 27, Fitness: 655.22
Gen: 157, Cand: 28, Fitness: 655.22
Gen: 1, Cand: 16, Fitness: 655.22
Gen: 148, Cand: 22, Fitness: 673.06
** v24_batch17 - parallel ASD on GCP; continue best solutions from v24_batch16
*** notes

Gen: 144, Cand: 10, Fitness: 310.98
set EEGain=1.4338777102469733
set EIGain=1.1625828604622033
set ('IELayerGain', '1-3')=1.091037051695174
set ('IELayerGain', '4')=1.8712819675755956
set ('IELayerGain', '5')=0.7397134465049761
set ('IELayerGain', '6')=1.367569320349433
set ('IILayerGain', '1-3')=1.418339439423966
set ('IILayerGain', '4')=0.6274719645228012
set ('IILayerGain', '5')=0.5675561437477121
set ('IILayerGain', '6')=1.5174286644853214
set thalamoCorticalGain=1.6851404284735372
set intraThalamicGain=1.063075099977045
set corticoThalamicGain=0.673804518651403

Gen: 174, Cand: 38, Fitness: 323.26
set EEGain=1.4117825668705553
set EIGain=1.4562645192525767
set ('IELayerGain', '1-3')=0.6966421717946888
set ('IELayerGain', '4')=1.1564048776911902
set ('IELayerGain', '5')=0.5082691576672945
set ('IELayerGain', '6')=1.8650994583365461
set ('IILayerGain', '1-3')=0.5247660780373347
set ('IILayerGain', '4')=1.3887063888108127
set ('IILayerGain', '5')=0.8359523062412009
set ('IILayerGain', '6')=0.786403002769916
set thalamoCorticalGain=1.0872681212597493
set intraThalamicGain=1.9355702398668257
set corticoThalamicGain=0.8456162169403141

Gen: 85, Cand: 30, Fitness: 350.80
set EEGain=1.4796339232563818
set EIGain=1.2494919865726666
set ('IELayerGain', '1-3')=1.2106074885592537
set ('IELayerGain', '4')=0.5914377334878493
set ('IELayerGain', '5')=0.7956691184253843
set ('IELayerGain', '6')=1.1044833499655324
set ('IILayerGain', '1-3')=1.8970275010959088
set ('IILayerGain', '4')=1.2806598565853817
set ('IILayerGain', '5')=1.0339389242169903
set ('IILayerGain', '6')=1.2449536297089994
set thalamoCorticalGain=1.653463860326919
set intraThalamicGain=0.5816973165681442
set corticoThalamicGain=1.8408576413375228

Gen: 102, Cand: 17, Fitness: 370.02 
set EEGain=1.3154950966436703
set EIGain=1.0095763680475387
set ('IELayerGain', '1-3')=1.3046938357412072
set ('IELayerGain', '4')=1.337690869825955
set ('IELayerGain', '5')=1.3419352351670506
set ('IELayerGain', '6')=2.0
set ('IILayerGain', '1-3')=1.806386376748424
set ('IILayerGain', '4')=1.785015289487499
set ('IILayerGain', '5')=1.3006272106913037
set ('IILayerGain', '6')=1.6797508518217605
set thalamoCorticalGain=1.5625342091955938
set intraThalamicGain=0.9733859948789619
set corticoThalamicGain=0.8423443321780072

Gen: 177, Cand: 14, Fitness: 372.27 - not so good
Gen: 173, Cand: 0, Fitness: 375.49 - use this one, a bit different
set EEGain=1.4081465013179777
set EIGain=0.6909751558458218
set ('IELayerGain', '1-3')=1.476256983214676
set ('IELayerGain', '4')=1.4388900372032694
set ('IELayerGain', '5')=0.5
set ('IELayerGain', '6')=1.4292511768559795
set ('IILayerGain', '1-3')=0.6980418301090989
set ('IILayerGain', '4')=1.1884408015079058
set ('IILayerGain', '5')=1.8830229460800467
set ('IILayerGain', '6')=1.1514878860870101
set thalamoCorticalGain=0.9636536753602729
set intraThalamicGain=1.283310375368901
set corticoThalamicGain=1.2234380160367202

---
Gen: 111, Cand: 33, Fitness: 376.33
Gen: 30, Cand: 11, Fitness: 382.09
Gen: 161, Cand: 23, Fitness: 396.65
Gen: 79, Cand: 18, Fitness: 405.74
Gen: 116, Cand: 3, Fitness: 406.03
Gen: 184, Cand: 26, Fitness: 423.47
Gen: 1, Cand: 34, Fitness: 430.15
Gen: 66, Cand: 4, Fitness: 441.70
Gen: 83, Cand: 39, Fitness: 456.27
Gen: 1, Cand: 36, Fitness: 461.09
Gen: 126, Cand: 19, Fitness: 463.25
Gen: 1, Cand: 9, Fitness: 465.06
Gen: 179, Cand: 7, Fitness: 475.23
Gen: 1, Cand: 8, Fitness: 477.15
Gen: 1, Cand: 15, Fitness: 477.47
Gen: 119, Cand: 20, Fitness: 485.75
Gen: 1, Cand: 25, Fitness: 489.01
Gen: 1, Cand: 32, Fitness: 489.11
Gen: 1, Cand: 2, Fitness: 489.84
Gen: 195, Cand: 6, Fitness: 508.97
Gen: 67, Cand: 21, Fitness: 539.32
Gen: 1, Cand: 12, Fitness: 549.61
Gen: 1, Cand: 37, Fitness: 552.11
Gen: 1, Cand: 35, Fitness: 562.90
Gen: 1, Cand: 24, Fitness: 604.63
Gen: 185, Cand: 31, Fitness: 607.66
Gen: 1, Cand: 29, Fitness: 631.44
Gen: 1, Cand: 13, Fitness: 632.18
Gen: 1, Cand: 27, Fitness: 655.22
Gen: 157, Cand: 28, Fitness: 655.22
Gen: 1, Cand: 16, Fitness: 655.22
Gen: 148, Cand: 22, Fitness: 673.06
*** code

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    x0 = [[1.4338777102469733, 1.1625828604622033, 1.091037051695174, 1.8712819675755956, 0.7397134465049761, 1.367569320349433, 1.418339439423966, 0.6274719645228012, 0.5675561437477121, 1.5174286644853214, 1.6851404284735372, 1.063075099977045, 0.673804518651403],
    [1.4117825668705553, 1.4562645192525767, 0.6966421717946888, 1.1564048776911902, 0.5082691576672945, 1.8650994583365461, 0.5247660780373347, 1.3887063888108127, 0.8359523062412009, 0.786403002769916, 1.0872681212597493, 1.9355702398668257, 0.8456162169403141],
    [1.4796339232563818, 1.2494919865726666, 1.2106074885592537, 0.5914377334878493, 0.7956691184253843, 1.1044833499655324, 1.8970275010959088, 1.2806598565853817, 1.0339389242169903, 1.2449536297089994, 1.653463860326919, 0.5816973165681442, 1.8408576413375228],
    [1.3154950966436703, 1.0095763680475387, 1.3046938357412072, 1.337690869825955, 1.3419352351670506, 2.0, 1.806386376748424, 1.785015289487499, 1.3006272106913037, 1.6797508518217605, 1.5625342091955938, 0.9733859948789619, 0.8423443321780072],
    [1.4081465013179777, 0.6909751558458218, 1.476256983214676, 1.4388900372032694, 0.5, 1.4292511768559795, 0.6980418301090989, 1.1884408015079058, 1.8830229460800467, 1.1514878860870101, 0.9636536753602729, 1.283310375368901, 1.2234380160367202]]

    # bkg inputs
    params['EEGain'] = [0.5, 2.0, [x[0] for x in x0]]
    params['EIGain'] = [0.5, 2.0, [x[1] for x in x0]]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, [x[2] for x in x0]]
    params[('IELayerGain', '4')] = [0.5, 2.0, [x[3] for x in x0]]
    params[('IELayerGain', '5')] = [0.5, 2.0, [x[4] for x in x0]]
    params[('IELayerGain', '6')] = [0.5, 2.0, [x[5] for x in x0]]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, [x[6] for x in x0]]
    params[('IILayerGain', '4')] = [0.5, 2.0, [x[7] for x in x0]]
    params[('IILayerGain', '5')] = [0.5, 2.0, [x[8] for x in x0]]
    params[('IILayerGain', '6')] = [0.5, 2.0, [x[9] for x in x0]]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, [x[10] for x in x0]]
    params['intraThalamicGain'] = [0.5, 2.0, [x[11] for x in x0]]
    params['corticoThalamicGain'] = [0.5, 2.0, [x[12] for x in x0]]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     300,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 1min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 12,  # max number of times to check if sim is completed (for each generation)
        'popsize': 5
    }

    return b



** v25_batch1 - parallel Optuna optim test on GCP
*** notes
had to run:
pip3 install --user bokeh optuna scikit-learn joblib pymysql mysqlclient
sudo yum install MySQL-python

mpi4py not working

- commented out optuna and bokeh loading so no issuess in hpc nodes 
*** results
worked ok after much debugging
** v25_batch2 - parallel Optuna optim on GCP - 50 parallel jobs
*** notes
50 parallel jobs, 300 trials each
** v25_batch3 - best of v25_batch2 with and w/o IC; with LFP 
*** note
actually results merged with v25_batch4 - same simlabel, diff files 
** v25_batch4 - best of v25_batch2 with IC off; with LFP; TC 
*** notes
*** results
- plotting 'manually' conn matrices

- m=sim.analysis.plotConn(includePre=pops, includePost=pops, feature='probability', synOrConn='conn', showFig=0, saveFig='conn_prob_new.png', saveData='conn_prob_new.pkl')
- issues with instnatiated vs empirical conn prob matrix:
-- PV2/SOM2 and PV4/SOM4 appear inverted
-- replotting with list of pops in correct order
-- that fixed the issue -- empirical approx same as instantiated prob conn matrix

- w=sim.analysis.plotConn(includePre=['IT3', 'NGF3'], includePost=['IT3','NGF3'], feature='weight', synOrConn='syn', synMech='AMPA', removeWeightNorm=1, showFig=0, saveFig='weight_AMPA.png', saveData='weight_AMPA.pkl')

- w2=sim.analysis.plotConn(includePre=pops, includePost=pops, removeWeightNorm=1, feature='weight', synOrConn='syn', synMech='AMPA', removeWeightNorm=0, showFig=0, saveFig='weight_AMPA.png', saveData='weight_AMPA.pkl')

-- issue with removeWeightNorm -- all 0 (if False, then weights ok)
-- checking locally
-- issues was that also need to save cell secs to have access to geom nseg and weightN

In [9]: allpops = ['NGF1', 'IT2', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'IT3',  'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'SOM4', 'PV4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'SOM5A', 'PV5A', 'VIP5A', 'NGF5A', 'IT5B'
   ...: , 'PT5B', 'CT5B',  'SOM5B', 'PV5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'SOM6', 'PV6', 'VIP6', 'NGF6', 'TC', 'TCM', 'HTC', 'IRE', 'IREM', 'TI', 'IC']

In [10]: w=sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='weight', synOrConn='syn', synMech='AMPA', removeWeightNorm=1, showFig=0, saveFig='weight_allpops_AMPA.png', saveData='weight_
    ...: allpops_AMPA.pkl')


** v25_batch5 - best of v25_batch2 with IC; stronger weights; start 750; with LFP
*** note
- there is high intrinsic activity at 750 so hard to see stim effect

** v25_batch6 - best of v25_batch2 with different NGF weightNorm values
*** note
- check if NGF wnorm changes it's excessive excitability/sensitivity

*** code
def custom():
    params = specs.ODict()

    # conn gains
    params[('weightNormScaling', 'NGF_reduced')] = [0.1, 0.25, 0.5, 1.0, 1.5, 2.0]
    # params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.2] 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    #params[('ICThalInput', 'probE')] = [0.12*2]#, 0.25]#, 0.5]
    #params[('ICThalInput', 'probI')] = [0.25]#, 0.5]
    #params['thalamoCorticalGain'] = [1.0, 1.434715802, 2.0]

    #params['thalamoCorticalGain'] = [1.8483736535302833, 2.5]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    #initCfg[('ICThalInput', 'startTime')] = 750

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # from v25_batch2 (optuna best)
    initCfg[('IELayerGain', '1-3')] = 0.7628339148790332 
    initCfg[('IELayerGain', '4')] = 1.974325049287055 
    initCfg[('IELayerGain', '5')] = 0.7753261834291882 
    initCfg[('IELayerGain', '6')] = 1.5588140501085836 
    initCfg[('IILayerGain', '1-3')] = 0.8006022233940763 
    initCfg[('IILayerGain', '4')] = 1.999312334956534 
    initCfg[('IILayerGain', '5')] = 0.9126340893010045 
    initCfg[('IILayerGain', '6')] = 1.5704716674573778 
    initCfg['EEGain'] = 1.9405846115921952 
    initCfg['EIGain'] = 1.8600534795309025 
    initCfg['corticoThalamicGain'] = 1.083986203608584 
    initCfg['intraThalamicGain'] = 0.5531222327683913
    initCfg['thalamoCorticalGain'] = 1.8483736535302833


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b
** v25_batch7 - best of v25_batch2 with different ITS4 weightNorm values
*** code
    params[('weightNormScaling', 'ITS4_reduced')] = [0.1, 0.25, 0.5, 1.0, 1.5, 2.0]

** v25_batch8 - best of v25_batch2 with different NGF+ITS4 weightNorm values
*** code
    params[('weightNormScaling', 'NGF_reduced')] = [0.8, 0.9, 1.1]
    params[('weightNormScaling', 'ITS4_reduced')] = [0.8, 0.9, 1.1]
** v25_batch9 - removed NGF2-6, increased IEGain
*** notes
fixed mpi issue on gcp:
export LD_LIBRARY_PATH=/usr/lib64/openmpi/lib:$LD_LIBRARY_PATH
*** code
    - REMOVED NGF2-6
    params['IEGain'] = [1.0, 1.25]


** v25_batch10 - synweightFracEI
*** code
    params['synWeightFractionEI'] = [[0.6, 0.4], [0.8, 0.2], [1.0, 0.0]]
** v25_batch11 - removed NGF2-6, increased IEGain (fine tune)
*** code
params['IEGain'] = [1.05, 1.1, 1.15, 1.2]


** NGF_evol1 - reducede sensitivity to E-I imbalance with similar fI curve
*** notes
pip install --user optuna psutil sklearn
*** code
def evolCellNGF():
    # parameters space to explore
    params = specs.ODict()

    scalingRange = [0.5, 2.0]
    
    params[('tune', 'Ra')] = scalingRange
    params[('tune', 'cm')] = scalingRange
    params[('tune', 'pas', 'e')] = scalingRange
    params[('tune', 'pas', 'g')] = scalingRange
    params[('tune', 'ch_CavL', 'gmax')] = scalingRange
    params[('tune', 'ch_CavN', 'gmax')] = scalingRange
    params[('tune', 'ch_KCaS', 'gmax')] = scalingRange
    params[('tune', 'ch_Kdrfastngf', 'gmax')] = scalingRange
    params[('tune', 'ch_KvAngf', 'gmax')] = scalingRange
    params[('tune', 'ch_KvCaB', 'gmax')] = scalingRange
    params[('tune', 'ch_Navngf', 'gmax')] = scalingRange
    params[('tune', 'hd', 'gbar')] = scalingRange

    # params[('tune', 'hd', 'ehd')] = scalingRange
    # params[('tune', 'hd', 'elk')] = scalingRange
    # params[('tune', 'hd', 'vhalfl')] = scalingRange
    # params[('tune', 'iconc_Ca', 'caiinf')] = scalingRange
    # params[('tune', 'iconc_Ca', 'catau')] = scalingRange


    # current injection params
    interval = 10000  # 10000
    dur = 500  # ms
    durSteady = 200  # ms
    amps = list(np.arange(0.04+0.075, 0.121+0.075, 0.01))  # amplitudes
    times = list(np.arange(interval, (dur+interval) * len(amps), dur+interval))  # start times
    targetRatesOnset = [43., 52., 68., 80., 96., 110., 119., 131., 139.]
    targetRatesSteady = [22., 24., 27., 30., 33., 35., 37., 39., 41.]

    stimWeights = [10, 50, 100, 150]
    stimRate = 80
    stimDur = 2000
    stimTimes = [times[-1] + x for x in list(np.arange(-interval, (stimDur + interval) * len(stimWeights), stimDur + interval))]
    stimTargetSensitivity = 100  # max - min 

    # initial cfg set up
    initCfg = {} # specs.ODict()
    initCfg['duration'] = ((dur+interval) * len(amps)) + ((stimDur+interval) * len(stimWeights)) 
    initCfg[('hParams', 'celsius')] = 37

    initCfg['savePickle'] = True
    initCfg['saveJson'] = False
    initCfg['saveDataInclude'] = ['simConfig', 'netParams', 'net', 'simData']

    initCfg[('IClamp1', 'pop')] = 'NGF'
    initCfg[('IClamp1', 'amp')] = amps
    initCfg[('IClamp1', 'start')] = times
    initCfg[('IClamp1', 'dur')] = dur
    
    # iclamp
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [0, initCfg['duration']] 
    initCfg[('analysis', 'plotfI', 'amps')] = amps
    initCfg[('analysis', 'plotfI', 'times')] = times
    initCfg[('analysis', 'plotfI', 'calculateOnset')] = True
    initCfg[('analysis', 'plotfI', 'dur')] = dur
    initCfg[('analysis', 'plotfI', 'durSteady')] = durSteady
    initCfg[('analysis', 'plotfI', 'targetRates')] = [] #
    initCfg[('analysis', 'plotfI', 'targetRatesOnset')] = targetRatesOnset
    initCfg[('analysis', 'plotfI', 'targetRatesSteady')] = targetRatesSteady

    # netstim 
    initCfg[('NetStim1', 'weight')] = stimWeights
    initCfg[('NetStim1', 'start')] = stimTimes
    initCfg[('NetStim1', 'interval')] = 1000.0 / stimRate 
    initCfg[('NetStim1', 'pop')] = 'NGF'
    initCfg[('NetStim1', 'sec')] = 'soma'
    initCfg[('NetStim1', 'synMech')] = ['AMPA', 'NMDA']
    initCfg[('NetStim1', 'synMechWeightFactor')] = [0.5, 0.5]
    initCfg[('NetStim1', 'number')] = 1e9
    initCfg[('NetStim1', 'noise')] = 1.0


    initCfg['removeWeightNorm'] = False
    initCfg[('analysis', 'plotRaster')] = False
    initCfg['printPopAvgRates'] = [[x, x+stimDur] for x in stimTimes]
    
    
    for k, v in params.items():
        initCfg[k] = v[0]  # initialize params in cfg so they can be modified    

    # fitness function
    fitnessFuncArgs = {}
    fitnessFuncArgs['targetRatesOnset'] = targetRatesOnset
    fitnessFuncArgs['targetRatesSteady'] = targetRatesSteady
    fitnessFuncArgs['stimTargetSensitivity'] = stimTargetSensitivity
    
    def fitnessFunc(simData, **kwargs):
        targetRatesOnset = kwargs['targetRatesOnset']
        targetRatesSteady = kwargs['targetRatesSteady']
        stimTargetSensitivity = kwargs['stimTargetSensitivity']
            
        diffRatesOnset = [abs(x-t) for x,t in zip(simData['fI_onset'], targetRatesOnset)]
        diffRatesSteady = [abs(x - t) for x, t in zip(simData['fI_steady'], targetRatesSteady)]
        stimDiffRate = np.max(list(simData['popRates']['NGF'].values())) - np.min(list(simData['popRates']['NGF'].values()))
        
        maxFitness = 1000
        fitness = np.mean(diffRatesOnset + diffRatesSteady) if stimDiffRate < stimTargetSensitivity else maxFitness
        
        print(' Candidate rates: ', simData['fI_onset']+simData['fI_steady'])
        print(' Target rates:    ', targetRatesOnset+targetRatesSteady)
        print(' Difference:      ', diffRatesOnset + diffRatesSteady)
        print(' Stim sensitivity: ', stimDiffRate)

        return fitness
        

    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, initCfg=initCfg)
    
    # Set output folder, grid method (all param combinations), and run configuration
    b.batchLabel = 'NGF_evol1'
    b.saveFolder = 'data/'+b.batchLabel
    b.method = 'evol'
    b.runCfg = {
        'type': 'mpi_bulletin',#'hpc_slurm', 
        'script': 'init.py',
        'mpiCommand': 'python3',  
        # # options required only for hpc
        # 'nodes': 1,
        # 'coresPerNode': 2,
        # 'allocation': 'default',
        # 'email': 'salvadordura@gmail.com',
        # 'reservation': None,
        # 'folder': '/home/salvadord/evol'
        # #'custom': 'export LD_LIBRARY_PATH="$HOME/.openmpi/lib"' # only for conda users
    }
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 95,
        'num_elites': 1, # keep this number of parents for next generation if they are fitter than children
        'mutation_rate': 0.4,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 2000,
        'time_sleep': 10, # wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 6, # max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000 # set fitness value in case simulation time is over
    }
    # Run batch simulations
    b.run()
** NGF_optuna1 - reducede sensitivity to E-I imbalance with similar fI curve
*** notes
pip3 install --user optuna psutil sklearn
*** code
sensitivity threshold 139
** NGF_optuna2
*** code
proportional to sensitivity
** NGF_evol3
*** code
sensitivity threshold 200
*** results
#gen  pop-size  worst  best  median  average  std-deviation
107, 95, 1000, 16.7812295636476, 1000.0, 909.5910595002416, 279.51521172064236
 Candidate 77 fitness = 16.8

 Candidate rates:  [0.0, 59.70149253383835, 63.89776357455542, 68.02721088039404, 72.46376811172408, 76.6283524859611, 80.64516130909925, 84.74576273159582, 88.49557524184343, 93.02325583561215, 0.0, 10.0, 10.0, 15.0, 15.0, 20.0, 20.0, 20.0, 25.0, 25.0]
 Target rates:     [0.0, 43.0, 52.0, 68.0, 80.0, 96.0, 110.0, 119.0, 131.0, 139.0, 0.0, 22.0, 24.0, 27.0, 30.0, 33.0, 35.0, 37.0, 39.0, 41.0]
 Difference:       [0.0, 16.701492533838348, 11.89776357455542, 0.027210880394036963, 7.536231888275921, 19.371647514038898, 29.35483869090075, 34.25423726840418, 42.504424758156574, 45.97674416438785, 0.0, 12.0, 14.0, 12.0, 15.0, 13.0, 15.0, 17.0, 14.0, 16.0]
 Stim sensitivity:  191.5

            "L": 1.2052913753109844,
            "Ra": 0.6188916807404659,
            "ch_CavL": {
                "gmax": 0.6643606309051462
            },
            "ch_CavN": {
                "gmax": 1.999513285476655
            },
            "ch_KCaS": {
                "gmax": 1.9119135773928315
            },
            "ch_Kdrfastngf": {
                "gmax": 0.6731585388416943
            },
            "ch_KvAngf": {
                "gmax": 1.1398823069068658
            },
            "ch_KvCaB": {
                "gmax": 1.990571113355998
            },
            "ch_Navngf": {
                "gmax": 0.5000341829278828
            },
            "cm": 1.8703530950670728,
            "diam": 1.0669279464935373,
            "hd": {
                "gbar": 0.5041587767739838
            },
            "pas": {
                "e": 0.6618040978482008,
                "g": 0.7938102760892314
            }

** NGF_optuna3
*** code
sensitivity threshold 200
*** results
Both have good steady start fI, but lower onset fI
stim <200 hz

Best is trial 7104 with value: 15.68709538903382
 "L": 0.5292094921519722,
            "Ra": 1.4789488212279527,
            "ch_CavL": {
                "gmax": 0.8294009810179838
            },
            "ch_CavN": {
                "gmax": 1.8302558031992033
            },
            "ch_KCaS": {
                "gmax": 1.9966915506612826
            },
            "ch_Kdrfastngf": {
                "gmax": 1.9718693540420718
            },
            "ch_KvAngf": {
                "gmax": 1.9995297406303094
            },
            "ch_KvCaB": {
                "gmax": 1.386572752588786
            },
            "ch_Navngf": {
                "gmax": 1.9747105482249578
            },
            "cm": 1.6538025216246877,
            "diam": 0.9280430551297493,
            "hd": {
                "gbar": 1.359096548635795
            },
            "pas": {
                "e": 0.6789102769330073,
                "g": 0.8144720557328889
            }


Best is trial 12641 with value: 15.686702153579452
            "L": 0.689135676792468,
            "Ra": 1.5107994749104472,
            "ch_CavL": {
                "gmax": 0.7785651254425331
            },
            "ch_CavN": {
                "gmax": 1.8726511033353617
            },
            "ch_KCaS": {
                "gmax": 1.9989870415294693
            },
            "ch_Kdrfastngf": {
                "gmax": 1.9993775322859029
            },
            "ch_KvAngf": {
                "gmax": 1.9988397324882128
            },
            "ch_KvCaB": {
                "gmax": 0.9711393790585342
            },
            "ch_Navngf": {
                "gmax": 1.9990447151070911
            },
            "cm": 1.7000470536108732,
            "diam": 0.8560750709483423,
            "hd": {
                "gbar": 1.3469228494250693
            },
            "pas": {
                "e": 0.603295186079315,
                "g": 0.7537517553399005
            }




** ITS4_optuna1
*** code
# ---------------------------------------------------------------------------------------------- #
def evolCellITS4():
    # parameters space to explore
    params = specs.ODict()

    scalingRange = [0.5, 2.0]
    scalingRangeReduced = [0.75, 1.5]
    

    params[('tune', 'L')] = scalingRangeReduced
    params[('tune', 'diam')] = scalingRange
    params[('tune', 'Ra')] = scalingRange
    params[('tune', 'cm')] = scalingRange
    params[('tune', 'kv', 'gbar')] = scalingRange
    params[('tune', 'naz', 'gmax')] = scalingRange
    params[('tune', 'pas', 'e')] = scalingRangeReduced
    params[('tune', 'pas', 'g')] = scalingRange

    params[('tune', 'Nca', 'gmax')] = scalingRange
    params[('tune', 'kca', 'gbar')] = scalingRange
    params[('tune', 'km', 'gbar')] = scalingRange


    # current injection params
    interval = 2000
    dur = 500  # ms
    amps = list(np.arange(0.0, 0.65, 0.05))  # amplitudes
    times = list(np.arange(interval, (dur+interval) * len(amps), dur+interval))  # start times
    targetRates = [0., 0., 19., 29., 37., 45., 51., 57., 63., 68., 73., 77., 81.]
 
    stimWeights = [10, 50, 100, 150]
    stimRate = 80
    stimDur = 2000
    stimTimes = [times[-1] + x for x in list(np.arange(interval, (stimDur + interval) * len(stimWeights), stimDur + interval))]
    stimTargetSensitivity = 75
 
    # initial cfg set up
    initCfg = {} # specs.ODict()
    initCfg['duration'] = stimTimes[-1] + dur
    initCfg[('hParams', 'celsius')] = 37

    initCfg['savePickle'] = True
    initCfg['saveJson'] = False
    initCfg['saveDataInclude'] = ['simConfig', 'netParams', 'net', 'simData']

    # iclamp
    initCfg[('IClamp1', 'pop')] = 'ITS4'
    initCfg[('IClamp1', 'amp')] = amps
    initCfg[('IClamp1', 'start')] = times
    initCfg[('IClamp1', 'dur')] = dur

    initCfg[('analysis', 'plotTraces', 'timeRange')] = [0, initCfg['duration']] 
    initCfg[('analysis', 'plotfI', 'amps')] = amps
    initCfg[('analysis', 'plotfI', 'times')] = times
    initCfg[('analysis', 'plotfI', 'dur')] = dur
    initCfg[('analysis', 'plotfI', 'targetRates')] = targetRates

    # netstim 
    initCfg[('NetStim1', 'weight')] = stimWeights
    initCfg[('NetStim1', 'start')] = stimTimes
    initCfg[('NetStim1', 'interval')] = 1000.0 / stimRate 
    initCfg[('NetStim1', 'pop')] = 'ITS4'
    initCfg[('NetStim1', 'sec')] = 'soma'
    initCfg[('NetStim1', 'synMech')] = ['AMPA', 'NMDA']
    initCfg[('NetStim1', 'synMechWeightFactor')] = [0.5, 0.5]
    initCfg[('NetStim1', 'number')] = stimRate * stimDur/1000. * 1.1
    initCfg[('NetStim1', 'noise')] = 1.0


    initCfg['removeWeightNorm'] = False
    initCfg[('analysis', 'plotRaster')] = False
    initCfg['printPopAvgRates'] = [[x, x+stimDur] for x in stimTimes]
    
    for k, v in params.items():
        initCfg[k] = v[0]  # initialize params in cfg so they can be modified    

    # fitness function
    fitnessFuncArgs = {}
    fitnessFuncArgs['targetRates'] = targetRates
    
    def fitnessFunc(simData, **kwargs):
        targetRates = kwargs['targetRates']
            
        diffRates = [abs(x - t) for x, t in zip(simData['fI'], targetRates)]
        
        # calculate sensitivity (firing rate) to exc syn inputs 
        stimMaxRate = np.max(list(simData['popRates']['ITS4'].values()))
        
        maxFitness = 1000

        fitness = np.mean(diffRates) if stimMaxRate < stimTargetSensitivity else \
                  np.mean(diffRates) + (stimMaxRate - stimTargetSensitivity)

        
        print(' Candidate rates: ', simData['fI'])
        print(' Target rates:    ', targetRates)
        print(' Difference:      ', diffRates)
        print(' Stim sensitivity: ', stimMaxRate)

        return fitness
        

    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, initCfg=initCfg)
    
    b.method = 'optuna'

    if b.method == 'evol':
        # Set output folder, grid method (all param combinations), and run configuration
        b.batchLabel = 'ITS4_evol1'
        b.saveFolder = 'data/'+b.batchLabel
        b.runCfg = {
            'type': 'mpi_bulletin',#'hpc_slurm', 
            'script': 'init.py',
            'mpiCommand': '',
            'nrnCommand': 'python3'
        }

        b.evolCfg = {
            'evolAlgorithm': 'custom',
            'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
            'fitnessFuncArgs': fitnessFuncArgs,
            'pop_size': 95,
            'num_elites': 1, # keep this number of parents for next generation if they are fitter than children
            'mutation_rate': 0.4,
            'crossover': 0.5,
            'maximize': False, # maximize fitness function?
            'max_generations': 2000,
            'time_sleep': 10, # wait this time before checking again if sim is completed (for each generation)
            'maxiter_wait': 6, # max number of times to check if sim is completed (for each generation)
            'defaultFitness': 1000 # set fitness value in case simulation time is over
        }

    elif b.method == 'optuna':
        # Set output folder, grid method (all param combinations), and run configuration
        b.batchLabel = 'ITS4_optuna1'
        b.saveFolder = 'data/'+b.batchLabel
        b.runCfg = {
            'type': 'mpi_direct', #'hpc_slurm', 
            'script': 'init.py',
            'mpiCommand': '',
            'nrnCommand': 'python3'
        }
        b.optimCfg = {
            'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
            'fitnessFuncArgs': fitnessFuncArgs,
            'maxFitness': 1000,
            'maxiters':     2000*95,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
            'maxtime':      100*2000,    #    Maximum time allowed, in seconds
            'maxiter_wait': 6,
            'time_sleep': 10,
            'popsize': 1  # unused - run with mpi 
        }    # Run batch simulations
    
    # Run batch simulations
    b.run()
** ITS4_optuna2
*** code
# ---------------------------------------------------------------------------------------------- #
def evolCellITS4():
    # parameters space to explore
    params = specs.ODict()

    scalingRange = [0.25, 4.0]
    scalingRangeReduced = [0.75, 1.5]
    

    params[('tune', 'L')] = scalingRangeReduced
    params[('tune', 'diam')] = scalingRange
    params[('tune', 'Ra')] = scalingRange
    params[('tune', 'cm')] = scalingRange
    params[('tune', 'kv', 'gbar')] = scalingRange
    params[('tune', 'naz', 'gmax')] = scalingRange
    params[('tune', 'pas', 'e')] = scalingRangeReduced
    params[('tune', 'pas', 'g')] = scalingRange

    params[('tune', 'Nca', 'gmax')] = scalingRange
    params[('tune', 'kca', 'gbar')] = scalingRange
    params[('tune', 'km', 'gbar')] = scalingRange


    # current injection params
    interval = 2000
    dur = 500  # ms
    amps = list(np.arange(0.0, 0.65, 0.05))  # amplitudes
    times = list(np.arange(interval, (dur+interval) * len(amps), dur+interval))  # start times
    targetRates = [0., 0., 19., 29., 37., 45., 51., 57., 63., 68., 73., 77., 81.]
 
    stimWeights = [10, 50, 100, 150]
    stimRate = 80
    stimDur = 2000
    stimTimes = [times[-1] + x for x in list(np.arange(interval, (stimDur + interval) * len(stimWeights), stimDur + interval))]
    stimTargetSensitivity = 75
 
    # initial cfg set up
    initCfg = {} # specs.ODict()
    initCfg['duration'] = stimTimes[-1] + dur
    initCfg[('hParams', 'celsius')] = 37

    initCfg['savePickle'] = True
    initCfg['saveJson'] = False
    initCfg['saveDataInclude'] = ['simConfig', 'netParams', 'net', 'simData']

    # iclamp
    initCfg[('IClamp1', 'pop')] = 'ITS4'
    initCfg[('IClamp1', 'amp')] = amps
    initCfg[('IClamp1', 'start')] = times
    initCfg[('IClamp1', 'dur')] = dur

    initCfg[('analysis', 'plotTraces', 'timeRange')] = [0, initCfg['duration']] 
    initCfg[('analysis', 'plotfI', 'amps')] = amps
    initCfg[('analysis', 'plotfI', 'times')] = times
    initCfg[('analysis', 'plotfI', 'dur')] = dur
    initCfg[('analysis', 'plotfI', 'targetRates')] = targetRates

    # netstim 
    initCfg[('NetStim1', 'weight')] = stimWeights
    initCfg[('NetStim1', 'start')] = stimTimes
    initCfg[('NetStim1', 'interval')] = 1000.0 / stimRate 
    initCfg[('NetStim1', 'pop')] = 'ITS4'
    initCfg[('NetStim1', 'sec')] = 'soma'
    initCfg[('NetStim1', 'synMech')] = ['AMPA', 'NMDA']
    initCfg[('NetStim1', 'synMechWeightFactor')] = [0.5, 0.5]
    initCfg[('NetStim1', 'number')] = stimRate * stimDur/1000. * 1.1
    initCfg[('NetStim1', 'noise')] = 1.0


    initCfg['removeWeightNorm'] = False
    initCfg[('analysis', 'plotRaster')] = False
    initCfg['printPopAvgRates'] = [[x, x+stimDur] for x in stimTimes]
    
    for k, v in params.items():
        initCfg[k] = v[0]  # initialize params in cfg so they can be modified    

    # fitness function
    fitnessFuncArgs = {}
    fitnessFuncArgs['targetRates'] = targetRates
    
    def fitnessFunc(simData, **kwargs):
        targetRates = kwargs['targetRates']
            
        diffRates = [abs(x - t) for x, t in zip(simData['fI'], targetRates)]
        
        # calculate sensitivity (firing rate) to exc syn inputs 
        stimMaxRate = np.max(list(simData['popRates']['ITS4'].values()))
        
        maxFitness = 1000

        fitness = np.mean(diffRates) if stimMaxRate < stimTargetSensitivity else \
                  np.mean(diffRates) + (stimMaxRate - stimTargetSensitivity)

        
        print(' Candidate rates: ', simData['fI'])
        print(' Target rates:    ', targetRates)
        print(' Difference:      ', diffRates)
        print(' Stim sensitivity: ', stimMaxRate)

        return fitness
        

    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, initCfg=initCfg)
    
    b.method = 'optuna'

    if b.method == 'evol':
        # Set output folder, grid method (all param combinations), and run configuration
        b.batchLabel = 'ITS4_evol1'
        b.saveFolder = 'data/'+b.batchLabel
        b.runCfg = {
            'type': 'mpi_bulletin',#'hpc_slurm', 
            'script': 'init.py',
            'mpiCommand': '',
            'nrnCommand': 'python3'
        }

        b.evolCfg = {
            'evolAlgorithm': 'custom',
            'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
            'fitnessFuncArgs': fitnessFuncArgs,
            'pop_size': 95,
            'num_elites': 1, # keep this number of parents for next generation if they are fitter than children
            'mutation_rate': 0.4,
            'crossover': 0.5,
            'maximize': False, # maximize fitness function?
            'max_generations': 2000,
            'time_sleep': 10, # wait this time before checking again if sim is completed (for each generation)
            'maxiter_wait': 6, # max number of times to check if sim is completed (for each generation)
            'defaultFitness': 1000 # set fitness value in case simulation time is over
        }

    elif b.method == 'optuna':
        # Set output folder, grid method (all param combinations), and run configuration
        b.batchLabel = 'ITS4_optuna2'
        b.saveFolder = 'data/'+b.batchLabel
        b.runCfg = {
            'type': 'mpi_direct', #'hpc_slurm', 
            'script': 'init.py',
            'mpiCommand': '',
            'nrnCommand': 'python3'
        }
        b.optimCfg = {
            'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
            'fitnessFuncArgs': fitnessFuncArgs,
            'maxFitness': 1000,
            'maxiters':     2000*95,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
            'maxtime':      100*2000,    #    Maximum time allowed, in seconds
            'maxiter_wait': 6,
            'time_sleep': 10,
            'popsize': 1  # unused - run with mpi 
        }    # Run batch simulations
    
    # Run batch simulations
    b.run()

** v28_batch1
*** code
*** results
- best fitness 244; trial 12398
-- upper layer quiet; then burst and deeper layers quiet; mutual inhib?
-- depol block: IT2, IT3, IT6, ITS4, PV2, PV6, SOM4, VIP2-4, VIP6 (most just short period at end)

- using filter analysis found 'better solutions'; trials: 9426, 13859, 14632
-- good rates for all E except: PT5B, TCM
-- good rates for all I except: NGF2-6, TIM, VIP4
-- depol block: cells ITS4, IT6, PV6 -- but only some cells; pop rates ok

- PT5B and TCM low rates, no depol block; can increase bkg input
- NGF very low rates; forgot to adjust bkg inputs after tuning! 
- TIM never fired; forgot to add bkg inputs!

** v28_batch2 - v28_batch1 trial 14632 with adjusted bkg weights
** v28_batch3 - v28_batch1 trial 14632 with adjusted bkg weights
*** code
bkgWeights:
    NGFfactor = 2.5
    ITS4factor = 5.0
    manualScaling = {'SOM2': 0.75, 'VIP2': 0.75, 'NGF2': 1.0 * NGFfactor, 'SOM3': 1.0, 'VIP3': 1.25, 'NGF3': 1.0 * NGFfactor, 'ITP4': 1.1, 'ITS4': 1.0 * ITS4factor, 'SOM4': 1.0, 'PV4': 0.9, 'VIP4': 1.0, 'NGF4': 1.0 * NGFfactor, 'IT5A': 0.075, 'CT5A': 0.75, 'SOM5A': 1.25, 'PV5A': 1.25, 'VIP5A': 1.1, 'NGF5A': 1.0 * NGFfactor, 'PT5B': 1.0, 'IT5B': 0.075, 'CT5B': 0.75, 'IT6': 0.1, 'CT6': 0.75, 'PV5B': 1.0, 'SOM6': 1.1, 'PV6': 0.75, 'NGF6': 1.0 * NGFfactor, 'TC': 1.25, 'TCM': 1.25, 'HTC': 1.25, 'TI': 1.25, 'TIM': 1.25}  # for v22_batch28


batch.py:
   params['thalamoCorticalGain'] = [1.0]#, 1.5]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 2000
    initCfg['printPopAvgRates'] = [1000, 2000] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    #initCfg[('ICThalInput', 'startTime')] = 750

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    # from v28_batch1 (optuna), trial 14632
    initCfg.update({
    'EEGain': 0.9627240590814994,
    'EIGain': 0.3917381420195193,
    'IEGain': 1.0,
    'IELayerGain': {'1-3': 1.4543584284774436,
    '4': 0.5876239956096105,
    '5': 0.20069931808448005,
    '6': 0.6754391191627422},
    'IIGain': 1.0,
    'IILayerGain': {'1-3': 0.34624502581075384,
    '4': 1.3085889834828857,
    '5': 0.24735365353066327,
    '6': 2.727404732884022}})



** v28_batch4 - v28_batch1 trial 14632 with adjusted bkg weights
*** notes
bkg w:
 - increased PT5B to 2.0
 - dec ITS4 to 4.0
 - inc NGF to 4.0
 - inc TIM to 1.5
*** code
    # manual scaling adjustments based on simulation with automatically calculated bkg weights (finetuning)
    NGFfactor = 4.0
    ITS4factor = 4.0
    manualScaling = {'SOM2': 0.75, 'VIP2': 0.75, 'NGF2': 1.0 * NGFfactor, 'SOM3': 1.0, 'VIP3': 1.25, 'NGF3': 1.0 * NGFfactor, 'ITP4': 1.1, 'ITS4': 1.0 * ITS4factor, 'SOM4': 1.0, 'PV4': 0.9, 'VIP4': 1.0, 'NGF4': 1.0 * NGFfactor, 'IT5A': 0.075, 'CT5A': 0.75, 'SOM5A': 1.25, 'PV5A': 1.25, 'VIP5A': 1.1, 'NGF5A': 1.0 * NGFfactor, 'PT5B': 2.0, 'IT5B': 0.075, 'CT5B': 0.75, 'IT6': 0.1, 'CT6': 0.75, 'PV5B': 1.0, 'SOM6': 1.1, 'PV6': 0.75, 'NGF6': 1.0 * NGFfactor, 'TC': 1.25, 'TCM': 1.25, 'HTC': 1.25, 'TI': 1.25, 'TIM': 1.5}  # for v22_batch28
*** results
messed up dynamics; many silent

** v28_batch5 - after fixing ITS4+NGF + bkg weights
*** notes
def optunaRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.1, 3.0]
    params['EIGain'] = [0.1, 3.0]

    params[('IELayerGain', '1-3')] = [0.1, 3.0]
    params[('IELayerGain', '4')] = [0.1, 3.0]
    params[('IELayerGain', '5')] = [0.1, 3.0]
    params[('IELayerGain', '6')] = [0.1, 3.0]

    params[('IILayerGain', '1-3')] = [0.1, 3.0]
    params[('IILayerGain', '4')] = [0.1, 3.0]
    params[('IILayerGain', '5')] = [0.1, 3.0]
    params[('IILayerGain', '6')] = [0.1, 3.0]
    
    # params['thalamoCorticalGain'] = [0.25, 2.0]
    # params['intraThalamicGain'] = [0.25, 2.0]
    # params['corticoThalamicGain'] = [0.25, 2.0]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 2000
    initCfg['printPopAvgRates'] = [[1000, 1250], [1250, 1500], [1500, 1750], [1750, 2000]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [1000,2000]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [1000,2000]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'optuna'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'maxFitness': fitnessFuncArgs['maxFitness'],
        'maxiters':     300,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      None,    #    Maximum time allowed, in seconds
        'maxiter_wait': 16,
        'time_sleep': 60,
        'popsize': 1  # unused - run with mpi 
    }

    return b
*** results
a few interesting solutions… several with 41/43 pops > 0 hz (all except NGF1 and NGF5B) … though IT2 and IT3 quite low

- In [17]: df.iloc[12575][2:12]                                                                                                                                                            
Out[17]: 
IELayerGain1-3    2.645462
IELayerGain4      0.734880
IELayerGain5      0.388620
IELayerGain6      2.794542
IILayerGain1-3    0.930986
IILayerGain4      2.909766
IILayerGain5      0.102020
IILayerGain6      2.557407
EEGain            0.712990
EIGain            0.230825


- In [8]: df.iloc[15446] (BEST fitness)

IELayerGain1-3         2.496991
IELayerGain4           0.752393
IELayerGain5           0.168554
IELayerGain6           2.899179
IILayerGain1-3         0.664827
IILayerGain4           2.287689
IILayerGain5           0.100696
IILayerGain6           2.613499
EEGain                 0.538222
EIGain                 0.245228


Out[8]: 
number             15446.000000
value                110.902053
IELayerGain1-3         2.496991
IELayerGain4           0.752393
IELayerGain5           0.168554
IELayerGain6           2.899179
IILayerGain1-3         0.664827
IILayerGain4           2.287689
IILayerGain5           0.100696
IILayerGain6           2.613499
EEGain                 0.538222
EIGain                 0.245228
NGF1                   0.000000
IT2                    0.000000
PV2                    6.166667
SOM2                  15.500000
VIP2                  82.500000
NGF2                  11.400000
IT3                    0.000000
SOM3                   2.685714
PV3                   20.886364
VIP3                  85.228571
NGF3                   4.600000
ITP4                   3.811005
ITS4                   0.093301
PV4                    2.695652
SOM4                  13.583333
VIP4                  11.500000
NGF4                   1.571429
IT5A                  26.513966
CT5A                  45.067039
PV5A                  89.111111
SOM5A                 68.904762
VIP5A                  2.600000
NGF5A                  4.250000
IT5B                  21.889362
PT5B                   1.106383
CT5B                  42.855319
PV5B                  73.597015
SOM5B                 83.267857
VIP5B                  9.250000
NGF5B                  0.000000
IT6                    9.265873
CT6                    8.317460
PV6                  177.595238
SOM6                   5.064516
VIP6                 100.833333
NGF6                   4.000000
TC                    26.189655
TCM                    0.857143
HTC                   35.368421
IRE                   14.428571
IREM                   0.272727
TI                     9.000000
TIM                    0.040000
** v28_batch6 - v28_batch5 best sol (15446) with reduced IE->Layer1-3
*** code
def custom():
    params = specs.ODict()

    # conn gains
    #params['synWeightFractionEI'] = [[0.6, 0.4], [0.8, 0.2], [1.0, 0.0]]
    #params['IEGain'] = [1.05, 1.1, 1.15, 1.2]
    #params[('weightNormScaling', 'NGF_reduced')] = [0.8, 0.9, 1.1]
    #params[('weightNormScaling', 'ITS4_reduced')] = [0.8, 0.9, 1.1]
    params[('IELayerGain', '1-3')] = list(range(2.4969906720467807, 2.4969906720467807-0.25, 0.05)) 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    #params[('ICThalInput', 'probE')] = [0.12*2]#, 0.25]#, 0.5]
    #params[('ICThalInput', 'probI')] = [0.25]#, 0.5]
    #params['thalamoCorticalGain'] = [1.0, 1.434715802, 2.0]

    #params['thalamoCorticalGain'] = [1.0]#, 1.5]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 2000
    initCfg['printPopAvgRates'] = [1000, 2000] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    #initCfg[('ICThalInput', 'startTime')] = 750

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    # from v28_batch5 (optuna), trial 15446
    initCfg.update({
        "EEGain": 0.538221678982146,
        "EIGain": 0.24522849924039522,
        "IELayerGain": {
            "1-3": 2.4969906720467807,
            "4": 0.7523928690211563,
            "5": 0.16855428023477206,
            "6": 2.8991792469343576
        },
        "IILayerGain": {
            "1-3": 0.6648270236528021,
            "4": 2.2876886663946765,
            "5": 0.10069589845756556,
            "6": 2.6134986990296576
        }})


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

** v29_batch1 - add EIGain by layer; reduce EEGain [0, 1.0]
*** notes
EEGain results were typically 0 - 1.0 so reduce search space (same in M1)
EIGain params by layer added 3 new params
*** code
    params['EEGain'] = [0.1, 1.0]

    params[('EILayerGain', '1-3')] = [0.1, 3.0]
    params[('EILayerGain', '4')] = [0.1, 3.0]
    params[('EILayerGain', '5')] = [0.1, 3.0]
    params[('EILayerGain', '6')] = [0.1, 3.0]

    params[('IELayerGain', '1-3')] = [0.1, 3.0]
    params[('IELayerGain', '4')] = [0.1, 3.0]
    params[('IELayerGain', '5')] = [0.1, 3.0]
    params[('IELayerGain', '6')] = [0.1, 3.0]

    params[('IILayerGain', '1-3')] = [0.1, 3.0]
    params[('IILayerGain', '4')] = [0.1, 3.0]
    params[('IILayerGain', '5')] = [0.1, 3.0]
    params[('IILayerGain', '6')] = [0.1, 3.0]
*** results Discussion
Best result so far: fitness = 94.62904843184099
image.png 
image.png


:clap:
1

12:37
Untitled 
[I 2020-10-06 14:45:30,252] Trial 38595 finished with value: 164.94081763646528 and parameters: {'EEGain': 0.9581268943227292, "('EILayerGain', '1-3')": 0.9662336380529412, "('EILayerGain', '4')": 2.075553800981232, "('EILayerGain', '5')": 0.9031500651354619, "('EILayerGain', '6')": 0.15028858958308838, "('IELayerGain', '1-3')": 0.521718697051653, "('IELayerGain', '4')": 0.6051567737172858, "('IELayerGain', '5')": 0.23132485908097394, "('IELayerGain', '6')": 0.390331535906009, "('IILayerGain', '1-3')": 0.10486845176787038, "('IILayerGain', '4')": 2.5771673116615763, "('IILayerGain', '5')": 0.19750168057425682, "('IILayerGain', '6')": 1.3760950758758617}. Best is trial 33970 with value: 94.62904843184099.


samn:speech_balloon:  12:39 PM
so now have activity in L1-3? and didn't before?

salvadord  12:40 PM
NGF1, NGF5B, TIM are the only ones at 0 HZ -- but not too worried cause other NGFs firing nicely so should be possible to fix; and TIM probably easy to fix too

samn:speech_balloon:  12:40 PM
some gains far from orig values

salvadord  12:40 PM
y IT2, IT3 and ITS4 show this burst of activity, so we'll see if can get some stable activity from them

samn:speech_balloon:  12:41 PM
great - and still running so may improve further.

salvadord  12:41 PM
also noticed a couple depol blocks there, so will look into that ... might be the ones not firing
image.png 
image.png


ericaygriffith:speech_balloon:  12:41 PM
out of curiosity, do we know if the burst of activity in those pops transitions into depol block, or do the cells just go quiet?
12:42
lol, same question you just asked, almost jinx

salvadord  12:43 PM
haha yeah... actually the depol blocks might be the NGFs not firing? not sure, def will look into each pop individually

ericaygriffith:speech_balloon:  12:43 PM
I'll take a look at that param set as well on my own too
:+1:
2


salvadord  12:43 PM
and also will look for other potentially good solutions
:+1:
1


samn:speech_balloon:  12:45 PM
so only a few pops left to fix ... for paper, suppose can still argue tightly constrained by experiment but had to adjust some gains ~10X since those values were missing
:+1:
2

12:46
maybe should aim to just use whatever optim finishes with by nov

salvadord  12:47 PM
sounds good

salvadord  12:57 PM
I'm a bit concerned that the burst of activity in upper layers doesn't seem to affect deeper layers at all
12:57
could be a good thing, since could tune upper layers (which seem more problematic) separately
12:58
but could also point to some issue/bug in the model

samn:speech_balloon:  12:58 PM
good point, would expect strong L2->L5
12:58
bug - but have substantial weight along that pathway? hmm

salvadord  1:00 PM
was just checking conn matrix, and L2->L5 not very high
1:00
so perhaps local activity / inhibition enough to keep stable

samn:speech_balloon:  1:00 PM
ic, lower than M1?
1:00
ok sg

salvadord  1:01 PM
y lower than m1 for sure... since m1 strongest projection is L2/3 -> L5B
:+1:
1


samn:speech_balloon:  1:01 PM
and canonical always mentioned as 4->2->5
:+1:
1


salvadord  1:01 PM
v25_batch4_plot_conn_pop_probability_matrix.png 
v25_batch4_plot_conn_pop_probability_matrix.png



samn:speech_balloon:  1:02 PM
ic, not much there

salvadord  1:03 PM
y it's true canonical makes a point of 2->5 ... I can check how allen V1 looks
:+1:
2


samn:speech_balloon:  1:03 PM
suppose i didn't see any cross layer tuning for opt, so that wouldn't be an issue
:+1:
1


salvadord  1:06 PM
Allen V1 shows low L2->L5 prob conn (0.083)
image.png 
image.png



samn:speech_balloon:  1:07 PM
& weights low too?

samn:speech_balloon: Oct 6th at 1:07 PM
& weights low too?




5 replies

salvadord  8 days ago
weight is around avg - somatic EPSP of 0.74 mV

samn:speech_balloon:  8 days ago
ic

samn:speech_balloon:  8 days ago
ok, sounds like that aspect is cleared up. multiple strong stims in L2/3 could produce a response. maybe higher levels of L2/3 gamma supports that, to prevent everything from getting to L5...
:+1:
1


ericaygriffith:speech_balloon:  8 days ago
hm yeah that's a reassuring thought -- looking thru some previous runs to see if we have any with high L2/3 activity to see if we do see it coming thru to lower levels in that case
:+1:
2


samn:speech_balloon:  8 days ago
def. better than epileptic net ... leaves room for activation from the real inputs too

ericaygriffith:speech_balloon:  1:07 PM
these are out IT2 pmat numbers in conn.pkl, just for reference
1:07
Untitled 
 pmat['IT2']
{'IT2': 0.1971161130784888, 'IT3': 0.1971161130784888, 'ITP4': 0.019711611307848882, 'ITS4': 0.015829021201757432, 'IT5A': 0.10225398365946607, 'CT5A': 0.033035902413058274, 'IT5B': 0.10225398365946607, 'PT5B': 0.12899733323194185, 'CT5B': 0.033035902413058274, 'IT6': 0.0, 'CT6': 0.0, 'NGF1': 0.0, 'PV2': 0.5406866917894705, 'SOM2': 0.23449298047141015, 'VIP2': 0.0657305390018572, 'NGF2': 0.1352844118104289, 'PV3': 0.5406866917894705, 'SOM3': 0.23449298047141015, 'VIP3': 0.0657305390018572, 'NGF3': 0.1352844118104289, 'PV4': 0.11361264662917989, 'SOM4': 0.10693910647872001, 'VIP4': 0.11361264662917989, 'NGF4': 0.10693910647872001, 'PV5A': 0.110874992493537, 'SOM5A': 0.1314191429015595, 'VIP5A': 0.032569529044976495, 'NGF5A': 0.0, 'PV5B': 0.110874992493537, 'SOM5B': 0.1314191429015595, 'VIP5B': 0.032569529044976495, 'NGF5B': 0.0, 'PV6': 0.0, 'SOM6': 0.0, 'VIP6': 0.0, 'NGF6': 0.0}


1:07
and weights for IT2:
1:07
Untitled 
wmat['IT2']
{'IT2': 0.36, 'IT3': 0.36, 'ITP4': 0.34, 'ITS4': 0.34, 'IT5A': 0.74, 'CT5A': 0.74, 'IT5B': 0.74, 'PT5B': 0.74, 'CT5B': 0.74, 'IT6': 0.0, 'CT6': 0.0, 'NGF1': 0.0, 'PV2': 1.49, 'SOM2': 0.86, 'VIP2': 1.49, 'NGF2': 1.31, 'PV3': 1.49, 'SOM3': 0.86, 'VIP3': 1.49, 'NGF3': 1.31, 'PV4': 1.39, 'SOM4': 0.69, 'VIP4': 1.39, 'NGF4': 0.91, 'PV5A': 1.32, 'SOM5A': 0.53, 'VIP5A': 1.32, 'NGF5A': 0.0, 'PV5B': 1.32, 'SOM5B': 0.53, 'VIP5B': 1.32, 'NGF5B': 0.0, 'PV6': 0.0, 'SOM6': 0.0, 'VIP6': 0.0, 'NGF6': 0.0}


1:07
just for easier comparison
:+1:
1


samn:speech_balloon:  1:08 PM
so higher than allen for probabilities

salvadord  1:12 PM
y we rescaled E->E/I based on conn for E subtypes from BBP S1, since Allen lumped all as E
:+1:
2

1:15
I still find surprising with 0.1 conn prob it doesnt affect L5 ... though could also be because L5 already firing relatively high (~25-30 hz)

samn:speech_balloon:  1:16 PM
PV5B @ 84 Hz in that raster
1:17
yeah, could try it separate from optimization and see if a few stims in those layers causes noticeable response


** v29_batch2 - v29_batch1 with increased maxiters and GCP n2 80-core nodes
*** results
**** 1 layer at a time
Number of solutions (sims) out of ~40k with the following pops having rates within 0.01-200Hz:

- all celltypes
[] ['NGF1']
0
['IT2'] ['PV2', 'SOM2', 'VIP2', 'NGF2']
1257
['IT3'] ['PV3', 'SOM3', 'VIP3', 'NGF3']
10099
['ITP4', 'ITS4'] ['PV4', 'SOM4', 'VIP4', 'NGF4']
91
['IT5A', 'CT5A'] ['PV5A', 'SOM5A', 'VIP5A', 'NGF5A']
5306
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'SOM5B', 'VIP5B', 'NGF5B']
0
['IT6', 'CT6'] ['PV6', 'SOM6', 'VIP6', 'NGF6']
549
['TC', 'HTC', 'TCM'] ['IRE', 'IREM', 'TI', 'TIM']
4

- NO SOMs
['IT2'] ['PV2', 'VIP2', 'NGF2']
1257
['IT3'] ['PV3', 'VIP3', 'NGF3']
10182
['ITP4', 'ITS4'] ['PV4', 'VIP4', 'NGF4']
153
['IT5A', 'CT5A'] ['PV5A', 'VIP5A', 'NGF5A']
5341
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'VIP5B', 'NGF5B']
0
['IT6', 'CT6'] ['PV6', 'VIP6', 'NGF6']
549


- NO PVs
['IT2'] ['PV2', 'VIP2', 'NGF2']
1257
['IT3'] ['PV3', 'VIP3', 'NGF3']
10182
['ITP4', 'ITS4'] ['PV4', 'VIP4', 'NGF4']
153
['IT5A', 'CT5A'] ['PV5A', 'VIP5A', 'NGF5A']
5341
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'VIP5B', 'NGF5B']
0
['IT6', 'CT6'] ['PV6', 'VIP6', 'NGF6']
549


- no NGFs
['IT2'] ['PV2', 'SOM2', 'VIP2']
1415
['IT3'] ['PV3', 'SOM3', 'VIP3']
10304
['ITP4', 'ITS4'] ['PV4', 'SOM4', 'VIP4']
589
['IT5A', 'CT5A'] ['PV5A', 'SOM5A', 'VIP5A']
16599
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'SOM5B', 'VIP5B']
13649
['IT6', 'CT6'] ['PV6', 'SOM6', 'VIP6']
549

- no VIPs
['IT2'] ['PV2', 'SOM2', 'NGF2']
1388
['IT3'] ['PV3', 'SOM3', 'NGF3']
10252
['ITP4', 'ITS4'] ['PV4', 'SOM4', 'NGF4']
104
['IT5A', 'CT5A'] ['PV5A', 'SOM5A', 'NGF5A']
5834
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'SOM5B', 'NGF5B']
0
['IT6', 'CT6'] ['PV6', 'SOM6', 'NGF6']
551

- no NGF + ITS4
['ITP4'] ['SOM4', 'VIP4', 'PV4']
12718

- no NGF + ITP4
['ITS4'] ['SOM4', 'PV4', 'VIP4']
614

- no NGFs + VIPs
['IT2'] ['PV2', 'SOM2']
2033
['IT3'] ['PV3', 'SOM3']
10585
['ITP4', 'ITS4'] ['PV4', 'SOM4']
1663
['IT5A', 'CT5A'] ['PV5A', 'SOM5A']
23776
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'SOM5B']
21787
['IT6', 'CT6'] ['PV6', 'SOM6']
551

- no NGF + VIPS+ ITS4
['ITP4'] ['SOM4', 'PV4', 'PV4']
24350

- no NGF + VIPS+ ITP4
['ITS4'] ['SOM4', 'PV4', 'PV4']
1692

- no NGFs + SOMs
['IT2'] ['PV2', 'VIP2']
1415
['IT3'] ['PV3', 'VIP3']
10389
['ITP4', 'ITS4'] ['PV4', 'VIP4']
655
['IT5A', 'CT5A'] ['PV5A', 'VIP5A']
16942
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'VIP5B']
14149
['IT6', 'CT6'] ['PV6', 'VIP6']
549

- no NGFs + SOMs
['IT2'] ['PV2', 'VIP2']
1415
['IT3'] ['PV3', 'VIP3']
10389
['ITP4', 'ITS4'] ['PV4', 'VIP4']
655
['IT5A', 'CT5A'] ['PV5A', 'VIP5A']
16942
['IT5B', 'PT5B', 'CT5B'] ['PV5B', 'VIP5B']
14149
['IT6', 'CT6'] ['PV6', 'VIP6']
549

- no NGFs + PVs
['IT2'] ['VIP2', 'SOM2']
1948
['IT3'] ['VIP3', 'SOM3']
15069
['ITP4', 'ITS4'] ['VIP4', 'SOM4']
678
['IT5A', 'CT5A'] ['VIP5A', 'SOM5A']
19675
['IT5B', 'PT5B', 'CT5B'] ['VIP5B', 'SOM5B']
15041
['IT6', 'CT6'] ['VIP6', 'SOM6']
8403


- no TI (thal)
['TC', 'HTC', 'TCM'] ['IRE', 'IREM', 'TI']
23995

**** 2 layers at a time
Number of solutions (sims) out of ~40k with the following pops having rates within 0.01-200Hz:

- all cell types:
['IT2', 'IT3'] ['PV2', 'SOM2', 'VIP2', 'NGF2', 'PV3', 'SOM3', 'VIP3', 'NGF3']
1121
['IT3', 'ITP4', 'ITS4'] ['PV3', 'SOM3', 'VIP3', 'NGF3', 'PV4', 'SOM4', 'VIP4', 'NGF4']
53
['ITP4', 'ITS4', 'IT5A', 'CT5A'] ['PV4', 'SOM4', 'VIP4', 'NGF4', 'PV5A', 'SOM5A', 'VIP5A', 'NGF5A']
36
['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B'] ['PV5A', 'SOM5A', 'VIP5A', 'NGF5A', 'PV5B', 'SOM5B', 'VIP5B', 'NGF5B']
0
['IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6'] ['PV5B', 'SOM5B', 'VIP5B', 'NGF5B', 'PV6', 'SOM6', 'VIP6', 'NGF6']
0

- no NGFs:
['IT2', 'IT3'] ['PV2', 'SOM2', 'VIP2', 'PV3', 'SOM3', 'VIP3']
1273
['IT3', 'ITP4', 'ITS4'] ['PV3', 'SOM3', 'VIP3', 'PV4', 'SOM4', 'VIP4']
104
['ITP4', 'ITS4', 'IT5A', 'CT5A'] ['PV4', 'SOM4', 'VIP4', 'PV5A', 'SOM5A', 'VIP5A']
201
['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B'] ['PV5A', 'SOM5A', 'VIP5A', 'PV5B', 'SOM5B', 'VIP5B']
12839
['IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6'] ['PV5B', 'SOM5B', 'VIP5B', 'PV6', 'SOM6', 'VIP6']
296

-  no NGFs+VIPs
['IT2', 'IT3'] ['PV2', 'SOM2', 'PV3', 'SOM3']
1849
['IT3', 'ITP4', 'ITS4'] ['PV3', 'SOM3', 'PV4', 'SOM4']
273
['ITP4', 'ITS4', 'IT5A', 'CT5A'] ['PV4', 'SOM4', 'PV5A', 'SOM5A']
1010
['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B'] ['PV5A', 'SOM5A', 'PV5B', 'SOM5B']
21212
['IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6'] ['PV5B', 'SOM5B', 'PV6', 'SOM6']
422

-  no NGFs+VIPs (L3 with rest)
['IT2', 'IT3'] ['PV2', 'SOM2', 'PV3', 'SOM3']
1849
['IT3', 'ITP4', 'ITS4'] ['PV3', 'SOM3', 'PV4', 'SOM4']
273
['IT3', 'IT5A', 'CT5A'] ['PV3', 'SOM3', 'PV5A', 'SOM5A']
8991
['IT3', 'IT5B', 'PT5B', 'CT5B'] ['PV3', 'SOM3', 'PV5B', 'SOM5B']
8395
['IT3', 'IT6', 'CT6'] ['PV3', 'SOM3', 'PV6', 'SOM6']
228

-  no NGFs+VIPs (L4 with rest)
['IT2', 'ITP4', 'ITS4'] ['PV2', 'SOM2', 'PV4', 'SOM4']
1
['IT3', 'ITP4', 'ITS4'] ['PV3', 'SOM3', 'PV4', 'SOM4']
273
['ITP4', 'ITS4', 'IT5A', 'CT5A'] ['PV4', 'SOM4', 'PV5A', 'SOM5A']
1010
['ITP4', 'ITS4', 'IT5B', 'PT5B', 'CT5B'] ['PV4', 'SOM4', 'PV5B', 'SOM5B']
887
['ITP4', 'ITS4', 'IT6', 'CT6'] ['PV4', 'SOM4', 'PV6', 'SOM6']
9


**** 3 layers at a time
Number of solutions (sims) out of ~40k with the following pops having rates within 0.01-200Hz:

**** Multiple layers

- All except: TIM, ITS4, NGF, VIP
 Filtering based on E + I pops: ['rates']
0.01<=SOM2_1750_2000<=200 and 0.01<=PV2_1750_2000<=200 and 0.01<=SOM3_1750_2000<=200 and 0.01<=PV3_1750_2000<=200 and 0.01<=SOM4_1750_2000<=200 and 0.01<=PV4_1750_2000<=200 and 0.01<=SOM5A_1750_2000<=200 and 0.01<=PV5A_1750_2000<=200 and 0.01<=SOM5B_1750_2000<=200 and 0.01<=PV5B_1750_2000<=200 and 0.01<=SOM6_1750_2000<=200 and 0.01<=PV6_1750_2000<=200 and 0.01<=IRE_1750_2000<=200 and 0.01<=IREM_1750_2000<=200 and 0.01<=TI_1750_2000<=200 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
4720     4720  196.279426        2.525180      1.415371      1.181422      0.149769        1.167405  ...          8.96          9.60          9.28            0.0            0.0            0.0            0.0
4735     4735  176.900135        2.522534      1.068643      1.481244      0.147047        1.172058  ...          9.28          9.44          9.76            0.0            0.0            0.0            0.0
4746     4746  186.014585        2.506955      1.076376      1.177170      0.156911        1.038090  ...          9.12          8.96          9.28            0.0            0.0            0.0            0.0
4752     4752  184.465662        2.528949      1.066805      1.177367      0.150565        1.061452  ...          9.12          8.48          8.64            0.0            0.0            0.0            0.0
5331     5331  205.786178        1.264519      1.454422      1.422741      0.140669        1.174307  ...          9.60          9.60          9.92            0.0            0.0            0.0            0.0
35984   35984  156.808598        0.352688      2.034246      1.922625      0.147769        0.703715  ...          8.64          8.48          9.76            0.0            0.0            0.0            0.0


- All E pops; no I pops required

 Filtering based on E pops: ['rates']
0.01<=IT2_1750_2000<=200 and 0.01<=IT3_1750_2000<=200 and 0.01<=ITS4_1750_2000<=200 and 0.01<=ITP4_1750_2000<=200 and 0.01<=IT5A_1750_2000<=200 and 0.01<=CT5A_1750_2000<=200 and 0.01<=IT5B_1750_2000<=200 and 0.01<=PT5B_1750_2000<=200 and 0.01<=CT5B_1750_2000<=200 and 0.01<=IT6_1750_2000<=200 and 0.01<=CT6_1750_2000<=200 and 0.01<=TC_1750_2000<=200 and 0.01<=HTC_1750_2000<=200 and 0.01<=TCM_1750_2000<=200 

In [3]: dfFilter.sort_values('value')
Out[3]: 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
29834   29834  214.604563        0.816199      2.248762      1.465796      0.101031        0.319455  ...          9.12          9.44          9.76            0.0            0.0            0.0            0.0
21955   21955  257.577638        1.150613      2.195296      1.498914      0.100694        0.366509  ...          9.44          8.80          9.12            0.0            0.0            0.0            0.0
11533   11533  278.845263        1.087404      2.068392      1.497798      0.100783        0.359008  ...          9.60          9.12          9.60            0.0            0.0            0.0            0.0
29486   29486  284.727525        0.757377      1.691641      1.400627      0.100533        0.398611  ...          9.60          8.80          9.60            0.0            0.0            0.0            0.0
11065   11065  290.300427        1.187804      1.897773      1.613020      0.102180        0.431450  ...          8.80          8.48          9.28            0.0            0.0            0.0            0.0
9499     9499  296.988502        1.285614      2.252270      1.428221      0.100360        0.465989  ...          9.44          9.12          9.28            0.0            0.0            0.0            0.0
21980   21980  378.994802        0.959330      1.898465      1.501951      0.150576        0.550258  ...          8.16          8.32          8.00            0.0            0.0            0.0            0.0


- L2+3+4 E+I (NO NGF+VIP) 

 Filtering based on E + I pops: ['rates']
0.01<=SOM2_1750_2000<=200 and 0.01<=PV2_1750_2000<=200 and 0.01<=SOM3_1750_2000<=200 and 0.01<=PV3_1750_2000<=200 and 0.01<=SOM4_1750_2000<=200 and 0.01<=PV4_1750_2000<=200 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
19405   19405  313.231487        0.982087       1.96245      1.395838      0.100029         0.34365  ...          9.44          8.48          9.76            0.0            0.0            0.0            0.0

[1 rows x 230 columns]
1


- L2+3+4 E+I (NO NGF+VIP+ITS4)

1044

- L2+3+4 E+I (NO NGF+ITS4)

21


- L5A,5B,6 E+I (NO NGF) 

 Filtering based on E + I pops: ['rates']
0.01<=SOM5A_1750_2000<=200 and 0.01<=PV5A_1750_2000<=200 and 0.01<=SOM5B_1750_2000<=200 and 0.01<=PV5B_1750_2000<=200 and 0.01<=SOM6_1750_2000<=200 and 0.01<=PV6_1750_2000<=200 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
96         96  406.138203        1.021888      1.720320      2.033943      0.105357        0.632811  ...          7.36          7.20          8.00            0.0           0.00           0.00           0.00
99         99  352.030195        0.729735      1.635442      1.964223      0.108902        0.836380  ...          7.84          8.32          8.32            0.0           0.00           0.00           0.32
180       180  300.206294        0.656118      1.479756      1.437200      0.106238        0.625935  ...          8.00          8.96          8.96            0.0           0.16           0.16           0.00
187       187  362.721582        0.698767      1.863606      1.616652      0.106268        0.624685  ...          9.76          9.28         10.08            0.0           0.00           0.00           0.00
291       291  253.592600        0.527498      1.361050      1.554490      0.198303        1.064973  ...          6.88          7.36          7.68            0.0           0.00           0.00           0.00
...       ...         ...             ...           ...           ...           ...             ...  ...           ...           ...           ...            ...            ...            ...            ...
38215   38215  308.859183        1.014043      1.986808      1.274551      0.149485        0.438205  ...          8.48          9.28          9.44            0.0           0.00           0.00           0.00
38235   38235  322.601654        0.890068      1.999058      0.830437      0.148718        0.460331  ...          8.32          8.80          8.96            0.0           0.00           0.00           0.00
38504   38504  274.685154        0.939122      1.970261      0.432678      0.151542        0.373413  ...          8.64          9.76          9.44            0.0           0.00           0.00           0.00
38847   38847  107.122255        0.870853      2.026761      0.914985      0.153562        0.501627  ...          8.96          8.48          8.48            0.0           0.00           0.00           0.00
38922   38922  275.564188        0.871219      2.009719      0.491761      0.151687        0.451387  ...          9.28          8.96          9.92            0.0           0.00           0.00           0.00

[408 rows x 230 columns]
408
['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6'] ['SOM5A', 'PV5A', 'SOM5B', 'PV5B', 'SOM6', 'PV6']
408


- L5A,5B,6 E+I (NO NGF+VIP) 

 Filtering based on E + I pops: ['rates']
0.01<=SOM5A_1750_2000<=200 and 0.01<=PV5A_1750_2000<=200 and 0.01<=VIP5A_1750_2000<=200 and 0.01<=SOM5B_1750_2000<=200 and 0.01<=PV5B_1750_2000<=200 and 0.01<=VIP5B_1750_2000<=200 and 0.01<=SOM6_1750_2000<=200 and 0.01<=PV6_1750_2000<=200 and 0.01<=VIP6_1750_2000<=200 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
358       358  247.294075        0.393895      1.205346      2.497569      0.203703        1.168813  ...          0.32          1.60          3.04            0.0            0.0            0.0            0.0
1258     1258  212.908082        2.628327      1.104676      0.996672      0.146807        1.327033  ...          8.48          9.60          9.44            0.0            0.0            0.0            0.0
1301     1301  208.493956        2.497085      1.036306      1.033008      0.150680        1.314046  ...          8.64          8.96          9.44            0.0            0.0            0.0            0.0
1686     1686  292.105837        2.659689      1.263736      1.097544      0.147424        1.275752  ...          8.64          9.28          8.64            0.0            0.0            0.0            0.0
1695     1695  211.337109        2.662798      1.255773      1.116682      0.150551        1.288195  ...          9.28          9.92          9.44            0.0            0.0            0.0            0.0
...       ...         ...             ...           ...           ...           ...             ...  ...           ...           ...           ...            ...            ...            ...            ...
38019   38019         NaN             NaN           NaN           NaN           NaN             NaN  ...          9.28          9.28          8.96            0.0            0.0            0.0            0.0
38039   38039  110.450001        0.957378      1.984317      1.342510      0.155504        0.530147  ...          8.00          8.80          8.80            0.0            0.0            0.0            0.0
38504   38504  274.685154        0.939122      1.970261      0.432678      0.151542        0.373413  ...          8.64          9.76          9.44            0.0            0.0            0.0            0.0
38847   38847  107.122255        0.870853      2.026761      0.914985      0.153562        0.501627  ...          8.96          8.48          8.48            0.0            0.0            0.0            0.0
38922   38922  275.564188        0.871219      2.009719      0.491761      0.151687        0.451387  ...          9.28          8.96          9.92            0.0            0.0            0.0            0.0

[264 rows x 230 columns]
264
['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6'] ['SOM5A', 'PV5A', 'VIP5A', 'SOM5B', 'PV5B', 'VIP5B', 'SOM6', 'PV6', 'VIP6']
264

- L5A,5B,6 E+I (NO NGF+VIP)  <40hz

 Filtering based on E + I pops: ['rates']
0.01<=SOM5A_1750_2000<=200 and 0.01<=PV5A_1750_2000<=200 and 0.01<=VIP5A_1750_2000<=200 and 0.01<=SOM5B_1750_2000<=200 and 0.01<=PV5B_1750_2000<=200 and 0.01<=VIP5B_1750_2000<=200 and 0.01<=SOM6_1750_2000<=200 and 0.01<=PV6_1750_2000<=200 and 0.01<=VIP6_1750_2000<=200 
       number       value  EILayerGain1-3  EILayerGain4  EILayerGain5  EILayerGain6  IELayerGain1-3  ...  TI_1250_1500  TI_1500_1750  TI_1750_2000  TIM_1000_1250  TIM_1250_1500  TIM_1500_1750  TIM_1750_2000
358       358  247.294075        0.393895      1.205346      2.497569      0.203703        1.168813  ...          0.32          1.60          3.04            0.0            0.0            0.0           0.00
18779   18779  149.368530        0.932133      1.966431      1.433206      0.102579        2.226749  ...          8.80          8.32          8.32            0.0            0.0            0.0           0.00
22305   22305  254.927907        0.911482      1.938855      1.657147      0.101034        0.519786  ...          8.48          8.16          8.80            0.0            0.0            0.0           0.00
27742   27742  174.027776        0.762392      2.093655      1.469545      0.102313        0.532864  ...          7.68          8.32          7.84            0.0            0.0            0.0           0.00
28202   28202  248.636374        0.922996      1.739317      1.480892      0.101525        0.511386  ...          7.36          7.68          7.20            0.0            0.0            0.0           0.00
30641   30641  246.649332        0.772034      2.049188      1.432427      0.102199        0.496337  ...          7.68          7.52          7.36            0.0            0.0            0.0           0.32
33559   33559  246.380751        1.121240      2.194362      1.725751      0.101278        0.487843  ...          8.00          8.16          8.00            0.0            0.0            0.0           0.00
33609   33609  173.846265        1.128041      2.204684      2.035821      0.100948        0.572834  ...          8.80          8.16          8.64            0.0            0.0            0.0           0.00
33638   33638  152.398000        1.122501      2.262560      1.773047      0.100855        0.577510  ...          8.96          9.12          8.96            0.0            0.0            0.0           0.00
35433   35433  153.321006        1.048183      2.125032      1.755068      0.101688        0.543698  ...          8.00          8.48          7.52            0.0            0.0            0.0           0.00

[10 rows x 230 columns]

*** results conclusions
1 layer at a time:
- NGF1 never fires
- NGF cell type problematic for L4,L5A,L5B (i.e. removing leads to significantly more solutions); not much for L2,L3
- VIP problematic for L4,L5A,L5B (similar subset as NGF; mostly due to NGF); not much for L2,L3
- PV,SOM ~problematic for L6
- TIM only fires in 6/40k sims; problematic for thal (most thal solutions ok if exclude TIM)
- ITS4 problematic for L4 (down from 23k to 1.6k solns); max 1Hz (traces show depol block)

2 layers at a time (no NGF+VIP): 
- L2 and L3 90% overlap of solns (1849/2033); ok
- L3 and L4 16% overlap of solns (273/1663); hyperinhibition / hyperexcitation?
- L4 and L5A 61% overlap of solns (1010/1663); ok'ish
- L5A and L5B 61% overlap of solns (1010/1663); ok'ish
- L5B and L6 77% overlap of solns (422/551); ok 

- L3 and L5A 38% overlap of solns (8991/23776); possible hyperinhibition / hyperexcitation?
- L3 and L5B 38% overlap of solns (8395/21787); possible hyperinhibition / hyperexcitation?
- L3 and L6 41% overlap of solns (228/551); possible hyperinhibition / hyperexcitation?

- L4 and L2 <1% overlap of solns (1/1663); hyperinhibition / hyperexcitation
- L4 and L5B 53% overlap of solns (887/1663); ok
- L4 and L6 2% overlap of solns (9/551); hyperinhibition / hyperexcitation?

Multiple layers
- All except: TIM, ITS4, NGF, VIP 6/40k
- Only E pops 7/40k
- Only L2-4 E+I (no NGF+VIP) 1/40k (0 if include NGF or VIP)
- Only L2-4 E+I (no NGF+VIP+ITS4) 1099/40k (21 if include VIP; 0 if include NGF) - some with burst
- Only L5A-6 E+I (no NGF+VIP) 408/40k (264/40k if include VIP; 0 if include NGF)
- Only L5A-6 E+I (no NGF), <40Hz, 10/40k

- Most problematic: L4-L2, L4-L3 and L4-6 
- L2-4 harder to tune than L5A-6 (1 vs >200 solutions); mostly due to ITS4

Hypotheses:
- L2-4 I fire too high and inhibit ITS4 (or decrease)
- L2-4 E -> IT4 conn too strong, leads to ITS4 hyperexc (depol block)


*** Possible next steps
- increase bkg input or conn to NGF1, TIM, ITS4
- tune L2-L4 and L4-L6 separately with E->PV,SOM,VIP,NGF specific gains
-- faster to run each sim
-- smaller parameter space (exponential decrease)


** v30_batch1 - tuning by layers - thal + L4
*** notes
after 500 trials, ITS4 never spiked
probably due to low bkg inputs and low thal inputs
try: add bkg input gains to thal pops -> stronger thal -> ITS4 fires
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch2 - tuning by layers - thal + L4
*** notes
added bkg input gains to thal pops -> stronger thal -> ITS4 fires
reduced to 1.5 secs
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch3 - same but replace ITS4 with IT cell type
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch4 - run best result from v30_batch3 for 10 sec
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch5 - tuning  L2+3+4 + thal
*** notes
increased duration since requires 1.5 sec to reach steady state
- needs over 1.5 sec to reach steady state!!!
- ITS4 not firing
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch6 - tuning  only L3+L4+thal; include L4 weights but starting from tuned and smaller interval - bug
*** notes
fitness func didn't include L3 pops
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch7 - tuning same as v30_batch6 but fixed fitness func to include L3 pops
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch8 - tuning added L2 and reduced width of gaussian tuning window
*** note
results were getting very low fitness, so made tuning func more restrictive by narrowing the gaussian func widths
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
** v30_batch9 - tuning best soln of v30_batch8, with param ranges +- 0.25, min rate = 0.5; increase min rate required
*** notes
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
*** code

- param ranges:

    # from v30_batch8 (optuna), trial 3958
    import json
    with open('data/v30_batch8/trial_3958/trial_3958_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()


    rangeV = 0.25
    minV = 0.1
    maxV = 5.0

    # bkg inputs
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EILayerGain']['2']-rangeV, minV), min(cfgLoad['EILayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['IELayerGain']['2']-rangeV, minV), min(cfgLoad['IELayerGain']['2']+rangeV, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['IILayerGain']['2']-rangeV, minV), min(cfgLoad['IILayerGain']['2']+rangeV, maxV)]

    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EILayerGain']['3']-rangeV, minV), min(cfgLoad['EILayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['IELayerGain']['3']-rangeV, minV), min(cfgLoad['IELayerGain']['3']+rangeV, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['IILayerGain']['3']-rangeV, minV), min(cfgLoad['IILayerGain']['3']+rangeV, maxV)]

    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV, minV), min(cfgLoad['EELayerGain']['4']+rangeV, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV, minV), min(cfgLoad['EILayerGain']['4']+rangeV, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV, minV), min(cfgLoad['IELayerGain']['4']+rangeV, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV, minV), min(cfgLoad['IILayerGain']['4']+rangeV, maxV)]


- tuning func: 
    Etune = {'target': 5, 'width': 5, 'min': 0.5}
    Itune = {'target': 10, 'width': 15, 'min': 0.5}
*** results
- did not find better solution -- ITS3 too low

- highest IT3 rates (1 - 1.5Hz) --> high SOM rates (~15hz)
- highest IT3 rates (1 - 1.5Hz) --> mid PV rates (~3hz)
- highest IT3 rates (1 - 1.5Hz) --> low VIP rates (<1hz)
- highest IT3 rates (1 - 1.5Hz) --> mid NGF rates (~3Hz)

- ITS4 proportional to ITP4; ITP4 slope x2
- ITS4 proportional to PV4; PV4 slope x25
- ITS4 proportional to SOM4; SOM4 slope x50
- ITS4 inversely proportional to VIP4; VIP4 slope x10; if ITS4 > 1.0 -> VIP4 = 0Hz
- ITS4 proportional to NGF4; NGF4 slope x2


** v30_batch10 - tuning best soln of v30_batch8, with cell-type specific EI gains
*** notes
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing
*** code
    params[('EICellTypeGain', 'PV')] = [minV, maxV]
    params[('EICellTypeGain', 'SOM')] = [minV, maxV]
    params[('EICellTypeGain', 'VIP')] = [minV, maxV]
    params[('EICellTypeGain', 'NGF')] = [minV, maxV]
** v30_batch11 - tuning L2+3+4+thal, layerwise + celltype
*** notes
https://docs.google.com/document/d/1Gbest9Xillhkq9XQ-UVBvq3AWZAkBBdcuDV74S7Nbtg/edit?usp=sharing

*** code
    minV1 = 0.2
    maxV1 = 4.0

    params[('EICellTypeGain', 'PV')] = [minV1, maxV1]
    params[('EICellTypeGain', 'SOM')] = [minV1, maxV1]
    params[('EICellTypeGain', 'VIP')] = [minV1, maxV1]
    params[('EICellTypeGain', 'NGF')] = [minV1, maxV1]

    params[('EELayerGain', '2')] = [minV1, maxV1]
    params[('EILayerGain', '2')] = [minV1, maxV1]
    params[('IELayerGain', '2')] = [minV1, maxV1]
    params[('IILayerGain', '2')] = [minV1, maxV1]

    params[('EELayerGain', '3')] = [minV1, maxV1]
    params[('EILayerGain', '3')] = [minV1, maxV1]
    params[('IELayerGain', '3')] = [minV1, maxV1]
    params[('IILayerGain', '3')] = [minV1, maxV1]

    params[('EELayerGain', '4')] = [minV1, maxV1]
    params[('EILayerGain', '4')] = [minV1, maxV1]
    params[('IELayerGain', '4')] = [minV1, maxV1]
    params[('IILayerGain', '4')] = [minV1, maxV1]

** v30_batch12 - tuning L4 + thal,  layer-specific + celltype-specific gains
*** notes
fixed thal gains from prev; 
Overall ESOM, EPV, ENGF, EVIP gains in range [0.2, 3]
L4 EE, EI, IE, II gains in range [0.2, 3]
8 params with large range
maybe II cell type-specific gains?

** v30_batch13 - tuning L4 + thal,  layer-specific + celltype-specific gains -- repeat
*** notes
very similar results -- good, as expected
** v31_batch2 - tuning L4 + thal, layer-specific + celltype-specific gains; new ITS4
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L3, with broad param range [0.2:4.0]
layer-specific EE,EI,IE,II gains for L4, with range [prev-0.25:prev+0.25]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) in range [prev-0.25:prev+0.25]
12 params; 8 small range, 4 large range
good results


** v31_batch3 - tuning L2+L3+L4 layer- + celltype-specific gains
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with broad param range [0.2:3.0]
layer-specific EE,EI,IE,II gains for L3, with param range [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L4, with param range [prev-0.25:prev+0.25]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
16 params; 12 small range, 4 large range
Good results but IT3 0.5-1.0 Hz
higher IT3 rates -> too high PV2+SOM2 is projecting too strongly to PV2 and SOM2 
** v31_batch4 - tuning L2+L3+L4 layer- + celltype-specific gains -- try wider range for prev params
*** notes
same as v31_batch3 but E-PV, E-SOM, E-NGF, E-VIP params in range [prev-0.5:prev+0.5]
** v31_batch5 - tuning L2+L3+L4 layer- + celltype-specific gains -- try wider range + min rate of 1 Hz
*** notes
same as v31_batch4 but min population rate set to 1.0 Hz (instead of 0.5 Hz)
** v31_batch6 - tuning L2+L3+L4+L5A layer + celltype-specific gains; from v31_batch4; small ranges
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with broad param range [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L3, with param range [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L4, with param range [prev-0.1:prev+0.1]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L5A, with broad param range [0.2:3.0]
20 params; 12 very small range, 4 small range, 4 large range
** v31_batch7 - tuning L2+L3+L4+L5A+L5B layer + celltype-specific gains; from v31_batch6; small ranges (subset of params)
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with fixed params
layer-specific EE,EI,IE,II gains for L3, with fixed params
layer-specific EE,EI,IE,II gains for L4, with fixed params
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.2:3.0]
20 params; 12 very small range, 4 small range, 4 large range
** v31_batch8 - tuning L2+L3+L4+L5A+L5B layer + celltype-specific gains; from v31_batch6; small ranges (all params)
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.2:3.0]
20 params; 12 very small range, 4 small range, 4 large range

** v31_batch9 - tuning increase L5B range from 0.2-3.0 to 0.1-5.0; increase L2+L3 range from 0.1 to 0.25
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:5.0]
20 params; 8 very small range, 8 small range, 4 large range
No good solutions; stuck at ~96 fitness
SOM2, SOM3, PT5B, CT5B 0hz or very low rate

** v32_batch1 - tuning L2-L5B; added IE presyn-cell-type specific params
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]
layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
28 params; 8 very small range, 12 small range, 4 large range
good solution: fitness=47; all pops good except PV2 (~160Hz) and IT5B (~28hz) a bit high
some solutions interesting slow (~1hz) oscillations on top of the fast ones (eg trial_13047)
PV2 in particular is just ~5 cells, so prob has some peculiarities due to small size, and hopefully not hard to fix
keep going with L6, and just fine tune at the end if needed

*** results
In [12]: df.iloc[7642][:30]
Out[12]: 
number               7642.000000
value                  45.737540
EELayerGain2            1.466797
EELayerGain3            0.733775
EELayerGain4            0.383257
EELayerGain5A           1.134515
EELayerGain5B           3.580222
EICellTypeGainNGF       0.523345
EICellTypeGainPV        1.577954
EICellTypeGainSOM       0.422428
EICellTypeGainVIP       1.963884
EILayerGain2            0.181358
EILayerGain3            0.210892
EILayerGain4            0.109693
EILayerGain5A           0.263932
EILayerGain5B           0.162074
IECellTypeGainNGF       0.495923
IECellTypeGainPV        0.503529
IECellTypeGainSOM       1.042023
IECellTypeGainVIP       0.170270
IELayerGain2            3.091169
IELayerGain3            2.692236
IELayerGain4            1.747858
IELayerGain5A           2.515508
IELayerGain5B           0.382218
IILayerGain2            0.885747
IILayerGain3            2.328585
IILayerGain4            0.965311
IILayerGain5A           0.230596
IILayerGain5B           0.103807

In [10]: df.iloc[6668][:30]
Out[10]: 
number               6668.000000
value                  51.626852
EELayerGain2            1.490007
EELayerGain3            0.710163
EELayerGain4            0.372384
EELayerGain5A           1.179958
EELayerGain5B           3.739412
EICellTypeGainNGF       0.538782
EICellTypeGainPV        1.616799
EICellTypeGainSOM       0.444799
EICellTypeGainVIP       1.947859
EILayerGain2            0.190476
EILayerGain3            0.221521
EILayerGain4            0.104049
EILayerGain5A           0.257049
EILayerGain5B           0.175283
IECellTypeGainNGF       0.310249
IECellTypeGainPV        0.532399
IECellTypeGainSOM       0.957409
IECellTypeGainVIP       1.066277
IELayerGain2            3.048898
IELayerGain3            2.689434
IELayerGain4            1.745614
IELayerGain5A           2.514517
IELayerGain5B           0.461983
IILayerGain2            0.899853
IILayerGain3            2.375172
IILayerGain4            0.971353
IILayerGain5A           0.230639
IILayerGain5B           0.103220

In [16]: df.iloc[6668][30:66]
Out[16]: 
IT2        7.603550
PV2      166.833333
SOM2      11.000000
VIP2      48.375000
NGF2       3.200000
IT3        1.841704
SOM3       1.885714
PV3       45.318182
VIP3       5.219048
NGF3       1.720000
ITP4       5.186603
ITS4       4.454545
PV4       28.108696
SOM4       5.000000
VIP4      22.833333
NGF4       1.571429
IT5A       1.452514
CT5A       9.312849
PV5A      57.250000
SOM5A     19.904762
VIP5A      3.000000
NGF5A     10.000000
IT5B      26.855319
PT5B       1.340426
CT5B       6.642553
PV5B      63.701493
SOM5B     35.982143
VIP5B     21.375000
NGF5B      2.166667
TC         6.086207
TCM       23.168831
HTC        5.421053
IRE        3.298701
IREM       3.077922
TI         3.880000
TIM        5.200000
Name: 6668, dtype: float64

In [17]: df.iloc[7642][30:66]
Out[17]: 
IT2        9.692308
PV2      168.500000
SOM2       6.000000
VIP2      40.500000
NGF2       3.200000
IT3        2.231390
SOM3       1.685714
PV3       49.420455
VIP3       3.533333
NGF3       1.866667
ITP4       4.468900
ITS4       3.811005
PV4       24.369565
SOM4       4.083333
VIP4      32.666667
NGF4       1.571429
IT5A       2.625698
CT5A      12.351955
PV5A      72.527778
SOM5A     21.428571
VIP5A      2.400000
NGF5A     10.500000
IT5B      27.863830
PT5B       2.000000
CT5B       1.646809
PV5B      50.716418
SOM5B     31.375000
VIP5B     19.125000
NGF5B      2.166667
TC         4.689655
TCM       24.662338
HTC        4.894737
IRE        3.168831
IREM       3.792208
TI         2.720000
TIM        4.720000
** v32_batch2 - tuning L2-L6; EI and IE cell-type specific gains; params from v32_batch1; 20 very small rannges
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EE,EI,IE,II gains for L2, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L5B, with param range [prev-0.1:prev+0.1]
layer-specific EE,EI,IE,II gains for L6, with broad param range [0.1:4.0]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [prev-0.25:prev+0.25]
32 params; 20 very small range, 8 small range, 4 large range

** v32_batch3 - tuning L1-L6; EI and IE cell-type specific gains; params from v32_batch1; added NGF1; inc range 0.1 to 0.15
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EI,II gains for L1, with broad param range [0.1:4.0]
layer-specific EE,EI,IE,II gains for L2, with [prev-0.15:prev+0.15]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.15:prev+0.15]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.15:prev+0.15]
layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.15:prev+0.15]
layer-specific EE,EI,IE,II gains for L5B, with param range [prev-0.15:prev+0.15]
layer-specific EE,EI,IE,II gains for L6, with broad param range [0.1:4.0]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [prev-0.25:prev+0.25]
34 params; 20 very small range, 8 small range, 6 large range

** v32_batch4 - tuning best soln v32_batch3, +- 0.2 all params; min rate >=0.5Hz
*** notes
fixed/frozen gains for thal from prev solution
layer-specific EI,II gains for L1, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L2, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L3, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L4, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L5A, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L5B, with [prev-0.2:prev+0.2]
layer-specific EE,EI,IE,II gains for L6, with [prev-0.2:prev+0.2]
E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.2:prev+0.2]
PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [prev-0.2:prev+0.2]
34 params; 34 small range
*** results
many good results
best: trial_15057

** v32_batch5 - run best of v32_batch4, with LFP; 3 scales 
*** notes
*** code
def custom():
    params = specs.ODict()

    # from v32_batch1 (optuna L2-L5B), trial 6668
    import json
    with open('data/v32_batch4/trial_15057/trial_15057_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # conn gains

    initCfg['scaleDensity'] = [0.5, 0.75, 1.0]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = cfgLoad  # set default options from prev sim
    
    initCfg['duration'] = 2500
    initCfg['printPopAvgRates'] = [1500, 2500] 

    # plotting and saving params
    initCfg['recordLFP'] = [[100, y, 100] for y in range(0, 2000, 100)]

    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotCSD')] = {'spacing_um': 100, 'timeRange': initCfg['printPopAvgRates'], 'LFP_overlay': True, 'layer_lines': True, 'saveFig': 1, 'showFig': 0}

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b
** v32_batch6 - run best of v32_batch4, with LFP; with cochlear/IC speech input; with different cortichothal gains
** v32_batch7 - run best of v32_batch4, with LFP; scaled to 100% with different gains / scaling factors
** v32_batch8 - tuning scale 1.0, from v32_batch4, with param range -0.4 +0.1
*** results
**** params order of importance (optuna)
OrderedDict([("('IELayerGain', '5B')", 0.7499801502949816),
             ("('EELayerGain', '6')", 0.055137684099558305),
             ("('EILayerGain', '2')", 0.03635570655825216),
             ("('EILayerGain', '5B')", 0.035392440489203265),
             ("('IILayerGain', '1')", 0.022242992113195782),
             ("('IILayerGain', '4')", 0.012277743367558977),
             ("('IILayerGain', '5B')", 0.011612647383699343),
             ("('EILayerGain', '3')", 0.009056442192559315),
             ("('EELayerGain', '4')", 0.00710624539774585),
             ("('IECellTypeGain', 'SOM')", 0.005899490508980003),
             ("('IELayerGain', '3')", 0.005484483076799773),
             ("('IELayerGain', '4')", 0.005259504941152925),
             ("('EILayerGain', '5A')", 0.0038855760530673573),
             ("('EICellTypeGain', 'VIP')", 0.003723196948324842),
             ("('EILayerGain', '6')", 0.0035016070582954226),
             ("('IILayerGain', '3')", 0.002852825893140483),
             ("('EICellTypeGain', 'SOM')", 0.0027826202811932397),
             ("('EELayerGain', '5A')", 0.002616465265447208),
             ("('IILayerGain', '5A')", 0.0023586747106461156),
             ("('IELayerGain', '2')", 0.002179872554014031),
             ("('IECellTypeGain', 'NGF')", 0.0020017208171822327),
             ("('EELayerGain', '2')", 0.0020012870209595184),
             ("('IECellTypeGain', 'PV')", 0.002000904527418183),
             ("('EICellTypeGain', 'PV')", 0.001971158738791962),
             ("('EELayerGain', '5B')", 0.0019025344008027562),
             ("('EELayerGain', '3')", 0.0016153303988286137),
             ("('EILayerGain', '1')", 0.00147970708681901),
             ("('IILayerGain', '2')", 0.0013053395401501741),
             ("('IECellTypeGain', 'VIP')", 0.001196072679381705),
             ("('EILayerGain', '4')", 0.0011403893414908093),
             ("('IELayerGain', '6')", 0.0010167186924202067),
             ("('EICellTypeGain', 'NGF')", 0.0009049134461898428),
             ("('IELayerGain', '5A')", 0.0008924573619307901),
             ("('IILayerGain', '6')", 0.0008650967598182902)])

** v32_batch9 - tuning scale 1.0, from v32_batch4, with param range -0.75 +0.25
** v32_batch10 - tuning scale 1.0, from v32_batch4, with param range -1.0 +1.0
*** results
**** params order of importance (optuna)
OrderedDict([("('IELayerGain', '5B')", 0.3151041601577254),
             ("('EICellTypeGain', 'SOM')", 0.08400212322088972),
             ("('IELayerGain', '6')", 0.0762918769003323),
             ("('IELayerGain', '4')", 0.0715883186275869),
             ("('IELayerGain', '3')", 0.05313019308373143),
             ("('EELayerGain', '4')", 0.045071353565951815),
             ("('IECellTypeGain', 'SOM')", 0.04465051832626217),
             ("('EILayerGain', '3')", 0.03513225590822564),
             ("('IELayerGain', '5A')", 0.03431980052812068),
             ("('IECellTypeGain', 'NGF')", 0.021889977683634144),
             ("('IILayerGain', '5B')", 0.018055913288555152),
             ("('EELayerGain', '5A')", 0.01603521241493111),
             ("('EILayerGain', '6')", 0.014430459842131458),
             ("('EELayerGain', '6')", 0.013700774868924117),
             ("('EICellTypeGain', 'PV')", 0.012762351035541556),
             ("('IECellTypeGain', 'PV')", 0.01271007860451602),
             ("('EICellTypeGain', 'NGF')", 0.01247971221706121),
             ("('EELayerGain', '3')", 0.011064900976532357),
             ("('IILayerGain', '4')", 0.01050117989864462),
             ("('IILayerGain', '5A')", 0.010040918117366206),
             ("('IILayerGain', '2')", 0.008828854276217579),
             ("('EELayerGain', '5B')", 0.008317352788539763),
             ("('EELayerGain', '2')", 0.00814952977715714),
             ("('EILayerGain', '5A')", 0.007014747634411912),
             ("('IECellTypeGain', 'VIP')", 0.006998916046105591),
             ("('EILayerGain', '1')", 0.006980195516415598),
             ("('EICellTypeGain', 'VIP')", 0.0063617138402887645),
             ("('IILayerGain', '1')", 0.006207601669380438),
             ("('IELayerGain', '2')", 0.005453809051148756),
             ("('IILayerGain', '6')", 0.005322212789753398),
             ("('IILayerGain', '3')", 0.004741085624350056),
             ("('EILayerGain', '4')", 0.004551092697970192),
             ("('EILayerGain', '2')", 0.004396261976505042),
             ("('EILayerGain', '5B')", 0.003714547045091773)])
** v32_batch11 - tuning scale 1.0, only thal+L4, param range 0.1 - 4.0 - CHECK!
** v32_batch12 - run best of v32_batch4, with LFP; with cochlear/IC speech input at 2000ms; with different weights 
** v32_batch13 - tuning from v32_batch11, scale 1.0, only thal+L2+L3+L4, L2+3 param range 0.1-4.0; L4 +-0.1; I->EI +-0.25
*** results
fitness ~90
ITP4, ITS4 ~ 0 Hz
** v32_batch14 - tuning from v32_batch13, scale 1.0, only thal+L2+L3+L4, L2+3+4 +-0.25; I->EI +-0.25
*** results
fitness ~90
**** params order of importance (optuna)
OrderedDict([("('EICellTypeGain', 'PV')", 0.6012994003413611),
             ("('EICellTypeGain', 'VIP')", 0.0674523215057324),
             ("('EICellTypeGain', 'SOM')", 0.05859333642331545),
             ("('EICellTypeGain', 'NGF')", 0.030404890848270017),
             ("('IELayerGain', '3')", 0.026609611733240005),
             ("('IECellTypeGain', 'VIP')", 0.024467396634401412),
             ("('EILayerGain', '3')", 0.023617705813091756),
             ("('EILayerGain', '2')", 0.02139474144951049),
             ("('IILayerGain', '2')", 0.020743683311677006),
             ("('IELayerGain', '2')", 0.017510779139447326),
             ("('IECellTypeGain', 'NGF')", 0.015071640236342313),
             ("('EELayerGain', '4')", 0.013298150090182486),
             ("('IECellTypeGain', 'PV')", 0.01229421034433112),
             ("('EILayerGain', '4')", 0.012034170246579217),
             ("('IELayerGain', '4')", 0.010810362332032402),
             ("('IECellTypeGain', 'SOM')", 0.010511967126289197),
             ("('EELayerGain', '3')", 0.010027132954179493),
             ("('IILayerGain', '3')", 0.008980533541981537),
             ("('IILayerGain', '4')", 0.007605008889729912),
             ("('EELayerGain', '2')", 0.007272957038305588)])
** v32_batch15 - run best of v32_batch4, with LFP; with cochlear/IC speech input at 2000ms; with different conn probs
** v32_batch16 - tuning from v32_batch13, scale 1.0, only thal+L2+L3+L4, param range +-1.0
*** results
fitness ~90

** v32_batch17 - scale 1.0, full model, from v32_batch14 
*** notes
EI params from v32_batch14 trial 981, +-1.0  (by mistaked didnt include here IE params)
thal+L2,L3,L4, IE params from v32_batch14 trial 981, +-0.5
L1, L5A,L5B,L6 - 0.1-4
*** results
no good sols

** v32_batch18 - tuning - best of v32_batch4; thal from v32_batch14; scaled to 100%; grid search of main params
*** notes
EE - [0.25, 0.5, 0.75, 1.0] - 16
EI, IE, II - [0.5, 1.0, 1.5] - 9
E-PV, E-SOM, E-NGF, E-VIP - [0.5, 1.0, 1.5] - 27
total = 16*9*27 = 3888
use thal from v32_batch14
*** results
- only solutions where all pops fire are with EE=1, but they don't fire at same time; different periods; pops inhibit each other
- a few solutions with EE=0, show promising results, with some osc, but some layers (eg L5) and some upper pops (eg SOM) dont fire
- did pop analysis 4D heatmap for all pops and params 
-- hard to extract conclusions
-- but IIGain=1.5 and IEGain=0.5 seems to work best for most pops

DONE:
- calculate fitness value as in evol/optuna, to find good solutions where most pops fire consistently 
- need to recalculate popRates every 250 ms -- info should be obtainable from .pkl files
- found good solutions based on fitness!

TODO:
- explore param space around these solutions using optuna and/or grid search
- if grid search, calculate fitness values directly?
** v32_batch19 - tuning - optuna based on best solutions of v32_batch18; plus added L2+L3-specific IE gains 
*** code
    # from prev - best of 50% cell density
    import json
    with open('data/v32_batch4/trial_15057/trial_15057_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v32_batch14/trial_981/trial_981_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.5
    rangeV2 = 1.0
    minV = 0.1
    maxV = 4.0

    # params based on v32_batch8 grid search best solutions; plus added L2 and L3 IE specific gains since those were problematic layers
    params['EEGain'] = [0.3, 0.7] # [0.25, 0.5, 0.75, 1.0]  # 1 
    params['EIGain'] = [0.3, 1.2] #[0.5, 1.0, 1.5] # 1, 0
    params['IEGain'] = [0.3, 0.7] #[0.5, 1.0, 1.5] # 0
    params['IIGain'] = [0.3, 0.7] #  0
    params[('EICellTypeGain', 'PV')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0, 2 
    params[('EICellTypeGain', 'SOM')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0, 2 once
    params[('EICellTypeGain', 'VIP')] = [0.8, 1.7] #[0.5, 1.0, 1.5] # 1,2
    params[('EICellTypeGain', 'NGF')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0,1,2

    params[('IELayerGain', '2')] = [max(cfgLoad2['IELayerGain']['2']-rangeV, minV), min(cfgLoad['IELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad2['IELayerGain']['3']-rangeV, minV), min(cfgLoad['IELayerGain']['3']+rangeV, maxV)]
*** results
trial_974 good!
** v32_batch20 - scale 1.0; best from v32_batch19; with LFP; cochlear IC/speech input; different conn probs (including 0)
** v32_batch21 - scale 1.0; 11.5-sec; best from v32_batch19; with LFP; cochlear IC/speech input; different conn probs (including 0) and start time
*** code
    # from prev - best of 50% cell density
    import json
    with open('data/v32_batch19/trial_974/trial_974_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v32_batch19/trial_974/trial_974_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    # conn gains - total 3888 param combs
    params[('ICThalInput', 'probE')] = [0.0, 0.12, 0.12, 0.26, 0.26] # 0,1,2
    params[('ICThalInput', 'probI')] = [0.0, 0.12, 0.26, 0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'startTime')] = [2000, 5000, 8000]
    
    groupedParams = [('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 11500
    initCfg['printPopAvgRates'] = [1500, 11500] 
    initCfg['scaleDensity'] = 1.0

    initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
                             'startTime': 2000, 
                             'weightE': 1.0, 
                             'weightI': 1.0, 
                             'probE': 0.12, 
                             'probI': 0.26, 
                             'seed': 1}  

*** results
so this is the full scale 10 sec (1.5-11.5 sec) sim without auditory stimuli (just all pops receving bkg inputs)…
after ~6sec the dynamics seem to change regime: several pops stop firing and others fire a lot and oscillations disappear (showing raster and lfp spec at 4 diff depths)
same with speech stimuli at 2-3sec … the stim seems to move net also to different regime with no osc etc
similar happens if move stim to 5-6sec or 8-9 sec

I was thinking of 1) trying one of the other solutions to see if keeps showing reasonable activity beyond 6 sec; 
and 2) trying lowering IC->Thal weight to see if can get transient response to stimuli that doesn’t mess up dynamics

try following trials:
- 287
- 616
- 1443

- sam for spont (full scale model) use this: v32_batch21_0_0_0.pkl in https://console.cloud.google.com/storage/browser/salvadord_data2/A1/v32_batch21 
(ideally 1.5- 5.5s since after 6s dynamics changed)
- for speech (full scale model) can try: v32_batch21_1_1_0.pkl, v32_batch21_2_2_0.pkl, v32_batch21_3_3_0.pkl, and v32_batch21_4_4_0.pkl; 
stim starts at 2sec (the model response is not transient though, it changes regime and infragranular stop firing); the 4 sims correspond to different IC->Thal conn params
** v32_batch22 - scale 1.0; 11.5-sec; trial 287 from v32_batch19; with LFP; cochlear IC/speech input; different conn probs (including 0), weights and start time
** v32_batch23 - scale 1.0; 11.5-sec; trial 616 from v32_batch19; with LFP; cochlear IC/speech input; different conn probs (including 0), weights and start time
** v32_batch24 - scale 1.0; 11.5-sec; trial 1443 from v32_batch19; with LFP; cochlear IC/speech input; different conn probs (including 0), weights and start time
** v32_batch25 - No cortical conn, just bkg; scale 1.0; 11.5-sec; trial 974 from v32_batch19; with LFP; with and w/o cochlear IC/speech input
*** code
    params[('ICThalInput', 'probE')] = [0.0, 0.12] #, 0.12, 0.26, 0.26] # 0,1,2
    params[('ICThalInput', 'probI')] = [0.0, 0.12] #, 0.26, 0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'weightE')] = [0.0, 0.25]
    params[('ICThalInput', 'weightI')] = [0.0, 0.25]
    params['thalamoCorticalGain'] = [0.0, 1.0]

    groupedParams = [('ICThalInput', 'probE'), ('ICThalInput', 'probI'), ('ICThalInput', 'weightE'), ('ICThalInput', 'weightI'), 'thalamoCorticalGain'] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    ...

    initCfg['EEGain'] = 0.0 #1.0
    initCfg['EIGain'] = 0.0 #1.0 # 1.8600534795309025 	
    initCfg['IEGain'] = 0.0 #1.0 #0.75
    initCfg['IIGain'] = 0.0
    initCfg['thalamoCorticalGain'] = 0.0
** v32_batch26 -  scale 1.0; 11.5-sec; trial 974 from v32_batch19; with LFP; with and w/o cochlear IC/speech input; diff thal->conn gains
*** code
    params[('ICThalInput', 'probE')] = [0.0, 0.12] #, 0.12, 0.26, 0.26] # 0,1,2 (orig: 0.12 - arbirtrary)
    params[('ICThalInput', 'probI')] = [0.0, 0.12] #, 0.26, 0.12, 0.26] # 0,1,2 (orig: 0.26 - arbirtrary)
    params[('ICThalInput', 'weightE')] = [0.0, 0.5] # (orig: 1.0 - arbitrary)
    params[('ICThalInput', 'weightI')] = [0.0, 0.25] # (orig: 1.0 - arbitrary)
    params['thalamoCorticalGain'] = [0.0, 0.25, 0.5, 1.0, 1.5] # (orig: 2.1058298893943608)
*** results
0_0_0_0-2 - no stim, TC gain<1.5 results in narrow large amp osc -- high sync; silent rest 
0_0_0_3 - no stim, TC gain=1.5 results in less overall synchrony

1_1_1_0-2 - stim, TC gain<1.5 no response to stim
1_1_1_3 - stim, TC gain=1.5 transient response to stim
Option 2: full scale model with weaker TC gain (shows less overall sync); spont=v32_batch26_0_0_0_0_3.pkl and v32_batch26_0_0_0_0_4.pkl; speech (starting at 3s)= v32_batch26_1_1_1_1_3.pkl and v32_batch26_1_1_1_1_4.pkl ; data folder: https://console.cloud.google.com/storage/browser/salvadord_data2/A1/v32_batch26 

** v32_batch27 - grid search tune to exp; scale 1.0; 4.5-sec; trial 974 from v32_batch19; with LFP; WITH cochlear IC/speech input; diff thal->conn gains
*** notes
- focus on granular electrode
- calculate wavelet CSD
- focus on freqs < 10 hz
- start stim at 2.5 sec; stim dur = 1sec; allow 1 sec after stim; total = 4.5 sec

Run separately no stim vs speech:
- no stim:
    params['thalamoCorticalGain'] = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
- speech:
    params[('ICThalInput', 'probE')] = [0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'probI')] = [0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'weightE')] = [0.25, 0.5]
    params[('ICThalInput', 'weightI')] = [0.25, 0.5]
    params['thalamoCorticalGain'] = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
** v32_batch28 - grid search tune to exp; scale 1.0; 4.5-sec; trial 974 from v32_batch19; with LFP; WITHOUT IC/speech input; diff thal->conn gains
*** notes
- start stim at 2.5 sec; stim dur = 1sec; allow 1 sec after stim; total = 4.5 sec

    params['thalamoCorticalGain'] = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
** v33_batch1 - same as v32_batch28 after fixing matrix thalamic conn bug
*** notes
while writing paper I just found a bug that made all prob conn from matrix thalamus to cortex be <0.0005 :disappointed: (edited) 
I’m gonna fix and rerun the latest sims, hopefully results don’t change too drastically
*** results
overall similar although some pops slightly off (too high or too low)
** v33_batch2 - tuning; same as v32_batch19 but after fixing matrix thalamic conn bug
*** notes

    # from prev - best of 50% cell density
    import json
    with open('data/v32_batch4/trial_15057/trial_15057_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v32_batch14/trial_981/trial_981_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.5
    rangeV2 = 1.0
    minV = 0.1
    maxV = 4.0

    # params based on v32_batch8 grid search best solutions; plus added L2 and L3 IE specific gains since those were problematic layers
    params['EEGain'] = [0.3, 0.7] # [0.25, 0.5, 0.75, 1.0]  # 1 
    params['EIGain'] = [0.3, 1.2] #[0.5, 1.0, 1.5] # 1, 0
    params['IEGain'] = [0.3, 0.7] #[0.5, 1.0, 1.5] # 0
    params['IIGain'] = [0.3, 0.7] #  0
    params[('EICellTypeGain', 'PV')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0, 2 
    params[('EICellTypeGain', 'SOM')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0, 2 once
    params[('EICellTypeGain', 'VIP')] = [0.8, 1.7] #[0.5, 1.0, 1.5] # 1,2
    params[('EICellTypeGain', 'NGF')] = [0.3, 1.7] #[0.5, 1.0, 1.5] # 0,1,2

    params[('IELayerGain', '2')] = [max(cfgLoad2['IELayerGain']['2']-rangeV, minV), min(cfgLoad['IELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad2['IELayerGain']['3']-rangeV, minV), min(cfgLoad['IELayerGain']['3']+rangeV, maxV)]
*** results
- IT5A, PV6, VIP6 silent; IT3 very low



** v34_batch1 - tuning; same as v32_batch18 after fixing matrix thalamic conn bug + adding cx->IREM,TIM
** v34_batch2 - tuning; from v34_batch1, scale 1.0, only thal+L2+L3+L4, L2+3+4 +-0.25; I->EI +-0.25
** v34_batch3 - tuning; from v34_batch1, scale 1.0, only thal+L2+L3+L4, L2+3 param range 0.1-4.0; L4+-0.1; I->EI +-0.25
** v34_batch4 - tuning; L2-L4; best of v32_batch4; thal from v34_batch3; scaled to 100%; grid search of main params; BUG: only L2-4+thal
*** notes
BUG! - ran only L2-4+thal -- good test to see if can use grid search to find similar/better solutions


- trying same approach that worked before: take best of 50% scale, with thal for 100% scale, and grid search
- note: thal from v34_batch3 doesn't matter which solution as they all use the same thal params; could also use thal from v32_batch14
- however in this case might not work because the 50% scale is different from this 100% qualitatively, 
i.e. fixed 2 matrix thalamic conn bugs (so maybe would have to tune 1st the 50% scale again with the bugs fixed)


EE - [0.25, 0.5, 0.75, 1.0] - 16
EI, IE, II - [0.5, 1.0, 1.5] - 9
E-PV, E-SOM, E-NGF, E-VIP - [0.5, 1.0, 1.5] - 27
total = 16*9*27 = 3888
use thal from v32_batch14

- if doesn't work, can continue tuning by layers -- eg. add L1, L5, L6

- analyzed via batchAnalysis.py
1)  var = [('simData','popRates')]
    params, data = utils.readBatchData(dataFolder, batchLabel, loadAll=loadAll, saveAll=1-loadAll, vars=var, maxCombs=None)

2)
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'TC', 'TCM', 'HTC']  # all layers + thal + IC
    Ipops = [                         # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'IRE', 'IREM', 'TI']  # Thal 

    df = addFitness(dataFolder, batchLabel, loadAll, tranges=[[1500, 1750], [1750,2000], [2000,2250], [2250,2500]], Epops=Epops, Ipops=Ipops)

*** results
great results, better than optuna! at least 2 good solutions with all firing
** v34_batch5 - tuning; full net; best of v32_batch4; thal from v34_batch3; scaled to 100%; grid search of main paramss
*** notes
- trying same approach that worked before: take best of 50% scale, with thal for 100% scale, and grid search
- note: thal from v34_batch3 doesn't matter which solution as they all use the same thal params; could also use thal from v32_batch14
- however in this case might not work because the 50% scale is different from this 100% qualitatively, 
i.e. fixed 2 matrix thalamic conn bugs (so maybe would have to tune 1st the 50% scale again with the bugs fixed)


EE - [0.25, 0.5, 0.75, 1.0] - 16
EI, IE, II - [0.5, 1.0, 1.5] - 9
E-PV, E-SOM, E-NGF, E-VIP - [0.5, 1.0, 1.5] - 27
total = 16*9*27 = 3888 -- actually 8748 
use thal from v32_batch14

- if doesn't work, can continue tuning by layers -- eg. add L1, L5, L6
*** results
best fitness:

In [31]: df.iloc[1520]
Out[31]: 
EEGain                                                                    0.25
EIGain                                                                     1.5
IEGain                                                                     0.5
IIGain                                                                     0.5
['EICellTypeGain', 'PV']                                                   1.5
['EICellTypeGain', 'SOM']                                                  0.5
['EICellTypeGain', 'VIP']                                                  1.5
['EICellTypeGain', 'NGF']                                                  1.5
paramValues                          [0.25, 1.5, 0.5, 0.5, 1.5, 0.5, 1.5, 1.5]
popRates                     {'NGF1': {'1500_1750': 3.5231788079470197, '17...
simLabel                                                      _0_2_0_0_2_0_2_2
fitness                                                                315.461
Name: 1520, dtype: object

best fitness with thal oscillations (searched visually through rasters and then via pandas)
In [30]: df.iloc[2006]
Out[30]: 
EEGain                                                                    0.25
EIGain                                                                     1.5
IEGain                                                                     1.5
IIGain                                                                     0.5
['EICellTypeGain', 'PV']                                                   1.5
['EICellTypeGain', 'SOM']                                                  0.5
['EICellTypeGain', 'VIP']                                                  1.5
['EICellTypeGain', 'NGF']                                                  1.5
paramValues                          [0.25, 1.5, 1.5, 0.5, 1.5, 0.5, 1.5, 1.5]
popRates                     {'NGF1': {'1500_1750': 2.9403973509933774, '17...
simLabel                                                      _0_2_2_0_2_0_2_2
fitness                                                                473.409
Name: 2006, dtype: object


param ranges to explore based on this:
EEGain: [0.1, 0.4]
EIGain: [1.3, 1.7]
IEGain: [0.3, 1.7]
IIGain: [0.3, 0.7]
['EICellTypeGain', 'PV']: [1.3, 1.7]
['EICellTypeGain', 'SOM']: [0.3, 0.7]
['EICellTypeGain', 'VIP']: [1.3, 1.7]
['EICellTypeGain', 'NGF']: [1.3, 1.7]

- include L2,3,4 +- 0.5 from v34_batch4 - check values:
1_2_1_1_0_0_2_2:
EEGain                                                                    0.5 - higher
EIGain                                                                     1.5 - ok
IEGain                                                                     1.0 - ok
IIGain                                                                     1.0 - higher
['EICellTypeGain', 'PV']                                                   0.5 - lower
['EICellTypeGain', 'SOM']                                                  0.5 - ok
['EICellTypeGain', 'VIP']                                                  1.5 - ok 
['EICellTypeGain', 'NGF']                                                  1.5 - ok

include IE l2,3,4,5A,5B:  with [prev-0.5:prev+0.5]]

[before:
Also added IE layer-specific gains for L2 and L3, since these seemed to be the more problematic, and set values based on v32_batch14 (full scale sim with only L2,3,4):
layer-specific IE,II gains for L2,L3, with [prev-0.5:prev+0.5]]

** v34_batch6 - tuning; full net; optuna based on best solutions of v34_batch5; plus added L2-5B specific IE gains since problematic layers
*** notes

- params ranges based on v34_batch5 2 best solutions
- added IE l2,3,4, 5A,5B:  with [prev-0.25:prev+0.25]] since those layers problematic; prev = v34_batch5 


- bug (1st attempt; wrong ranges):
    rangeV = 0.25
    rangeV2 = 1.0
    minV = 0.1
    maxV = 4.0


    # params based on v32_batch8 grid search best solutions; plus added L2 and L3 IE specific gains since those were problematic layers
    params['EEGain'] = [0.1, 0.5] 
    params['EIGain'] = [1.3, 1.7] 
    params['IEGain'] = [0.8, 1.7] 
    params['IIGain'] = [0.3, 0.7] 
    params[('EICellTypeGain', 'PV')] = [0.8, 1.7] 
    params[('EICellTypeGain', 'SOM')] = [0.3, 0.7] 
    params[('EICellTypeGain', 'VIP')] = [1.3, 1.7] 
    params[('EICellTypeGain', 'NGF')] = [1.3, 1.7] 

    params[('IELayerGain', '2')] = [max(cfgLoad2['IELayerGain']['2']-rangeV, minV), min(cfgLoad['IELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad2['IELayerGain']['3']-rangeV, minV), min(cfgLoad['IELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad2['IELayerGain']['4']-rangeV, minV), min(cfgLoad['IELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad2['IELayerGain']['5A']-rangeV, minV), min(cfgLoad['IELayerGain']['5A']+rangeV, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad2['IELayerGain']['5B']-rangeV, minV), min(cfgLoad['IELayerGain']['5B']+rangeV, maxV)]

- After fixing:

    # good thal params for 100% cell density 
    with open('data/v34_batch5/v34_batch5_0_2_0_0_2_0_2_2_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    cfgLoad = cfgLoad2

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.25
    rangeV2 = 1.0
    minV = 0.1
    maxV = 4.0


    # params based on v32_batch8 grid search best solutions; plus added L2 and L3 IE specific gains since those were problematic layers
    params['EEGain'] = [0.1, 0.5] 
    params['EIGain'] = [1.3, 1.7] 
    params['IEGain'] = [0.8, 1.7] 
    params['IIGain'] = [0.3, 0.7] 
    params[('EICellTypeGain', 'PV')] = [0.8, 1.7] 
    params[('EICellTypeGain', 'SOM')] = [0.3, 0.7] 
    params[('EICellTypeGain', 'VIP')] = [1.3, 1.7] 
    params[('EICellTypeGain', 'NGF')] = [1.3, 1.7] 

    params[('IELayerGain', '2')] = [max(cfgLoad2['IELayerGain']['2']-rangeV, minV), min(cfgLoad2['IELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad2['IELayerGain']['3']-rangeV, minV), min(cfgLoad2['IELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad2['IELayerGain']['4']-rangeV, minV), min(cfgLoad2['IELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad2['IELayerGain']['5A']-rangeV, minV), min(cfgLoad2['IELayerGain']['5A']+rangeV, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad2['IELayerGain']['5B']-rangeV, minV), min(cfgLoad2['IELayerGain']['5B']+rangeV, maxV)]

    
*** results
- after 3k iterations, best fitness was ~280
- pretty bad - IT2, IT3 never fire; IT4S and IT4P very very low


** v34_batch7 - tuning; full net; grid search of thal + layer params with best sol from v34_batch5 
*** notes
    with open('data/v32_batch5/v32_batch5_0_2_2_0_2_0_2_2_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v32_batch5/v32_batch5_0_2_2_0_2_0_2_2_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    # conn gains 
    # params['EEGain'] = [0.25, 0.5, 0.75, 1.0]
    # params['EIGain'] = [0.5, 1.0, 1.5]
    # params['IEGain'] = [0.5, 1.0, 1.5]
    # params['IIGain'] = [0.5, 1.0, 1.5]
    # params[('EICellTypeGain', 'PV')] = [0.5, 1.0, 1.5] 
    # params[('EICellTypeGain', 'SOM')] = [0.5, 1.0, 1.5]
    # params[('EICellTypeGain', 'VIP')] = [0.5, 1.0, 1.5] 
    # params[('EICellTypeGain', 'NGF')] = [0.5, 1.0, 1.5]

    flow = 0.5
    fhigh = 1.5

    params[('EILayerGain', '2')] = [cfgLoad['EILayerGain']['2']*flow, cfgLoad['EILayerGain']['2'], cfgLoad['EILayerGain']['2']*fhigh]
    params[('EILayerGain', '3')] = [cfgLoad['EILayerGain']['3']*flow, cfgLoad['EILayerGain']['3'], cfgLoad['EILayerGain']['3']*fhigh]
    params[('EILayerGain', '5A')] = [cfgLoad['EILayerGain']['5A']*flow, cfgLoad['EILayerGain']['5A'], cfgLoad['EILayerGain']['5A']*fhigh]
    params[('EILayerGain', '5B')] = [cfgLoad['EILayerGain']['5B']*flow, cfgLoad['EILayerGain']['5B'], cfgLoad['EILayerGain']['5B']*fhigh]
        
    params[('IECellTypeGain', 'PV')] = [cfgLoad['IECellTypeGain']['PV']*flow, cfgLoad['IECellTypeGain']['PV'], cfgLoad['IECellTypeGain']['PV']*fhigh]
    params[('IECellTypeGain', 'SOM')] = [cfgLoad['IECellTypeGain']['SOM']*flow, cfgLoad['IECellTypeGain']['SOM'], cfgLoad['IECellTypeGain']['SOM']*fhigh]
    params[('IECellTypeGain', 'VIP')] = [cfgLoad['IECellTypeGain']['VIP']*flow, cfgLoad['IECellTypeGain']['VIP'], cfgLoad['IECellTypeGain']['VIP']*fhigh]
    params[('IECellTypeGain', 'NGF')] = [cfgLoad['IECellTypeGain']['NGF']*flow, cfgLoad['IECellTypeGain']['NGF'], cfgLoad['IECellTypeGain']['NGF']*fhigh]

*** results
- >6500 sims, best fitness was 367
- bad - IT2, IT3, ITS4 and ITP4 never fire 
** v34_batch8 - tuning; L2-5A; best of v34_batch4; optuna with large range L5A, small range rest (bug L2,3 EE)
*** notes
- bug: didnt include L5A in fitness; wasn't setting all conn params based on prev sim -- rerun


def optunaRatesLayersThalL2345A():

    # from prev
    import json
    with open('data/v34_batch4/v34_batch4_2_2_2_1_0_0_2_2_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.25
    rangeV2 = 0.1
    minV = 0.1
    maxV = 4.0

    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV, maxV)]

    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV, maxV)]

    # params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV2, minV), min(cfgLoad['EILayerGain']['1']+rangeV, maxV)]
    # params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV2, minV), min(cfgLoad['IILayerGain']['1']+rangeV, maxV)]

    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]

    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]

    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV2, minV), min(cfgLoad['EILayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV2, minV), min(cfgLoad['IELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV2, minV), min(cfgLoad['IILayerGain']['4']+rangeV2, maxV)]

    params[('EELayerGain', '5A')] = [minV, maxV]
    params[('EILayerGain', '5A')] = [minV, maxV]
    params[('IELayerGain', '5A')] = [minV, maxV]
    params[('IILayerGain', '5A')] = [minV, maxV]

*** results
good results (fitness ~40)
IT2 and CT5A a bit low (<0.1hz), and PV2 a bit high (~80hz); but rest good
Note: missed CT5A in fitness func so that may explain why low!
best fitness: trial 2979; best from pandas: trial 4529 

** v34_batch9 - tuning; L2-5B; best of v34_batch8; optuna with large range L5B, small range rest (bug L2,3 EE)
*** notes
    # from prev
    import json
    with open('data/v34_batch8/trial_4529/trial_4529_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.25
    rangeV2 = 0.1
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]
    '''

    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV, maxV)]

    # potentially increase to 0.1-4.0
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV, maxV)]

    # params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV2, minV), min(cfgLoad['EILayerGain']['1']+rangeV, maxV)]
    # params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV2, minV), min(cfgLoad['IILayerGain']['1']+rangeV, maxV)]

    # potentially increase to +-0.25
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]

    # potentially increase to +-0.25
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]

    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV2, minV), min(cfgLoad['EILayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV2, minV), min(cfgLoad['IELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV2, minV), min(cfgLoad['IILayerGain']['4']+rangeV2, maxV)]
    
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV2, minV), min(cfgLoad['EELayerGain']['5A']+rangeV2, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV2, minV), min(cfgLoad['EILayerGain']['5A']+rangeV2, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV2, minV), min(cfgLoad['IELayerGain']['5A']+rangeV2, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV2, minV), min(cfgLoad['IILayerGain']['5A']+rangeV2, maxV)]

    params[('EELayerGain', '5B')] = [minV, maxV]
    params[('EILayerGain', '5B')] = [minV, maxV]
    params[('IELayerGain', '5B')] = [minV, maxV]
    params[('IILayerGain', '5B')] = [minV, maxV]
*** results
- after 2.7k sims, best fitness was 274

** v34_batch10 - v34_batch9 increased IE range to 0.1-4 (bug L2,3 EE)
*** notes
*** results
- fitness ~199 after 10k sims
- SOM2, SOM3, PT5B silent

** v34_batch11 -  tuning; L2-5B; best of v34_batch10; optuna with L2, L3, L5B, EI +-0.25; rest +0.1 (bug L2,3 EE)
*** code


    # from prev
    import json
    with open('data/v34_batch10/trial_11993/trial_11993_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV = 0.25
    rangeV2 = 0.1
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]
    '''

    # 0.25
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV, maxV)]

    # 0.1
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV2, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV2, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV2, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV2, maxV)]

    # params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV2, minV), min(cfgLoad['EILayerGain']['1']+rangeV, maxV)]
    # params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV2, minV), min(cfgLoad['IILayerGain']['1']+rangeV, maxV)]

    # 0.25
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]

    # 0.1
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]

    # 0.1
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV2, minV), min(cfgLoad['EILayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV2, minV), min(cfgLoad['IELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV2, minV), min(cfgLoad['IILayerGain']['4']+rangeV2, maxV)]
    
    # 0.1
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV2, minV), min(cfgLoad['EELayerGain']['5A']+rangeV2, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV2, minV), min(cfgLoad['EILayerGain']['5A']+rangeV2, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV2, minV), min(cfgLoad['IELayerGain']['5A']+rangeV2, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV2, minV), min(cfgLoad['IILayerGain']['5A']+rangeV2, maxV)]

    # 0.25
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']-rangeV, minV), min(cfgLoad['EELayerGain']['5B']+rangeV, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']-rangeV, minV), min(cfgLoad['EILayerGain']['5B']+rangeV, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']-rangeV, minV), min(cfgLoad['IELayerGain']['5B']+rangeV, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']-rangeV, minV), min(cfgLoad['IILayerGain']['5B']+rangeV, maxV)]
*** results
   Trial 0:	 431.94
   Trial 1:	 426.84
   Trial 2:	 426.82
   Trial 22:	 379.88
   Trial 31:	 287.29
   Trial 34:	 261.08
   Trial 106:	 241.04
   Trial 139:	 204.51
   Trial 227:	 202.89
   Trial 228:	 198.81
   Trial 258:	 195.97
   Trial 277:	 188.65
   Trial 324:	 185.17
   Trial 507:	 183.58
   Trial 511:	 167.87
   Trial 513:	 161.50
   Trial 544:	 152.52
   Trial 579:	 146.03
   Trial 1250:	 145.26
   Trial 1782:	 145.13
   Trial 1831:	 145.10
   Trial 2150:	 145.08
   Trial 2175:	 144.82

   Trial 2555 

trial 2175 overall better rates, but still SOM2, SOM3, PT5B = 0Hz

 
** v34_batch12 - tuning; L2-5B; best of v34_batch10; optuna with L2, L3, L5B, EI +-0.25; rest +0.1; E-SOM, SOM-E, and L5B increased range to +-1.0 (bug L2,3 EE)
*** code

    rangeV = 0.25
    rangeV2 = 0.1
    rangeV3 = 1.0
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]
    '''

    # 0.25
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV3, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV3, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV, maxV)]

    # 0.1
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV2, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV3, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV3, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV2, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV2, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV2, maxV)]

    # params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV2, minV), min(cfgLoad['EILayerGain']['1']+rangeV, maxV)]
    # params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV2, minV), min(cfgLoad['IILayerGain']['1']+rangeV, maxV)]

    # 0.25
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV, minV), min(cfgLoad['EELayerGain']['2']+rangeV, maxV)]

    # 0.1
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV, minV), min(cfgLoad['EELayerGain']['3']+rangeV, maxV)]

    # 0.1
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV2, minV), min(cfgLoad['EELayerGain']['4']+rangeV2, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV2, minV), min(cfgLoad['EILayerGain']['4']+rangeV2, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV2, minV), min(cfgLoad['IELayerGain']['4']+rangeV2, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV2, minV), min(cfgLoad['IILayerGain']['4']+rangeV2, maxV)]
    
    # 0.1
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV2, minV), min(cfgLoad['EELayerGain']['5A']+rangeV2, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV2, minV), min(cfgLoad['EILayerGain']['5A']+rangeV2, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV2, minV), min(cfgLoad['IELayerGain']['5A']+rangeV2, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV2, minV), min(cfgLoad['IILayerGain']['5A']+rangeV2, maxV)]

    # 0.25
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']-rangeV3, minV), min(cfgLoad['EELayerGain']['5B']+rangeV3, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']-rangeV3, minV), min(cfgLoad['EILayerGain']['5B']+rangeV3, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']-rangeV3, minV), min(cfgLoad['IELayerGain']['5B']+rangeV3, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']-rangeV3, minV), min(cfgLoad['IILayerGain']['5B']+rangeV3, maxV)]

** v34_batch13 - tuning; L2-5B; best of v34_batch11; optuna with IE, L5B 0.1-4.0; L2, L3, EI +-0.25; rest +-0.1; similar to v32_batch1 (L2-L5B 50% density) (bug L2,3 EE)
*** code
    # from prev
    import json
    with open('data/v34_batch11/trial_2150/trial_2150_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV1 = 0.1
    rangeV2 = 0.25
    rangeV3 = 2.0
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]

    '''

    # 0.25
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV2, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV2, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV2, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV2, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV2, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV2, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV2, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV3, maxV)]

    # 0.1
    params[('IECellTypeGain', 'PV')] = [minV, maxV] # [max(cfgLoad['IECellTypeGain']['PV']-rangeV3, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV3, maxV)]
    params[('IECellTypeGain', 'SOM')] = [minV, maxV] # [max(cfgLoad['IECellTypeGain']['SOM']-rangeV3, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV3, maxV)]
    params[('IECellTypeGain', 'VIP')] = [minV, maxV] # [max(cfgLoad['IECellTypeGain']['VIP']-rangeV3, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV3, maxV)]
    params[('IECellTypeGain', 'NGF')] = [minV, maxV] # [max(cfgLoad['IECellTypeGain']['NGF']-rangeV3, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV3, maxV)]

    # params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV2, minV), min(cfgLoad['EILayerGain']['1']+rangeV, maxV)]
    # params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV2, minV), min(cfgLoad['IILayerGain']['1']+rangeV, maxV)]

    # 0.25
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV2, minV), min(cfgLoad['EELayerGain']['2']+rangeV2, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV2, minV), min(cfgLoad['EELayerGain']['2']+rangeV2, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV2, minV), min(cfgLoad['EELayerGain']['2']+rangeV2, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV2, minV), min(cfgLoad['EELayerGain']['2']+rangeV2, maxV)]

    # 0.1
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV2, minV), min(cfgLoad['EELayerGain']['3']+rangeV2, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV2, minV), min(cfgLoad['EELayerGain']['3']+rangeV2, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV2, minV), min(cfgLoad['EELayerGain']['3']+rangeV2, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV2, minV), min(cfgLoad['EELayerGain']['3']+rangeV2, maxV)]

    # 0.1
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV1, minV), min(cfgLoad['EELayerGain']['4']+rangeV1, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV1, minV), min(cfgLoad['EILayerGain']['4']+rangeV1, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV1, minV), min(cfgLoad['IELayerGain']['4']+rangeV1, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV1, minV), min(cfgLoad['IILayerGain']['4']+rangeV1, maxV)]
    
    # 0.1
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV1, minV), min(cfgLoad['EELayerGain']['5A']+rangeV1, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV1, minV), min(cfgLoad['EILayerGain']['5A']+rangeV1, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV1, minV), min(cfgLoad['IELayerGain']['5A']+rangeV1, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV1, minV), min(cfgLoad['IILayerGain']['5A']+rangeV1, maxV)]

    # 0.25
    params[('EELayerGain', '5B')] = [minV, maxV] #[max(cfgLoad['EELayerGain']['5B']-rangeV2, minV), min(cfgLoad['EELayerGain']['5B']+rangeV2, maxV)]
    params[('EILayerGain', '5B')] = [minV, maxV] # [max(cfgLoad['EILayerGain']['5B']-rangeV2, minV), min(cfgLoad['EILayerGain']['5B']+rangeV2, maxV)]
    params[('IELayerGain', '5B')] = [minV, maxV] #[max(cfgLoad['IELayerGain']['5B']-rangeV2, minV), min(cfgLoad['IELayerGain']['5B']+rangeV2, maxV)]
    params[('IILayerGain', '5B')] = [minV, maxV] #[max(cfgLoad['IILayerGain']['5B']-rangeV2, minV), min(cfgLoad['IILayerGain']['5B']+rangeV2, maxV)]

*** results

** v34_batch14 - tuning; L1-6; best of v34_batch11; optuna with L1,L6 +-0.15; IE,EI +-0.25; rest +-0.1; changed fitness func of I cells to be >0.05Hz (before >0.5) (bug L2,3 EE)
*** code
** v34_batch15 - tuning; L1-6; best of v34_batch14; optuna with all params +-0.2 (bug L2,3 EE)
*** code

    # from prev
    import json
    with open('data/v34_batch14/trial_3782/trial_3782_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV1 = 0.2
    rangeV2 = 0.25
    rangeV3 = 2.0
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]

    '''

    # E->I cell-type-specific
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV1, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV1, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV1, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV1, maxV)]

    # I->E cell-type-specific
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV1, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV1, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV1, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV1, maxV)]

    # L1
    params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV1, minV), min(cfgLoad['EILayerGain']['1']+rangeV1, maxV)]
    params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV1, minV), min(cfgLoad['IILayerGain']['1']+rangeV1, maxV)]

    # L2
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]

    # L3
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]

    # L4
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV1, minV), min(cfgLoad['EELayerGain']['4']+rangeV1, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV1, minV), min(cfgLoad['EILayerGain']['4']+rangeV1, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV1, minV), min(cfgLoad['IELayerGain']['4']+rangeV1, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV1, minV), min(cfgLoad['IILayerGain']['4']+rangeV1, maxV)]
    
    # L5A
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV1, minV), min(cfgLoad['EELayerGain']['5A']+rangeV1, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV1, minV), min(cfgLoad['EILayerGain']['5A']+rangeV1, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV1, minV), min(cfgLoad['IELayerGain']['5A']+rangeV1, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV1, minV), min(cfgLoad['IILayerGain']['5A']+rangeV1, maxV)]

    # L5B
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']-rangeV1, minV), min(cfgLoad['EELayerGain']['5B']+rangeV1, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']-rangeV1, minV), min(cfgLoad['EILayerGain']['5B']+rangeV1, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']-rangeV1, minV), min(cfgLoad['IELayerGain']['5B']+rangeV1, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']-rangeV1, minV), min(cfgLoad['IILayerGain']['5B']+rangeV1, maxV)]

    # L6
    params[('EELayerGain', '6')] = [max(cfgLoad['EELayerGain']['6']-rangeV1, minV), min(cfgLoad['EELayerGain']['6']+rangeV1, maxV)]
    params[('EILayerGain', '6')] = [max(cfgLoad['EILayerGain']['6']-rangeV1, minV), min(cfgLoad['EILayerGain']['6']+rangeV1, maxV)]
    params[('IELayerGain', '6')] = [max(cfgLoad['IELayerGain']['6']-rangeV1, minV), min(cfgLoad['IELayerGain']['6']+rangeV1, maxV)]
    params[('IILayerGain', '6')] = [max(cfgLoad['IILayerGain']['6']-rangeV1, minV), min(cfgLoad['IILayerGain']['6']+rangeV1, maxV)]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 2500
    initCfg['printPopAvgRates'] = [[1500, 1750], [1750, 2000], [2000, 2250], [2250, 2500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','markerSize')] = 10

    initCfg[('analysis','plotRaster','timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    print(initCfg)


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC
    # Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    #Etune = {'target': 5, 'width': 5, 'min': 0.5}
    
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    # Ipops = ['NGF1',                            # L1
    #         'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
    #         'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
    #         'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
    #         'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
    #         'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
    #         'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
    #         'IRE', 'IREM', 'TI']  # Thal 
    Ipops = ['NGF1',  
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A 
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',  # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    #Itune = {'target': 10, 'width': 15, 'min': 0.5}

    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] >= v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'optuna'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'maxFitness': fitnessFuncArgs['maxFitness'],
        'maxiters':     1e6,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      None,    #    Maximum time allowed, in seconds
        'maxiter_wait': 60,
        'time_sleep': 150,
        'popsize': 1  # unused - run with mpi 
    }

    return b

** v34_batch16 - tuning; L1-6; best of v34_batch15; optuna with all params +-0.2 (bug L2,3 EE)
*** code

    # from prev
    import json
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV1 = 0.2
    rangeV2 = 0.25
    rangeV3 = 2.0
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]

    '''

    # E->I cell-type-specific
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV1, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV1, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV1, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV1, maxV)]

    # I->E cell-type-specific
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV1, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV1, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV1, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV1, maxV)]

    # L1
    params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV1, minV), min(cfgLoad['EILayerGain']['1']+rangeV1, maxV)]
    params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV1, minV), min(cfgLoad['IILayerGain']['1']+rangeV1, maxV)]

    # L2
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]

    # L3
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]

    # L4
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV1, minV), min(cfgLoad['EELayerGain']['4']+rangeV1, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV1, minV), min(cfgLoad['EILayerGain']['4']+rangeV1, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV1, minV), min(cfgLoad['IELayerGain']['4']+rangeV1, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV1, minV), min(cfgLoad['IILayerGain']['4']+rangeV1, maxV)]
    
    # L5A
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV1, minV), min(cfgLoad['EELayerGain']['5A']+rangeV1, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV1, minV), min(cfgLoad['EILayerGain']['5A']+rangeV1, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV1, minV), min(cfgLoad['IELayerGain']['5A']+rangeV1, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV1, minV), min(cfgLoad['IILayerGain']['5A']+rangeV1, maxV)]

    # L5B
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']-rangeV1, minV), min(cfgLoad['EELayerGain']['5B']+rangeV1, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']-rangeV1, minV), min(cfgLoad['EILayerGain']['5B']+rangeV1, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']-rangeV1, minV), min(cfgLoad['IELayerGain']['5B']+rangeV1, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']-rangeV1, minV), min(cfgLoad['IILayerGain']['5B']+rangeV1, maxV)]

    # L6
    params[('EELayerGain', '6')] = [max(cfgLoad['EELayerGain']['6']-rangeV1, minV), min(cfgLoad['EELayerGain']['6']+rangeV1, maxV)]
    params[('EILayerGain', '6')] = [max(cfgLoad['EILayerGain']['6']-rangeV1, minV), min(cfgLoad['EILayerGain']['6']+rangeV1, maxV)]
    params[('IELayerGain', '6')] = [max(cfgLoad['IELayerGain']['6']-rangeV1, minV), min(cfgLoad['IELayerGain']['6']+rangeV1, maxV)]
    params[('IILayerGain', '6')] = [max(cfgLoad['IILayerGain']['6']-rangeV1, minV), min(cfgLoad['IILayerGain']['6']+rangeV1, maxV)]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 2500
    initCfg['printPopAvgRates'] = [[1500, 1750], [1750, 2000], [2000, 2250], [2250, 2500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','markerSize')] = 10

    initCfg[('analysis','plotRaster','timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    print(initCfg)


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC
    # Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    #Etune = {'target': 5, 'width': 5, 'min': 0.5}
    
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    # Ipops = ['NGF1',                            # L1
    #         'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
    #         'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
    #         'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
    #         'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
    #         'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
    #         'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
    #         'IRE', 'IREM', 'TI']  # Thal 
    Ipops = ['NGF1',  
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A 
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',  # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    #Itune = {'target': 10, 'width': 15, 'min': 0.5}

    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] >= v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'optuna'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'maxFitness': fitnessFuncArgs['maxFitness'],
        'maxiters':     1e6,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      None,    #    Maximum time allowed, in seconds
        'maxiter_wait': 60,
        'time_sleep': 150,
        'popsize': 1  # unused - run with mpi 
    }

    return b

** v34_batch17 - tuning; L1-6; best of v34_batch15; optuna with all params +-0.2; maxFitness=2000 (bug L2,3EE)
*** code

    # from prev
    import json
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    rangeV1 = 0.2
    rangeV2 = 0.25
    rangeV3 = 2.0
    minV = 0.1
    maxV = 4.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]

    '''

    # E->I cell-type-specific
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['PV']+rangeV1, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['SOM']+rangeV1, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['VIP']+rangeV1, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['EICellTypeGain']['NGF']+rangeV1, maxV)]

    # I->E cell-type-specific
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['PV']+rangeV1, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['SOM']+rangeV1, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['VIP']+rangeV1, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']-rangeV1, minV), min(cfgLoad['IECellTypeGain']['NGF']+rangeV1, maxV)]

    # L1
    params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']-rangeV1, minV), min(cfgLoad['EILayerGain']['1']+rangeV1, maxV)]
    params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']-rangeV1, minV), min(cfgLoad['IILayerGain']['1']+rangeV1, maxV)]

    # L2
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]

    # L3
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]

    # L4
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']-rangeV1, minV), min(cfgLoad['EELayerGain']['4']+rangeV1, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']-rangeV1, minV), min(cfgLoad['EILayerGain']['4']+rangeV1, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']-rangeV1, minV), min(cfgLoad['IELayerGain']['4']+rangeV1, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']-rangeV1, minV), min(cfgLoad['IILayerGain']['4']+rangeV1, maxV)]
    
    # L5A
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']-rangeV1, minV), min(cfgLoad['EELayerGain']['5A']+rangeV1, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']-rangeV1, minV), min(cfgLoad['EILayerGain']['5A']+rangeV1, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']-rangeV1, minV), min(cfgLoad['IELayerGain']['5A']+rangeV1, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']-rangeV1, minV), min(cfgLoad['IILayerGain']['5A']+rangeV1, maxV)]

    # L5B
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']-rangeV1, minV), min(cfgLoad['EELayerGain']['5B']+rangeV1, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']-rangeV1, minV), min(cfgLoad['EILayerGain']['5B']+rangeV1, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']-rangeV1, minV), min(cfgLoad['IELayerGain']['5B']+rangeV1, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']-rangeV1, minV), min(cfgLoad['IILayerGain']['5B']+rangeV1, maxV)]

    # L6
    params[('EELayerGain', '6')] = [max(cfgLoad['EELayerGain']['6']-rangeV1, minV), min(cfgLoad['EELayerGain']['6']+rangeV1, maxV)]
    params[('EILayerGain', '6')] = [max(cfgLoad['EILayerGain']['6']-rangeV1, minV), min(cfgLoad['EILayerGain']['6']+rangeV1, maxV)]
    params[('IELayerGain', '6')] = [max(cfgLoad['IELayerGain']['6']-rangeV1, minV), min(cfgLoad['IELayerGain']['6']+rangeV1, maxV)]
    params[('IILayerGain', '6')] = [max(cfgLoad['IILayerGain']['6']-rangeV1, minV), min(cfgLoad['IILayerGain']['6']+rangeV1, maxV)]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 2500
    initCfg['printPopAvgRates'] = [[1500, 1750], [1750, 2000], [2000, 2250], [2250, 2500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','markerSize')] = 10

    initCfg[('analysis','plotRaster','timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    print(initCfg)


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC
    # Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    #Etune = {'target': 5, 'width': 5, 'min': 0.5}
    
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    # Ipops = ['NGF1',                            # L1
    #         'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
    #         'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
    #         'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
    #         'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
    #         'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
    #         'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
    #         'IRE', 'IREM', 'TI']  # Thal 
    Ipops = ['NGF1',  
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A 
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',  # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    #Itune = {'target': 10, 'width': 15, 'min': 0.5}

    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 2000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] >= v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'optuna'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'maxFitness': fitnessFuncArgs['maxFitness'],
        'maxiters':     1e6,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      None,    #    Maximum time allowed, in seconds
        'maxiter_wait': 60,
        'time_sleep': 150,
        'popsize': 1  # unused - run with mpi 
    }

    return b
** v34_batch18 - tuning; L1-6; best of v34_batch15; optuna with all params +- 25%; maxFitness=2000; maxV=0.5 (bug L2,3 EE)
*** code
   rangeV1 = 0.2
    rangeV2 = 0.25
    rangeV3 = 2.0

    scaleLow = 0.75
    scaleHigh = 1.25

    minV = 0.1
    maxV = 5.0

    ''' potentially:
    layer-specific EE,EI,IE,II gains for L2, with [prev-0.25:prev+0.25]
    layer-specific EE,EI,IE,II gains for L3, with [prev-0.25:prev+025]
    layer-specific EE,EI,IE,II gains for L4, with [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5A, with param range [prev-0.1:prev+0.1]
    layer-specific EE,EI,IE,II gains for L5B, with broad param range [0.1:4.0]
    E-PV, E-SOM, E-NGF, E-VIP (common to all layers) with range [prev-0.25:prev+0.25]
    PV-E, SOM-E, NGF-E, VIP-E (common to all layers) with range [0.1:4.0]

    '''

    # E->I cell-type-specific
    params[('EICellTypeGain', 'PV')] = [max(cfgLoad['EICellTypeGain']['PV']*scaleLow, minV), min(cfgLoad['EICellTypeGain']['PV']*scaleHigh, maxV)]
    params[('EICellTypeGain', 'SOM')] = [max(cfgLoad['EICellTypeGain']['SOM']*scaleLow, minV), min(cfgLoad['EICellTypeGain']['SOM']*scaleHigh, maxV)]
    params[('EICellTypeGain', 'VIP')] = [max(cfgLoad['EICellTypeGain']['VIP']*scaleLow, minV), min(cfgLoad['EICellTypeGain']['VIP']*scaleHigh, maxV)]
    params[('EICellTypeGain', 'NGF')] = [max(cfgLoad['EICellTypeGain']['NGF']*scaleLow, minV), min(cfgLoad['EICellTypeGain']['NGF']*scaleHigh, maxV)]

    # I->E cell-type-specific
    params[('IECellTypeGain', 'PV')] = [max(cfgLoad['IECellTypeGain']['PV']*scaleLow, minV), min(cfgLoad['IECellTypeGain']['PV']*scaleHigh, maxV)]
    params[('IECellTypeGain', 'SOM')] = [max(cfgLoad['IECellTypeGain']['SOM']*scaleLow, minV), min(cfgLoad['IECellTypeGain']['SOM']*scaleHigh, maxV)]
    params[('IECellTypeGain', 'VIP')] = [max(cfgLoad['IECellTypeGain']['VIP']*scaleLow, minV), min(cfgLoad['IECellTypeGain']['VIP']*scaleHigh, maxV)]
    params[('IECellTypeGain', 'NGF')] = [max(cfgLoad['IECellTypeGain']['NGF']*scaleLow, minV), min(cfgLoad['IECellTypeGain']['NGF']*scaleHigh, maxV)]

    # L1
    params[('EILayerGain', '1')] = [max(cfgLoad['EILayerGain']['1']*scaleLow, minV), min(cfgLoad['EILayerGain']['1']*scaleHigh, maxV)]
    params[('IILayerGain', '1')] = [max(cfgLoad['IILayerGain']['1']*scaleLow, minV), min(cfgLoad['IILayerGain']['1']*scaleHigh, maxV)]

    # L2
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']*scaleLow, minV), min(cfgLoad['EELayerGain']['2']*scaleHigh, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']*scaleLow, minV), min(cfgLoad['EELayerGain']['2']*scaleHigh, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']*scaleLow, minV), min(cfgLoad['EELayerGain']['2']*scaleHigh, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']*scaleLow, minV), min(cfgLoad['EELayerGain']['2']*scaleHigh, maxV)]

    # L3
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']*scaleLow, minV), min(cfgLoad['EELayerGain']['3']*scaleHigh, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']*scaleLow, minV), min(cfgLoad['EELayerGain']['3']*scaleHigh, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']*scaleLow, minV), min(cfgLoad['EELayerGain']['3']*scaleHigh, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']*scaleLow, minV), min(cfgLoad['EELayerGain']['3']*scaleHigh, maxV)]

    # L4
    params[('EELayerGain', '4')] = [max(cfgLoad['EELayerGain']['4']*scaleLow, minV), min(cfgLoad['EELayerGain']['4']*scaleHigh, maxV)]
    params[('EILayerGain', '4')] = [max(cfgLoad['EILayerGain']['4']*scaleLow, minV), min(cfgLoad['EILayerGain']['4']*scaleHigh, maxV)]
    params[('IELayerGain', '4')] = [max(cfgLoad['IELayerGain']['4']*scaleLow, minV), min(cfgLoad['IELayerGain']['4']*scaleHigh, maxV)]
    params[('IILayerGain', '4')] = [max(cfgLoad['IILayerGain']['4']*scaleLow, minV), min(cfgLoad['IILayerGain']['4']*scaleHigh, maxV)]
    
    # L5A
    params[('EELayerGain', '5A')] = [max(cfgLoad['EELayerGain']['5A']*scaleLow, minV), min(cfgLoad['EELayerGain']['5A']*scaleHigh, maxV)]
    params[('EILayerGain', '5A')] = [max(cfgLoad['EILayerGain']['5A']*scaleLow, minV), min(cfgLoad['EILayerGain']['5A']*scaleHigh, maxV)]
    params[('IELayerGain', '5A')] = [max(cfgLoad['IELayerGain']['5A']*scaleLow, minV), min(cfgLoad['IELayerGain']['5A']*scaleHigh, maxV)]
    params[('IILayerGain', '5A')] = [max(cfgLoad['IILayerGain']['5A']*scaleLow, minV), min(cfgLoad['IILayerGain']['5A']*scaleHigh, maxV)]

    # L5B
    params[('EELayerGain', '5B')] = [max(cfgLoad['EELayerGain']['5B']*scaleLow, minV), min(cfgLoad['EELayerGain']['5B']*scaleHigh, maxV)]
    params[('EILayerGain', '5B')] = [max(cfgLoad['EILayerGain']['5B']*scaleLow, minV), min(cfgLoad['EILayerGain']['5B']*scaleHigh, maxV)]
    params[('IELayerGain', '5B')] = [max(cfgLoad['IELayerGain']['5B']*scaleLow, minV), min(cfgLoad['IELayerGain']['5B']*scaleHigh, maxV)]
    params[('IILayerGain', '5B')] = [max(cfgLoad['IILayerGain']['5B']*scaleLow, minV), min(cfgLoad['IILayerGain']['5B']*scaleHigh, maxV)]

    # L6
    params[('EELayerGain', '6')] = [max(cfgLoad['EELayerGain']['6']*scaleLow, minV), min(cfgLoad['EELayerGain']['6']*scaleHigh, maxV)]
    params[('EILayerGain', '6')] = [max(cfgLoad['EILayerGain']['6']*scaleLow, minV), min(cfgLoad['EILayerGain']['6']*scaleHigh, maxV)]
    params[('IELayerGain', '6')] = [max(cfgLoad['IELayerGain']['6']*scaleLow, minV), min(cfgLoad['IELayerGain']['6']*scaleHigh, maxV)]
    params[('IILayerGain', '6')] = [max(cfgLoad['IILayerGain']['6']*scaleLow, minV), min(cfgLoad['IILayerGain']['6']*scaleHigh, maxV)]
** v34_batch19 - tuning; L1-6; best of v34_batch15; optuna with all params +- 10%; fixed bug, L2,3 EI, IE, II 0.1-5.0
*** notes
- there was a bug in the last 11 batch sims where L2/3 EI, IE, II params were set around L2/3 EE:

    # L2
    params[('EELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('EILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IELayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]
    params[('IILayerGain', '2')] = [max(cfgLoad['EELayerGain']['2']-rangeV1, minV), min(cfgLoad['EELayerGain']['2']+rangeV1, maxV)]

    # L3
    params[('EELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('EILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IELayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]
    params[('IILayerGain', '3')] = [max(cfgLoad['EELayerGain']['3']-rangeV1, minV), min(cfgLoad['EELayerGain']['3']+rangeV1, maxV)]

- therefore solutions found for L2/3 were not messed up in the following batch and the wrong param ranges were explored

- to fix this, I reran the last batch (v34_batch18) with L2,3 EI, IE, II in range 0.1-5.0
** v34_batch20 - 3 long sims; best from v34_batch15 (trial_5955); 11.5-sec; with LFP; corticothalamicgain +- 25%
*** code
def custom():
    params = specs.ODict()

    # from prev 
    import json
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    # conn gains 
    params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]

    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 11500
    initCfg['printPopAvgRates'] = [1500, 11500] 
    initCfg['scaleDensity'] = 1.0

    # initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
    #                          'startTime': 2000, 
    #                          'weightE': 1.0, 
    #                          'weightI': 1.0, 
    #                          'probE': 0.12, 
    #                          'probI': 0.26, 
    #                          'seed': 1}  

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']

    # changed directly in cfg.py    
    #initCfg[('analysis', 'plotCSD')] = {'spacing_um': 100, 'timeRange': initCfg['printPopAvgRates'], 'LFP_overlay': 1, 'layer_lines': 1, 'saveFig': 1, 'showFig': 0}
    #initCfg['recordLFP'] = [[100, y, 100] for y in range(0, 2000, 100)]

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
    
    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad2[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad2[p]})


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b

 
** v34_batch21 - 3 long sims; best from v34_batch15 (trial_8073); 11.5-sec; with LFP; corticothalamicgain +- 25%
** v34_batch22 - single sim; v34_batch15_trial_5955; reduce IT2/3->PV2/VIP2 weight
*** code
def custom():
    params = specs.ODict()

    # from prev 
    import json
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']

    # good thal params for 100% cell density 
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad2 = json.load(f)['simConfig']

    with open('conn/conn.pkl', 'rb') as fileObj: connData = pickle.load(fileObj)
        wmat = connData['wmat']

    # conn gains 
    #params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]
    params[('wmat', 'IT2', 'PV2')] = [wmat['IT2']['PV2'] * 0.75]
    params[('wmat', 'IT2', 'VIP2')] = [wmat['IT2']['VIP2'] * 0.75]
    params[('wmat', 'IT3', 'PV2')] = [wmat['IT3']['PV2'] * 0.75]
    params[('wmat', 'IT3', 'VIP2')] = [wmat['IT3']['VIP2'] * 0.75]


    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 2500 #11500
    initCfg['printPopAvgRates'] = [1500, 2500] #11500] 
    initCfg['scaleDensity'] = 1.0

    # initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
    #                          'startTime': 2000, 
    #                          'weightE': 1.0, 
    #                          'weightI': 1.0, 
    #                          'probE': 0.12, 
    #                          'probI': 0.26, 
    #                          'seed': 1}  

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']

    # changed directly in cfg.py    
    #initCfg[('analysis', 'plotCSD')] = {'spacing_um': 100, 'timeRange': initCfg['printPopAvgRates'], 'LFP_overlay': 1, 'layer_lines': 1, 'saveFig': 1, 'showFig': 0}
    #initCfg['recordLFP'] = [[100, y, 100] for y in range(0, 2000, 100)]

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
    
    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad2[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad2[p]})


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b
** v34_batch23 - tuning; v34_batch15_trial_5955; optuna with 16 L2 cell-type-specific weight params (targeting PV2, SOM2, VIP2) 
*** code
    # from prev
    import json
    with open('data/v34_batch15/trial_5955/trial_5955_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()


    scaleLow = 0.2
    scaleHigh = 5.0
    
    import pickle
    with open('conn/conn.pkl', 'rb') as fileObj: connData = pickle.load(fileObj)
    wmat = connData['wmat']
    

    weightsScale = [['IT2', 'PV2'],
                    ['IT2', 'SOM2'], 
                    ['IT3', 'PV2'],
                    ['IT3', 'SOM2'],
                    ['PV2', 'PV2'],
                    ['PV2', 'VIP2'],
                    ['PV3', 'PV2'],
                    ['PV3', 'VIP2'],
                    ['SOM2', 'PV2'],
                    ['SOM2', 'VIP2'],
                    ['SOM3', 'PV2'],
                    ['SOM3', 'VIP2'],
                    ['VIP2', 'SOM2'],
                    ['VIP3', 'SOM2']]

    for ws in weightsScale:
        params[('wmat', ws[0], ws[1])] = [wmat[ws[0]][ws[1]] * scaleLow, wmat[ws[0]][ws[1]] * scaleHigh]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 2500
    initCfg['printPopAvgRates'] = [[1500, 1750], [1750, 2000], [2000, 2250], [2250, 2500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','markerSize')] = 10

    initCfg[('analysis','plotRaster','timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [1500, 2500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    print(initCfg)

*** results
good solution: trial_1937
** v34_batch24 - 1 long sims; best from v34_batch23 (trial_1937); 11.5-sec; with LFP
** v34_batch25 - tuning; optuna with 16 L2 cell-type-specific weight params (targeting PV2, SOM2, VIP2) around best sol of v34_batch23 (trial_1937)
** v34_batch26 - 5x5 seeds; best from v34_batch23 (trial_1937); 11.5-sec; with LFP
** v34_batch27 - 5x5 seeds; best from v34_batch25 (trial_2142); 11.5-sec; with LFP

** v34_batch28 - tuning; optuna with 16 L6 cell-type-specific weight params 0.5-2.0 (targeting PV6, SOM6, NGF6) around best sol of v34_batch25 (trial_2142); 2.5 sec
** v34_batch29 - tuning; optuna with 16 L6 cell-type-specific weight params 0.2-4.0 (targeting PV6, SOM6, NGF6) around best sol of v34_batch25 (trial_2142); 2.5 sec
*** code
def optunaRatesLayersWmat():

    # from prev
    import json
    with open('data/v34_batch25/trial_2142/trial_2142_cfg.json', 'rb') as f:
        cfgLoad = json.load(f)['simConfig']


    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    scaleLow = 0.75
    scaleHigh = 1.25

    scaleLow2 = 0.2
    scaleHigh2 = 4.0

    # import pickle
    # with open('conn/conn.pkl', 'rb') as fileObj: connData = pickle.load(fileObj)
    # wmat = connData['wmat']
    wmat = cfgLoad['wmat']    

    weightsScale = [['IT6', 'NGF6'],
                    ['PV6', 'NGF6'],
                    ['SOM6', 'NGF6'],
                    ['VIP6', 'NGF6'],
                    ['NGF6', 'NGF6'],
                    ['IT6', 'SOM6'],
                    ['PV6', 'SOM6'],
                    ['SOM6', 'SOM6'],
                    ['VIP6', 'SOM6'],
                    ['NGF6', 'SOM6'],         
                    ['IT6', 'PV6'],
                    ['PV6', 'PV6'],
                    ['SOM6', 'PV6'],
                    ['VIP6', 'PV6'],
                    ['NGF6', 'PV6']]        
                    

    for ws in weightsScale:
        params[('wmat', ws[0], ws[1])] = [wmat[ws[0]][ws[1]] * scaleLow2, wmat[ws[0]][ws[1]] * scaleHigh2]

** v34_batch30 - tuning; optuna with 16 L6 cell-type-specific weight params 0.2-4.0 (targeting PV6, SOM6, NGF6) around best sol of v34_batch25 (trial_2142); 2.5 sec
*** code
    weightsScale =  [['IT6,' 'PV6'], 
                    ['IT6,' 'SOM6'], 
                    ['IT6,' 'VIP6'], 
                    ['IT6,' 'NGF6'], 
                    ['CT6,' 'PV6'], 
                    ['CT6,' 'SOM6'], 
                    ['CT6,' 'VIP6'], 
                    ['CT6,' 'NGF6'], 
                    ['PV6,' 'IT6'], 
                    ['PV6,' 'CT6'], 
                    ['PV6,' 'PV6'], 
                    ['PV6,' 'SOM6'], 
                    ['PV6,' 'VIP6'], 
                    ['PV6,' 'NGF6'], 
                    ['SOM6,' 'IT6'], 
                    ['SOM6,' 'CT6'], 
                    ['VIP6,' 'PV6'], 
                    ['VIP6,' 'SOM6'], 
                    ['VIP6,' 'VIP6'], 
                    ['VIP6,' 'NGF6'], 
                    ['NGF6,' 'IT6'], 
                    ['NGF6,' 'CT6']]
** v34_batch31 - tuning; same as v34_batch25 but with added L6 weights
*** code

    scaleLow2 = 0.5
    scaleHigh2 = 2.0

    weightsScale = [['IT2', 'PV2'],
                    ['IT2', 'SOM2'], 
                    ['IT3', 'PV2'],
                    ['IT3', 'SOM2'],
                    ['PV2', 'PV2'],
                    ['PV2', 'VIP2'],
                    ['PV3', 'PV2'],
                    ['PV3', 'VIP2'],
                    ['SOM2', 'PV2'],
                    ['SOM2', 'VIP2'],
                    ['SOM3', 'PV2'],
                    ['SOM3', 'VIP2'],
                    ['VIP2', 'SOM2'],
                    ['VIP3', 'SOM2'],
                    ['IT2', 'SOM3'], 
                    ['IT3', 'SOM3'],
                    ['VIP2', 'SOM3'],
                    ['VIP3', 'SOM3'],
                    
                    ['IT6', 'PV6'], 
                    ['IT6', 'SOM6'], 
                    ['IT6', 'VIP6'], 
                    ['IT6', 'NGF6']]

** v34_batch32-48 - long sims of best from v34_batch31
*** notes
    #trials = [5421, 5214, 5383, 3719, 3606, 4005, 3079, 4300]  # 32-39
    trials = [7378, 5692, 7996, 5822, 6172, 7423, 5767, 6226, 6194] # 40-48
** v34_batch49 - 5x5 seeds; best from v34_batch31 (trial_5214); 11.5-sec
** v34_batch50 - explore contribution of pops to LFP as func of dist (for NIH R01 grant with UTH)
*** code
** v34_batch51 - v34_batch31 (trial_5214); all LFP pops at 1 horizontal distance
** v34_batch52 - v34_batch31 (trial_5214); selected LFP pops at 20 horizontal distances
** v34_batch53 - v34_batch31 (trial_5214); record dipole and EEG for first time!
** v34_batch54 - v34_batch25 (trial_2142); testing LFPpops for long 11.5sec sim at 1ms recordStep
*** notes
at 0.1 ms recordStep crashed when gathering
** v34_batch55 - v34_batch25 (trial_2142); 4.5 secs; with LFP; WITH cochlear IC/speech input; diff thal->conn gains
*** code
   params = specs.ODict()

    if not filename:
        filename = 'data/v34_batch25/trial_2142/trial_2142_cfg.json'

    # from prev 
    import json
    with open(filename, 'rb') as f:
        cfgLoad = json.load(f)['simConfig']
    cfgLoad2 = cfgLoad

    params[('ICThalInput', 'probE')] = [0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'probI')] = [0.12, 0.26] # 0,1,2
    params[('ICThalInput', 'weightE')] = [0.25, 0.5]
    params[('ICThalInput', 'weightI')] = [0.25, 0.5]
    params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain'] * x for x in [0.75, 1.0, 1.25, 1.5, 1.75, 2.0]]

    # conn gains 
    #params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']] # [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]
    # params[('seeds', 'conn')] = list(range(1)) #[4321+(17*i) for i in range(5)]
    # params[('seeds', 'stim')] = list(range(1)) #[1234+(17*i) for i in range(5)]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 4500
    initCfg['printPopAvgRates'] = [1500, 4500] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 1

    initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
                             'startTime': 2000, 
                             'weightE': 1.0, 
                             'weightI': 1.0, 
                             'probE': 0.12, 
                             'probI': 0.26, 
                             'seed': 1}  

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotSpikeStats', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotCSD', 'timeRange')] = [1500, 1700]

    initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
                            'startTime': 2500, 
                            'weightE': 1.0, 
                            'weightI': 1.0, 
                            'probE': 0.12, 
                            'probI': 0.26, 
                            'seed': 1}  


** v34_batch56 - 1 long sim; v34_batch25 (trial_2142); with LFP recordStep=0.05 to see if avoid artifact
** v34_batch57 - 5x5 seeds; v34_batch56
** v34_batch58 - explore IC->Thal params with speech; 25 sims (not seeds, different stim/conn params); v34_batch56 with speech
** v34_batch59 - explore TC->IT/PV params with speech
*** code
    params[('wmat', 'TC', 'ITS4')] = [0.5, 0.75, 1.0, 1.25]
    params[('wmat', 'TC', 'ITP4')] = [0.5, 0.75, 1.0, 1.25]
    params[('wmat', 'HTC', 'ITS4')] = [0.5, 0.75, 1.0, 1.25]
    params[('wmat', 'HTC', 'ITP4')] = [0.5, 0.75, 1.0, 1.25]

    params[('wmat', 'TC', 'PV4')] = [0.25, 0.5]
    params[('wmat', 'HTC', 'PV4')] = [0.25, 0.5]


    # conn gains 
    #params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']] # [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]
    # params[('seeds', 'conn')] = list(range(1)) #[4321+(17*i) for i in range(5)]
    # params[('seeds', 'stim')] = list(range(1)) #[1234+(17*i) for i in range(5)]
    
    groupedParams = [('wmat', 'TC', 'ITS4'), ('wmat', 'TC', 'ITP4'), ('wmat', 'HTC', 'IT4'), ('wmat', 'HTC', 'ITS4')] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 4500
    initCfg['printPopAvgRates'] = [1500, 4500] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotSpikeStats', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotCSD', 'timeRange')] = [1500, 1700]

    initCfg['ICThalInput'] = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 
                            'startTime': 2500, 
                            'weightE': 0.25,#1.0, 
                            'weightI': 0.25,#1.0, 
                            'probE': 0.12, 
                            'probI': 0.12, #0.25 
                            'seed': 1}  


** v34_batch60 - 1 long sim (10sec) with LFPpops; v34_batch25 (trial_2142); with LFP recordStep=0.05 to avoid artifact
*** code
cfg.py:
cfg.allCorticalPops = ['NGF1', 'IT2', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'IT3',  'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'SOM4', 'PV4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'SOM5A', 'PV5A', 'VIP5A', 'NGF5A', 'IT5B', 'PT5B', 'CT5B',  'SOM5B', 'PV5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'SOM6', 'PV6', 'VIP6', 'NGF6']
cfg.recordLFP = [[100, y, 100] for y in range(0, 2000, 100)] #+[[100, 2500, 200], [100,2700,200]]
cfg.saveLFPPops =  cfg.allCorticalPops #, "IT3", "SOM3", "PV3", "VIP3", "NGF3", "ITP4", "ITS4", "IT5A", "CT5A", "IT5B", "PT5B", "CT5B", "IT6", "CT6"]
** v34_batch61 - CRASHED - 1 very long sim (30 sec) with LFPpops; v34_batch25 (trial_2142); with LFP recordStep=0.05 to avoid artifact - crashed
*** notes

** v34_batch62 - explore params with speech; 36 sims (TC->L4, start time); v34_batch56 with speech - TO ANALYZE
    params[('wmat', 'TC', 'ITS4')] = [0.7, 0.8]
    params[('wmat', 'TC', 'ITP4')] = [0.7, 0.8]
    params[('wmat', 'HTC', 'ITS4')] = [0.7, 0.8]
    params[('wmat', 'HTC', 'ITP4')] = [0.7, 0.8]

    params[('wmat', 'TC', 'PV4')] = [0.2, 0.3, 0.4, 0.5]
 
    params[('ICThalInput', 'startTime')] = [2500, 2550, 2600, 2650]

    groupedParams = [('wmat', 'TC', 'ITS4'), ('wmat', 'TC', 'ITP4'), ('wmat', 'HTC', 'ITS4'), ('wmat', 'HTC', 'ITP4')] 

** v34_batch63 - CRASHED- 1 very long sim (20 sec) with LFPpops; v34_batch25 (trial_2142); with LFP recordStep=0.05 to avoid artifact - crashed
** v34_batch64 - 1 very long sim (20 sec) withOUT LFPpops; v34_batch25 (trial_2142); with LFP recordStep=0.05 to avoid artifact 
** v34_batch65 - 1 long sim (10 sec) with LFPpops; v34_batch57 seed 3_4 (for wavelets)
*** notes
- BUG saving LFPPops
- had to rerun using:
-- netpyne fix to merge lfppops
-- pip install NEURON-nightly==8.0.dev99
-- highmem nodes
*** code
    params[('seeds', 'conn')] = [3]#, 3, 3] #list(range(1)) #[4321+(17*i) for i in range(5)]
    params[('seeds', 'stim')] = [4]#, 2, 3] #list(range(1)) #[1234+(17*i) for i in range(5)]
    
    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # -------------------------------------------------------- 
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 11500
    initCfg['printPopAvgRates'] = [1500, initCfg['duration']] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05
** v34_batch66 - 1 very long sim (30 sec) withOUT LFPpops; v34_batch25 (trial_2142); with LFP recordStep=0.05 to avoid artifact 
** v34_batch67 - v34_batch65 with seeds 3_2, 3_3 
*** code
    params[('seeds', 'conn')] = [3, 3] #list(range(1)) #[4321+(17*i) for i in range(5)]
    params[('seeds', 'stim')] = [2, 3] #list(range(1)) #[1234+(17*i) for i in range(5)]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 11500
    initCfg['printPopAvgRates'] = [1500, initCfg['duration']] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05
** v34_batch68 - response to netstim to thal E pops with different weights (to reproduce rate + lfp + bold responses)
*** code test
    params = specs.ODict()

    if not filename:
        filename = 'data/v34_batch25/trial_2142/trial_2142_cfg.json'

    # from prev 
    import json
    with open(filename, 'rb') as f:
        cfgLoad = json.load(f)['simConfig']
    cfgLoad2 = cfgLoad

    # conn gains 
    params[('NetStim1', 'weight')] = [1]#, 5, 10, 20, 40] # 50 Hz

    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 6500
    initCfg['printPopAvgRates'] = [1500, initCfg['duration']] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05

    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'pop')] = ['TC', 'TCM', 'HTC']
    initCfg[('NetStim1', 'ynorm')] = [0.0, 3.0]
    initCfg[('NetStim1', 'sec')] = 'soma'
    initCfg[('NetStim1', 'loc')] = 0.5
    initCfg[('NetStim1', 'start')] = 1500
    initCfg[('NetStim1', 'pop')] = 1000.0/50.0, # 50 Hz
    initCfg[('NetStim1', 'noise')] = 0.5, # 50 Hz
    initCfg[('NetStim1', 'number')] = 50 * 10, # enough spikes for 10 seconds


    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotSpikeStats', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotCSD', 'timeRange')] = [1500, 1700]

    # changed directly in cfg.py    
    #initCfg[('analysis', 'plotCSD')] = {'spacing_um': 100, 'timeRange': initCfg['printPopAvgRates'], 'LFP_overlay': 1, 'layer_lines': 1, 'saveFig': 1, 'showFig': 0}
    #initCfg['recordLFP'] = [[100, y, 100] for y in range(0, 2000, 100)]

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
    
    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain', 'wmat']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad2[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad2[p]})


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b




*** code
    params[('NetStim1', 'weight')] = [1, 5, 10, 20] # 50 Hz
    params[('NetStim1', 'interval')] = [1000.0/50.0, 1000.0/100.0] # 50 Hz
    params[('NetStim1', 'noise')] = [0.5, 1.0] # 50 Hz

    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 6000
    initCfg['printPopAvgRates'] = [1500, initCfg['duration']] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05

    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'pop')] = ['TC', 'TCM', 'HTC']
    initCfg[('NetStim1', 'ynorm')] = [0.0, 3.0]
    initCfg[('NetStim1', 'sec')] = 'soma'
    initCfg[('NetStim1', 'loc')] = 0.5
    initCfg[('NetStim1', 'start')] = 3000
    #initCfg[('NetStim1', 'interval')] = 1000.0/50.0 # 50 Hz
    #initCfg[('NetStim1', 'noise')] = 0.5 # 50 Hz
    initCfg[('NetStim1', 'number')] = 100 * 10 # enough spikes for 10 seconds
** v35_batch1 - effect of L5B PT Ih and exc cell K+ conductance (to simulate NA/ACh modulation)  -- BUG (netsim on)
*** notes
left netstim input at the beginning turned on
*** code
def custom_spont(filename):
    params = specs.ODict()

    if not filename:
        filename = 'data/v34_batch25/trial_2142/trial_2142_cfg.json'

    # from prev 
    import json
    with open(filename, 'rb') as f:
        cfgLoad = json.load(f)['simConfig']
    cfgLoad2 = cfgLoad

    
    #params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']] # [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]
    #params[('seeds', 'conn')] = [3, 3] #list(range(1)) #[4321+(17*i) for i in range(5)]
    #params[('seeds', 'stim')] = [2, 3] #list(range(1)) #[1234+(17*i) for i in range(5)]

    params['ihGbar'] = [1.0, 1.25]
    params['KgbarFactor'] = [1.0, 1.25]

    groupedParams = [] #('ICThalInput', 'probE'), ('ICThalInput', 'probI')] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {} # set default options from prev sim
    
    initCfg['duration'] = 11500
    initCfg['printPopAvgRates'] = [1500, initCfg['duration']] 
    initCfg['scaleDensity'] = 1.0
    initCfg['recordStep'] = 0.05

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotSpikeStats', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotCSD', 'timeRange')] = [1500, 1700]

    # changed directly in cfg.py    
    #initCfg[('analysis', 'plotCSD')] = {'spacing_um': 100, 'timeRange': initCfg['printPopAvgRates'], 'LFP_overlay': 1, 'layer_lines': 1, 'saveFig': 1, 'showFig': 0}
    #initCfg['recordLFP'] = [[100, y, 100] for y in range(0, 2000, 100)]

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
    
    # from prev - best of 50% cell density
    updateParams = ['EEGain', 'EIGain', 'IEGain', 'IIGain',
                    ('EICellTypeGain', 'PV'), ('EICellTypeGain', 'SOM'), ('EICellTypeGain', 'VIP'), ('EICellTypeGain', 'NGF'),
                    ('IECellTypeGain', 'PV'), ('IECellTypeGain', 'SOM'), ('IECellTypeGain', 'VIP'), ('IECellTypeGain', 'NGF'),
                    ('EILayerGain', '1'), ('IILayerGain', '1'),
                    ('EELayerGain', '2'), ('EILayerGain', '2'),  ('IELayerGain', '2'), ('IILayerGain', '2'), 
                    ('EELayerGain', '3'), ('EILayerGain', '3'), ('IELayerGain', '3'), ('IILayerGain', '3'), 
                    ('EELayerGain', '4'), ('EILayerGain', '4'), ('IELayerGain', '4'), ('IILayerGain', '4'), 
                    ('EELayerGain', '5A'), ('EILayerGain', '5A'), ('IELayerGain', '5A'), ('IILayerGain', '5A'), 
                    ('EELayerGain', '5B'), ('EILayerGain', '5B'), ('IELayerGain', '5B'), ('IILayerGain', '5B'), 
                    ('EELayerGain', '6'), ('EILayerGain', '6'), ('IELayerGain', '6'), ('IILayerGain', '6')] 

    for p in updateParams:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad[p]})

    # good thal params for 100% cell density 
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain', 'wmat']

    for p in updateParams2:
        if isinstance(p, tuple):
            initCfg.update({p: cfgLoad2[p[0]][p[1]]})
        else:
            initCfg.update({p: cfgLoad2[p]})


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)
    b.method = 'grid'

    return b
** v35_batch2 - effect of L5B PT Ih and exc cell K+ conductance (to simulate NA/ACh modulation) 
*** code
    if not filename:
        filename = 'data/v34_batch25/trial_2142/trial_2142_cfg.json'

    # from prev 
    import json
    with open(filename, 'rb') as f:
        cfgLoad = json.load(f)['simConfig']
    cfgLoad2 = cfgLoad

    
    #params['thalamoCorticalGain'] = [cfgLoad['thalamoCorticalGain']] # [cfgLoad['thalamoCorticalGain']*0.75, cfgLoad['thalamoCorticalGain'], cfgLoad['thalamoCorticalGain']*1.25]
    #params[('seeds', 'conn')] = [3, 3] #list(range(1)) #[4321+(17*i) for i in range(5)]
    #params[('seeds', 'stim')] = [2, 3] #list(range(1)) #[1234+(17*i) for i in range(5)]

    params['ihGbar'] = [0.75, 1.0, 1.25]
    params['KgbarFactor'] = [0.75, 1.0, 1.25]
** blank




