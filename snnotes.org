
* 20mar5 - setting up
** cloned from https://github.com/NathanKlineInstitute/A1

then made a new branch samn off of salva branch
for now, will use samn for development ...

** wav files converted to mat to send to model

data is in data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat
so those are spikes from inferior colliculus

can take a look to see how it looks ...

** make sure using py3env

now setup laptop to use anaconda with neurosim dir structures
so, that py3env uses python 3.6 with anaconda ... 

** compile

nrnivmodl mod

** run

make a myrun script wrapper
that contains
mpiexec -n $1 nrniv -python -mpi init.py

init.py is entry point for network model

which param to scale down so can run on laptop?

sal mentioned:
cfg.scaleDensity — if you set to 0.025 it's ~400 cells, runs in 60 sec

try out a 2 s sim with scale of 0.025 ...

myrun 8

with scale of 1.0 there are 1607 cells on each node ... for 12856 cells total ... too much
for lowly laptop ...

with scale of 0.025, 8 cores, ~43-44 cells per node ...

  Done; run time = 28.73 s; real-time ratio: 0.07.

  Cells: 347
  Connections: 7412 (21.36 per cell)
  Synaptic contacts: 14473 (41.71 per cell)
  Spikes: 1830 (2.64 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.083 Hz
   IT3 : 0.204 Hz
   SOM3 : 50.000 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.167 Hz
   ITS4 : 9.633 Hz
   PV4 : 0.000 Hz
   IT5A : 3.417 Hz
   CT5A : 0.083 Hz
   SOM5A : 38.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.606 Hz
   CT5B : 0.000 Hz
   PT5B : 0.061 Hz
   SOM5B : 34.000 Hz
   PV5B : 0.000 Hz
   IT6 : 2.213 Hz
   CT6 : 0.133 Hz
   SOM6 : 39.333 Hz
   PV6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.373 Hz
  Simulated time: 2.0 s; 8 workers
  Run time: 28.73 s
Saving output as data/v11_manualTune//v11_sim52.json  ...

most cells not firing ...

could run scale of 0.1 for ~1300 cells ...

myrun 8

getting lots of these errors: exp(inf) out of range, returning exp(700)

  Cells: 1313
  Connections: 130037 (99.04 per cell)
  Synaptic contacts: 253484 (193.06 per cell)
  Spikes: 4513 (1.72 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.049 Hz
   SOM3 : 56.381 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.398 Hz
   SOM4 : 62.667 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 37.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.147 Hz
   CT6 : 0.100 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 10.933 Hz
  Simulated time: 2.0 s; 8 workers
  Run time: 359.73 s
Saving output as data/v11_manualTune//v11_sim52.json  ... 
Finished saving!
Done; saving time = 1.06 s.

at this scale, have lots of populations not firing at all as well ...

are there exp(inf) warnings for scale of 1 too?

try 200 ms sim at that scale to see ... (the warnings started before sim reached 100 ms)

myrun 8

yeah, looks like get same errors at scale of 1
exp(inf) out of range, returning exp(700)

takes a while to get network wired, of course ... millions of synapses per node

then crashes eventually with out of memory problem ... when it gets to gather:

Gathering data...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
[samndp7730:13791] *** Process received signal ***
[samndp7730:13791] Signal: Aborted (6)
[samndp7730:13791] Signal code:  (-6)

* 20mar6 - testing/tuning manually
** reading code/testing/tuning smaller version of model

in the 0.1 scaledensity simulation, the IC cells are firing ~8 Hz when providing
the auditory input signal ... but the TC cells are not firing at all

SOM cells fire too much, most other populations do not fire too much

myrun 12

  Cells: 1313
  Connections: 130037 (99.04 per cell)
  Synaptic contacts: 253484 (193.06 per cell)
  Spikes: 4526 (1.72 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.049 Hz
   SOM3 : 56.381 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.398 Hz
   SOM4 : 62.667 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 37.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.147 Hz
   CT6 : 0.100 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.107 Hz
  Simulated time: 2.0 s; 12 workers
  Run time: 327.72 s
  Saving output as data/20mar6//20mar6_A0.pkl ...

so, where is connection from IC -> THAL ?   

in cfg.py have this:
cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 'startTime': 500}  # parameters to generate realistic cochlear + IC input

and in netParams.py have this:
if cfg.ICThalInput:
which loads spikes from file and then creates VecStims like this:
netParams.popParams['IC'] = {'cellModel': 'VecStim', 'numCells': numCells, 'ynormRange': layer['cochlear'],'spkTimes': spkTimes}
but, do not see the weight set ...aha, it's set below as
    # connect cochlear + IC thalamic inputs
    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalE'],
            'weight': cfg.weightInput['ThalE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalI'], 
            'weight': cfg.weightInput['ThalI'],
            'synMechWeightFactor': cfg.synWeightFractionEI,
            'delay': cfg.delayBkg}  

so, to increase weight of those IC inputs just increase cfg.weightInput['ThalE'] and/or cfg.weightInput['ThalI']

try that out . . .

even if that works should have some activity throughout the network in the absence of auditory inputs

hmm, still have 0 TC rates:
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.440 Hz

   did not seem to impact TC rates ... or activity

data/20mar6/20mar6_A0_traces_gid_1204.png   
data/20mar6/20mar6_A0_traces_gid_1215.png
data/20mar6/20mar6_A0_traces_gid_1230.png
data/20mar6/20mar6_A0_traces_gid_1233.png
data/20mar6/20mar6_A0_traces_gid_1248.png
data/20mar6/20mar6_A0_traces_gid_1263.png
raster: data/20mar6/20mar6_A0_raster.png

probably because no inputs at all ??
cfg.probInput = {'ThalE': 0.0, 'ThalI': 0.0} # {'ThalE': 0.25, 'ThalI': 0.25}  # probability of conn

so need to set that to a positive value ...

ok, put those weights back to 0.5 and put the probabilities at 0.25 ... see how it looks

myrun 12

ok, looks a lot different now, though still a lot of types not firing at all:

  Cells: 1313
  Connections: 130736 (99.57 per cell)
  Synaptic contacts: 254882 (194.12 per cell)
  Spikes: 5384 (2.05 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.054 Hz
   SOM3 : 57.429 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.655 Hz
   SOM4 : 64.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.833 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.142 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 39.394 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.260 Hz
   CT6 : 0.113 Hz
   SOM6 : 34.556 Hz
   PV6 : 0.083 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 10.727 Hz
   TCM : 11.156 Hz
   HTC : 8.222 Hz
   IRE : 6.089 Hz
   IREM : 4.800 Hz
   IC : 11.573 Hz
  Simulated time: 2.0 s; 12 workers
  Run time: 353.24 s

data/20mar6/20mar6_A0_traces_gid_1204.png   
data/20mar6/20mar6_A0_traces_gid_1215.png
data/20mar6/20mar6_A0_traces_gid_1230.png
data/20mar6/20mar6_A0_traces_gid_1233.png
data/20mar6/20mar6_A0_traces_gid_1248.png
data/20mar6/20mar6_A0_traces_gid_1263.png
raster: data/20mar6/20mar6_A0_raster.png

seems like SOM cells overactive in every layer ... that's probably leading to suppression of everything else ...

try turning down I -> E gain ... and I -> I gain ... and EIGain (in cfg.py)

cfg.EEGain = 1.0 
cfg.EIGain = 0.75 # 1.0 #0.75
cfg.IEGain = 0.75 # 1.0 #0.75
cfg.IIGain = 0.75 # 1.0 #0.5

cfg.simLabel = '20mar6_A1'

myrun 12

data/20mar6/20mar6_A1_traces_gid_1204.png   
data/20mar6/20mar6_A1_traces_gid_1215.png
data/20mar6/20mar6_A1_traces_gid_1230.png
data/20mar6/20mar6_A1_traces_gid_1233.png
data/20mar6/20mar6_A1_traces_gid_1248.png
data/20mar6/20mar6_A1_traces_gid_1263.png
raster: data/20mar6/20mar6_A1_raster.png

did not make much difference...

SOM still dominating ...

  Cells: 1313
  Connections: 130736 (99.57 per cell)
  Synaptic contacts: 254882 (194.12 per cell)
  Spikes: 5849 (2.23 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.020 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.139 Hz
   SOM3 : 60.952 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.185 Hz
   ITS4 : 5.390 Hz
   SOM4 : 65.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.438 Hz
   CT5A : 0.000 Hz
   SOM5A : 34.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 41.455 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.073 Hz
   CT6 : 0.147 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 8.364 Hz
   TCM : 10.711 Hz
   HTC : 9.111 Hz
   IRE : 5.956 Hz
   IREM : 4.800 Hz
   IC : 11.160 Hz

test with IEGain of 0 to see if E cells activate without the inhib inputs ...

cfg.simLabel = '20mar6_A2'
cfg.IEGain = 0.0 # 0.75 # 1.0 #0.75

myrun 12

data/20mar6/20mar6_A2_traces_gid_1204.png   
data/20mar6/20mar6_A2_traces_gid_1215.png
data/20mar6/20mar6_A2_traces_gid_1230.png
data/20mar6/20mar6_A2_traces_gid_1233.png
data/20mar6/20mar6_A2_traces_gid_1248.png
data/20mar6/20mar6_A2_traces_gid_1263.png
raster: data/20mar6/20mar6_A2_raster.png

well, it has some impact but E populations are mostly silent ...

  Spikes: 14203 (5.41 Hz)
   NGF1 : 0.000 Hz
   IT2 : 10.222 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.555 Hz
   SOM3 : 105.333 Hz
   PV3 : 41.882 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.000 Hz
   ITS4 : 17.839 Hz
   SOM4 : 96.667 Hz
   PV4 : 19.704 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 44.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 1.830 Hz
   SOM5B : 54.485 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 3.627 Hz
   CT6 : 0.280 Hz
   SOM6 : 36.333 Hz
   PV6 : 7.750 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 7.455 Hz
   TCM : 8.889 Hz
   HTC : 3.333 Hz
   IRE : 6.756 Hz
   IREM : 5.956 Hz
   IC : 10.640 Hz

and try another with cortical connectivity turned off ... (may need to adjust the noise inputs)
cfg.simLabel = '20mar6_A3'   
cfg.addConn = 0   

myrun 12

  Spikes: 6048 (2.30 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.020 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.081 Hz
   SOM3 : 38.190 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.120 Hz
   ITS4 : 10.048 Hz
   SOM4 : 42.333 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 3.048 Hz
   CT5A : 0.133 Hz
   SOM5A : 35.833 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.922 Hz
   CT5B : 0.099 Hz
   PT5B : 0.071 Hz
   SOM5B : 41.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.733 Hz
   CT6 : 0.120 Hz
   SOM6 : 33.333 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 8.970 Hz
   TCM : 8.622 Hz
   HTC : 5.111 Hz
   IRE : 6.133 Hz
   IREM : 5.911 Hz
   IC : 10.853 Hz

data/20mar6/20mar6_A3_traces_gid_1204.png   
data/20mar6/20mar6_A3_traces_gid_1215.png
data/20mar6/20mar6_A3_traces_gid_1230.png
data/20mar6/20mar6_A3_traces_gid_1233.png
data/20mar6/20mar6_A3_traces_gid_1248.png
data/20mar6/20mar6_A3_traces_gid_1263.png
raster: data/20mar6/20mar6_A3_raster.png
   
ok, SOM still firing but not much from the other types ... can adjust noise inputs first;
to aim for ~1 Hz firing of all types ... ? or perhaps only E types ... 

* 20oct22 - back to model
** back to model -- git merge samn with salva so have latest

cloned onto cycle

git clone git@github.com:NathanKlineInstitute/A1.git
cd A1
git branch
git pull origin salva
git branch
git checkout samn
git merge origin/salva
Auto-merging netParams.py
CONFLICT (content): Merge conflict in netParams.py
Auto-merging cfg.py
CONFLICT (content): Merge conflict in cfg.py
Automatic merge failed; fix conflicts and then commit the result.
git add netParams.py cfg.py
git commit -m 'merge'
git push origin samn
git mv snnotes.dol snnotes.org
git commit -m 'to org'
git push origin samn

** homeostatic synapses to regulate/tune firing rates

can either do via hsyn.mod or in py with periodic callbacks - similar to smartagent weight normalizations

http://www.netpyne.org/reference.html?highlight=hsyn

** old NetPyNE slack discussion on using hsyn.mod in NetPyNE (from 5/4/20)

Haroon Anwar It appears that homeostatic synaptic plasticity is associated with the synaptic
mechanism (and therefore should be set/declared in netParams.synMechParams) instead of synaptic
connection (as in case of STDP rule). I see the following lines on NetPyNe website but it is not
clear to me how to use this option: selfNetCon (optional) - dictionary with the parameters of a
NetCon between the cell voltage and the synapse, required by some synaptic mechanisms such as the
homeostatic synapse (hsyn). e.g. 'selfNetCon': {'sec': 'soma' , 'threshold': -15, 'weight': -1,
'delay': 0}
salvadord think we had an example with homeostatic syns — did you find that? otherwise I’ll look for it after lunch
Haroon Anwar no i didn’t find. If you can look for it, would be great help.
salvadord not finding the example… what was the name of the mod file for homeostatic syns?
samn:speech_balloon: hsyn.mod
salvadord thx
salvadord haroon, found this in sam’s netpyne version of m1 model from ~2017 … maybe try
something similar and let me know if works: netParams.synMechParams['AMPA'] =
{'mod':'hsyn','tau1':0.05,'tau2':5.3,'e':0,'scaling':1,'targetrate':5,'scalefactor':1.0,'scaleratefctr':scaleratefctr,
'selfNetCon': {'threshold': -15, 'weight': -1, 'delay': 0}}
Haroon Anwar ok
let me try
Haroon Anwar salva, can you please send me the link to this m1 model?
salvadord this version is in /u/samn/m1np
Haroon Anwar thanks

** test net

using a scaled down version for testing
cfg.scaledensity=0.1

for plotting, do not call matplotlib.use('Agg') on cycle ... just on server (gcp)

./myrun 30

** replace AMPA with hsyn 

will need diff AMPA mech for E and I neurons ...

netParams.synMechParams['AMPA'] = {'mod':'hsyn','tau1':0.05,'tau2':5.3,'e':0,'scaling':1,'targetrate':5,'scalefactor':1.0,'scaleratefctr':scaleratefctr,
'selfNetCon': {'threshold': -15, 'weight': -1, 'delay': 0}}

ok, adjusting to have option whether to use the homeostatic scaling ... ideally would want to have param
for different target rates for each population ... will add that in if/when basic mechanism is working

* 23aug2
** sz modeling

EG had szdelta branch, pull from there and merge with samn

git pull origin szdelta

From github.com:NathanKlineInstitute/A1
 * branch            szdelta    -> FETCH_HEAD
Auto-merging netParams.py
CONFLICT (content): Merge conflict in netParams.py
Auto-merging init.py
CONFLICT (content): Merge conflict in init.py
Auto-merging cfg.py
CONFLICT (content): Merge conflict in cfg.py
Automatic merge failed; fix conflicts and then commit the result.

ok, fixed/updated those files and commited ... will stick with samn branch moving forward

* 23aug3
** test run

nrnivmodl mod

./myrun 30

  Cells: 1273
  Connections: 0 (0.00 per cell)
  Spikes: 112493 (8.84 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 205.01 s
   NGF1 : 3.421 Hz
   IT2 : 4.434 Hz
   PV2 : 132.900 Hz
   VIP2 : 15.700 Hz
   NGF2 : 13.400 Hz
   IT3 : 3.694 Hz
   SOM3 : 22.914 Hz
   PV3 : 27.712 Hz
   VIP3 : 19.390 Hz
   NGF3 : 6.540 Hz
   ITP4 : 7.131 Hz
   ITS4 : 5.891 Hz
   SOM4 : 14.650 Hz
   PV4 : 21.100 Hz
   VIP4 : 29.400 Hz
   NGF4 : 7.700 Hz
   IT5A : 2.309 Hz
   CT5A : 1.300 Hz
   SOM5A : 22.200 Hz
   PV5A : 41.467 Hz
   VIP5A : 62.700 Hz
   IT5B : 6.496 Hz
   CT5B : 0.373 Hz
   PT5B : 0.615 Hz
   SOM5B : 48.440 Hz
   PV5B : 32.569 Hz
   VIP5B : 7.000 Hz
   NGF5B : 5.300 Hz
   IT6 : 15.431 Hz
   CT6 : 12.926 Hz
   SOM6 : 60.150 Hz
   PV6 : 37.138 Hz
   NGF6 : 94.100 Hz
   TC : 41.000 Hz
   TCM : 39.147 Hz
   HTC : 57.750 Hz
   IRE : 4.027 Hz
   IREM : 3.107 Hz
   TI : 18.380 Hz
   TIM : 18.300 Hz
Saving output as data/23aug3_A0/23aug3_A0_data.pkl ... 
Finished saving!
  Done; saving time = 2.56 s.

pretty fast runtime ... a little over 3 minutes for 10 s of simulation ...

but this was at 10% density:
cfg.scaleDensity # 0.1

ok, much slower with 100% density ... (on cycle with 30 cores)

  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 273942 (2.12 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 7604.76 s
   NGF1 : 1.752 Hz
   IT2 : 0.484 Hz
   SOM2 : 32.900 Hz
   PV2 : 12.138 Hz
   VIP2 : 24.233 Hz
   NGF2 : 10.791 Hz
   IT3 : 0.209 Hz
   SOM3 : 1.147 Hz
   PV3 : 9.172 Hz
   VIP3 : 20.003 Hz
   NGF3 : 5.747 Hz
   ITP4 : 0.495 Hz
   ITS4 : 0.475 Hz
   SOM4 : 1.639 Hz
   PV4 : 5.221 Hz
   VIP4 : 15.131 Hz
   NGF4 : 8.023 Hz
   IT5A : 2.140 Hz
   CT5A : 0.779 Hz
   SOM5A : 3.250 Hz
   PV5A : 4.764 Hz
   VIP5A : 18.070 Hz
   NGF5A : 14.550 Hz
   IT5B : 4.446 Hz
   CT5B : 0.242 Hz
   PT5B : 0.196 Hz
   SOM5B : 13.161 Hz
   PV5B : 2.560 Hz
   VIP5B : 13.600 Hz
   NGF5B : 15.643 Hz
   IT6 : 1.339 Hz
   CT6 : 0.892 Hz
   SOM6 : 47.630 Hz
   PV6 : 0.363 Hz
   VIP6 : 8.275 Hz
   NGF6 : 81.697 Hz
   TC : 4.940 Hz
   TCM : 5.097 Hz
   HTC : 4.384 Hz
   IRE : 2.783 Hz
   IREM : 3.198 Hz
   TI : 1.976 Hz
   TIM : 3.241 Hz

will setup simdat.py for easier load/analysis of sim data ... 

* 23aug5
** info from eg

Hi all, 

Hope you are doing well! I made a summary of those latest results as requested. 

Here is a google drive directory with data files, summary documents, and slides:  https://drive.google.com/drive/folders/16XWvAeeessXokFPRn3B7PBM7zKy-qdko?usp=sharing 

The Summary_BBN google slides doc shows the figures, and the notes section of each slide shows how to reproduce those figures. 

Data files and more detailed summaries are located in each of the two main subdirectories of that google drive folder (they are called model_vs_NHP and NMDA). Each of those subdirs has a summary document that details the steps I took. 

Let me know if there are any permissions issues or any issues reproducing the figs.

* 23aug7
** continue
* 23aug10
** continue test on edge

with 30 cores: 
  Done; run time = 4884.62 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 50.09 s.

Analyzing...
  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 235909 (1.83 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 4884.62 s
   NGF1 : 1.697 Hz
   IT2 : 0.261 Hz
   SOM2 : 16.040 Hz
   PV2 : 8.469 Hz
   VIP2 : 24.775 Hz
   NGF2 : 8.727 Hz
   IT3 : 0.156 Hz
   SOM3 : 0.843 Hz
   PV3 : 4.789 Hz
   VIP3 : 15.738 Hz
   NGF3 : 4.935 Hz
   ITP4 : 0.287 Hz
   ITS4 : 0.287 Hz
   SOM4 : 0.946 Hz
   PV4 : 2.958 Hz
   VIP4 : 12.131 Hz
   NGF4 : 6.050 Hz
   IT5A : 1.557 Hz
   CT5A : 0.464 Hz
   SOM5A : 2.291 Hz
   PV5A : 1.893 Hz
   VIP5A : 8.710 Hz
   NGF5A : 10.750 Hz
   IT5B : 3.406 Hz
   CT5B : 0.133 Hz
   PT5B : 0.130 Hz
   SOM5B : 11.856 Hz
   PV5B : 0.940 Hz
   VIP5B : 7.076 Hz
   NGF5B : 9.617 Hz
   IT6 : 0.678 Hz
   CT6 : 0.532 Hz
   SOM6 : 22.943 Hz
   PV6 : 44.274 Hz
   VIP6 : 52.917 Hz
   NGF6 : 45.032 Hz
   TC : 4.501 Hz
   TCM : 4.436 Hz
   HTC : 4.087 Hz
   IRE : 2.546 Hz
   IREM : 3.082 Hz
   TI : 1.800 Hz
   TIM : 3.067 Hz

hmm, number of spikes is much different compared to the run on cycle ... 
also does not finish saving data 

  Saving output as: 23aug3_B0_node_8.pkl ... 
  Done; saving time = 3.65 s.

Searching for .pkl node files in data/23aug3_B0/23aug3_B0_node_data ...

Gathering data from files for simulation: 23aug3_B0 ...
  Merging data file: 23aug3_B0_node_0.pkl
Traceback (most recent call last):
  File "init.py", line 48, in <module>
    sim.gatherDataFromFiles()
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in gatherDataFromFiles
    allCells.extend([cell.__getstate__() for cell in data['cells']])
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in <listcomp>
    allCells.extend([cell.__getstate__() for cell in data['cells']])
AttributeError: 'dict' object has no attribute '__getstate__'
bash: /opt/miniconda3/envs/py376/lib/libtinfo.so.6: no version information available (required by bash)

(py376) samn@edge:~/A1$ python
Python 3.7.6 (default, Jan  8 2020, 19:59:22) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import neuron
>>> neuron.__version__
'8.2.2'
>>> import netpyne
>>> netpyne.__version__
'1.0.4.2'
>>> 

and on cycle:
(base) samn@cycle:~/accumnavnet$ python
Python 3.7.6 (default, Jan  8 2020, 19:59:22) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import netpyne
>>> netpyne.__version__
'1.0.2.1'
>>> import neuron
>>> neuron.__version__
'8.0.2'
>>> 

so, older versions of both on cycle ... 

can also try on edge w/o the gatherdatafromfiles ... 

had an extra call to gatherdata ... will try again w/o it...

and try with 60 cores ... see if that speeds up (took ~180 minutes with 30 cores on edge)

./myrun 60

  Done; run time = 4239.55 s; real-time ratio: 0.00.

took ~70 minutes ...

Saving an output file for each node in: data/23aug10_A0/23aug10_A0_node_data
Searching for .pkl node files in data/23aug10_A0/23aug10_A0_node_data ...

Gathering data from files for simulation: 23aug10_A0 ...
  Merging data file: 23aug10_A0_node_0.pkl
Traceback (most recent call last):
  File "init.py", line 48, in <module>
    sim.gatherDataFromFiles()
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in gatherDataFromFiles
    allCells.extend([cell.__getstate__() for cell in data['cells']])
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in <listcomp>
    allCells.extend([cell.__getstate__() for cell in data['cells']])
AttributeError: 'dict' object has no attribute '__getstate__'

so, get the same error as before ...

will install versions used on cycle

pip uninstall neuron
pip uninstall netpyne

pip install neuron==8.0.2
pip install netpyne==1.0.2.1

ok, try that again ...

./myrun 48

  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 205839 (1.59 Hz)
  Simulated time: 10.0 s; 48 workers
  Run time: 3904.57 s
   NGF1 : 1.673 Hz
   IT2 : 0.193 Hz
   SOM2 : 12.540 Hz
   PV2 : 4.015 Hz
   VIP2 : 23.019 Hz
   NGF2 : 7.960 Hz
   IT3 : 0.141 Hz
   SOM3 : 0.858 Hz
   PV3 : 2.888 Hz
   VIP3 : 11.005 Hz
   NGF3 : 4.669 Hz
   ITP4 : 0.189 Hz
   ITS4 : 0.204 Hz
   SOM4 : 0.804 Hz
   PV4 : 1.532 Hz
   VIP4 : 7.777 Hz
   NGF4 : 4.979 Hz
   IT5A : 1.247 Hz
   CT5A : 0.242 Hz
   SOM5A : 2.129 Hz
   PV5A : 0.571 Hz
   VIP5A : 3.378 Hz
   NGF5A : 6.300 Hz
   IT5B : 2.579 Hz
   CT5B : 0.063 Hz
   PT5B : 0.082 Hz
   SOM5B : 12.238 Hz
   PV5B : 0.248 Hz
   VIP5B : 1.731 Hz
   NGF5B : 5.279 Hz
   IT6 : 0.540 Hz
   CT6 : 0.340 Hz
   SOM6 : 12.087 Hz
   PV6 : 66.013 Hz
   VIP6 : 68.082 Hz
   NGF6 : 31.905 Hz
   TC : 4.322 Hz
   TCM : 4.186 Hz
   HTC : 4.057 Hz
   IRE : 2.533 Hz
   IREM : 2.982 Hz
   TI : 1.858 Hz
   TIM : 3.162 Hz
Saving output as data/23aug10_A0/23aug10_A0_data.pkl ... 
Finished saving!
  Done; saving time = 30.59 s.

ok, ran to completion ... and took ~65 minutes with 48 cores

** neuron/netpyne version used in A1 paper: neuron==7.8.2 and netpyne==1.0.2.1
* 23aug14
** check output from 23aug10_A0_

python -i simdat.py

loading data from 23aug10_A0
Traceback (most recent call last):
  File "simdat.py", line 132, in <module>
    simConfig, dstartidx, dendidx, dnumc, dspkID, dspkT = loadsimdat(name,lpop=[])
  File "simdat.py", line 28, in loadsimdat
    if simConfig['net']['pops'][p]['tags']['numCells'] > 0:
KeyError: 'tags'

no 'tags' used here

name = '23aug10_A0'
simConfig = pickle.load(open('data/'+name+'/'+name+'_data.pkl','rb'))
simConfig['net']['pops'].keys()
odict_keys(['NGF1', 'IT2', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'IT3', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'SOM4', 'PV4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'SOM5A', 'PV5A', 'VIP5A', 'NGF5A', 'IT5B', 'CT5B', 'PT5B', 'SOM5B', 'PV5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'SOM6', 'PV6', 'VIP6', 'NGF6', 'TC', 'TCM', 'HTC', 'IRE', 'IREM', 'TI', 'TIM'])
simConfig['net']['pops']['NGF1'].keys() # odict_keys(['cellType', 'cellModel', 'ynormRange', 'density', 'pop', 'numCells', 'cellGids'])
simConfig['net']['pops']['NGF1']['numCells'] # 151

python -i simdat.py

** updated code from repro branch

this was the branch eg used for BBN, ERP, NMDA adjustment figures

most of the changes were in analysis subfolder

** next runs -- BBN
* 23aug15
** check LFP presence

python -i simdat.py

savefig('gif/23aug15_rast_a0.png') # [[./gif/23aug15_rast_a0.png]]

xlim((9e3,10e3))

savefig('gif/23aug15_rast_a0b.png') # [[./gif/23aug15_rast_a0b.png]]

some rhythmicity there in thalamic populations, have to check if providing auditory stim

len(simConfig['simData']['LFP']) # 100000

clf()

plot(simConfig['simData']['t'],simConfig['simData']['LFP'])

savefig('gif/23aug15_LFP_a1.png') # [[./gif/23aug15_LFP_a1.png]]

strange transition at the end

xlim((2e3,3e3)); ylim((-1.1,.65))

savefig('gif/23aug15_LFP_a2.png') # [[./gif/23aug15_LFP_a2.png]]

some useful plotting routines already in analysis subfolder (some of it is from OEvent code)

from analysis.simDataAnalysis import *

** setting up rhythmic BBN input
* 23aug23
** how to run BBN

check here
https://github.com/NathanKlineInstitute/A1/commit/c4011870a4c1617ca8b4d056dbed494e3e18f706

uses batch.py in repro branch, and there's a custom_BBN function there
that runs with and without the BBN stimulus ... 

* 23aug24
** testing BBN batch

http://www.netpyne.org/tutorial.html#tutorial-8-running-batch-simulations

mpiexec -np 48 nrniv -python -mpi batch.py

hmm, getting issues running using mpiexec ... creates configs but does not actually run them

** info from SD

sd: for BBN here’s the data: https://drive.google.com/drive/folders/1FYnlTBrS2WVvHAa6LWNoeq03v-O9496P?usp=drive_link
and this some summary erica sent: https://docs.google.com/document/d/1E0EHdja1HpzQKHa0q5WqGRP386xjEYs_wHDLz2xanLI/edit
sn: thanks...will try run it...for BBN using the ICThalInput
sd:  this also best ERP matches from erica: https://docs.google.com/document/d/1eY1Vfk0wmd62bgWuM-FA1WA2Ma2RDSHecWJ6oDKTMTY/edit?usp=sharing
and best BBN CSD matches: https://docs.google.com/document/d/1Lnt68zwRfQ8hzUx_B0DguUBNeyEr05m0abCs1JMn5IE/edit?usp=sharing
the ERP fig I shared above is for SOA850
sn: if i was going to optimize model to match ERPs to experiment ... could focus on dipoles, CSD, or LFP ... and adjust the strength/timing of inputs probably ...
sd: yeah that makes sense

** try a single sim with BBN

use this in cfg.py : 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': 2500,
                   'weightE': 0.25,
                   'weightI': 0.25,
                   'probE': 0.12, 
                   'probI': 0.12,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

./myrun 48

  Done; gather time = 76.08 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 241557 (1.54 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 5834.21 s
   NGF1 : 1.696 Hz
   IT2 : 0.161 Hz
   SOM2 : 9.467 Hz
   PV2 : 3.583 Hz
   VIP2 : 22.328 Hz
   NGF2 : 7.775 Hz
   IT3 : 0.130 Hz
   SOM3 : 0.715 Hz
   PV3 : 2.794 Hz
   VIP3 : 10.702 Hz
   NGF3 : 4.684 Hz
   ITP4 : 0.167 Hz
   ITS4 : 0.165 Hz
   SOM4 : 0.670 Hz
   PV4 : 1.695 Hz
   VIP4 : 7.006 Hz
   NGF4 : 5.423 Hz
   IT5A : 1.077 Hz
   CT5A : 0.201 Hz
   SOM5A : 2.054 Hz
   PV5A : 0.462 Hz
   VIP5A : 2.815 Hz
   NGF5A : 5.448 Hz
   IT5B : 2.698 Hz
   CT5B : 0.058 Hz
   PT5B : 0.078 Hz
   SOM5B : 13.307 Hz
   PV5B : 0.206 Hz
   VIP5B : 1.516 Hz
   NGF5B : 4.538 Hz
   IT6 : 0.438 Hz
   CT6 : 0.294 Hz
   SOM6 : 10.228 Hz
   PV6 : 66.888 Hz
   VIP6 : 61.333 Hz
   NGF6 : 28.491 Hz
   TC : 4.613 Hz
   TCM : 4.504 Hz
   HTC : 4.200 Hz
   IRE : 2.397 Hz
   IREM : 2.975 Hz
   TI : 1.872 Hz
   TIM : 3.187 Hz
   IC : 0.242 Hz
Saving output as data/23aug24_A0/23aug24_A0_data.pkl ... 
Finished saving!
  Done; saving time = 31.39 s.

* 23aug25
** 23aug24_A0 -- check BBN sim

python -i simdat.py

NGF1 1.68 Hz
IT2 0.16 Hz
SOM2 9.57 Hz
PV2 3.66 Hz
VIP2 22.55 Hz
NGF2 7.2 Hz
IT3 0.13 Hz
SOM3 0.72 Hz
PV3 2.79 Hz
VIP3 10.64 Hz
NGF3 4.68 Hz
ITP4 0.17 Hz
ITS4 0.16 Hz
SOM4 0.66 Hz
PV4 1.71 Hz
VIP4 7.05 Hz
NGF4 5.53 Hz
IT5A 0.97 Hz
CT5A 0.12 Hz
SOM5A 2.03 Hz
PV5A 0.45 Hz
VIP5A 2.39 Hz
NGF5A 5.29 Hz
IT5B 2.69 Hz
CT5B 0.06 Hz
PT5B 0.08 Hz
SOM5B 13.16 Hz
PV5B 0.19 Hz
VIP5B 1.26 Hz
NGF5B 4.43 Hz
IT6 0.4 Hz
CT6 0.25 Hz
SOM6 9.94 Hz
PV6 67.26 Hz
VIP6 57.13 Hz
NGF6 28.51 Hz
TC 4.48 Hz
TCM 4.47 Hz
HTC 4.07 Hz
IRE 2.37 Hz
IREM 2.93 Hz
TI 1.87 Hz
TIM 3.18 Hz
IC 0.24 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug25__rast.png]]

xlim((2e3,4e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug25__rastB.png]]

only looks like one activation of IC population ... 
even during that activation, do not see much impact on L4 ... 

check the parameters for IC -> THAL and THAL -> CTX

looks like it's only applied a single time at 2.5 s ... 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': 2500,
                   'weightE': 0.25,
                   'weightI': 0.25,
                   'probE': 0.12, 
                   'probI': 0.12,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

moved params into cfg.py ... 

  Spikes: 262669 (1.67 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 5662.20 s
   NGF1 : 1.714 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.700 Hz
   PV2 : 3.032 Hz
   VIP2 : 16.359 Hz
   NGF2 : 7.000 Hz
   IT3 : 0.115 Hz
   SOM3 : 0.715 Hz
   PV3 : 2.851 Hz
   VIP3 : 8.468 Hz
   NGF3 : 4.515 Hz
   ITP4 : 0.135 Hz
   ITS4 : 0.158 Hz
   SOM4 : 0.678 Hz
   PV4 : 2.138 Hz
   VIP4 : 5.532 Hz
   NGF4 : 5.167 Hz
   IT5A : 1.002 Hz
   CT5A : 0.202 Hz
   SOM5A : 1.754 Hz
   PV5A : 0.458 Hz
   VIP5A : 2.815 Hz
   NGF5A : 5.146 Hz
   IT5B : 2.198 Hz
   CT5B : 0.082 Hz
   PT5B : 0.080 Hz
   SOM5B : 12.832 Hz
   PV5B : 0.209 Hz
   VIP5B : 1.495 Hz
   NGF5B : 4.028 Hz
   IT6 : 0.547 Hz
   CT6 : 0.294 Hz
   SOM6 : 10.343 Hz
   PV6 : 86.855 Hz
   VIP6 : 79.076 Hz
   NGF6 : 29.401 Hz
   TC : 5.033 Hz
   TCM : 4.918 Hz
   HTC : 4.716 Hz
   IRE : 2.494 Hz
   IREM : 2.955 Hz
   TI : 1.795 Hz
   TIM : 3.070 Hz
   IC : 3.392 Hz
Saving output as data/23aug24_BBN0/23aug24_BBN0_data.pkl ... 

* 23aug30 - adjusting for BBN
** check output from 23aug24_BBN0

python -i simdat.py 23aug24_BBN0

loaded simulation data 23aug24_BBN0 on 23aug30_
NGF1 1.69 Hz
IT2 0.16 Hz
SOM2 9.8 Hz
PV2 3.1 Hz
VIP2 16.45 Hz
NGF2 6.48 Hz
IT3 0.11 Hz
SOM3 0.72 Hz
PV3 2.85 Hz
VIP3 8.4 Hz
NGF3 4.51 Hz
ITP4 0.13 Hz
ITS4 0.16 Hz
SOM4 0.66 Hz
PV4 2.14 Hz
VIP4 5.55 Hz
NGF4 5.27 Hz
IT5A 0.9 Hz
CT5A 0.12 Hz
SOM5A 1.73 Hz
PV5A 0.45 Hz
VIP5A 2.39 Hz
NGF5A 4.98 Hz
IT5B 2.19 Hz
CT5B 0.08 Hz
PT5B 0.08 Hz
SOM5B 12.68 Hz
PV5B 0.2 Hz
VIP5B 1.24 Hz
NGF5B 3.9 Hz
IT6 0.51 Hz
CT6 0.25 Hz
SOM6 10.05 Hz
PV6 87.41 Hz
VIP6 73.74 Hz
NGF6 29.44 Hz
TC 4.89 Hz
TCM 4.89 Hz
HTC 4.58 Hz
IRE 2.46 Hz
IREM 2.91 Hz
TI 1.79 Hz
TIM 3.06 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug30_23aug24_BBN0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug30_23aug24_BBN0_rastB.png]]

does not look like any increase in L4 during the BBNs ... compared to the version
used in paper, so params must still differ

lk = ['IC', 'TC', 'TCM', 'ITP4','ITS4']
lclr = ['r','g','b','c','m']
sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in lk}

for k,clr in zip(lk, lclr): plot(sh[k][0],sh[k][1],clr)
xlim((4e3,6e3))
ax=gca()
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehist.png') # [[./gif/23aug30_23aug24_BBN0_spikehist.png]]

so IC, TC, TCM rates are increasing, but not L4 ITP4, ITS4 (L4 pyramidal and stellate neurons)

xlim((4e3,8e3))

savefig(gifpath()+'_spikehistB.png') # [[./gif/23aug30_23aug24_BBN0_spikehistB.png]]

so params used must not be correct ... 

** discuss

sn: those params i mentioned above must be incorrect, since look pretty different in terms of responses to BBN (almost negligible in L4)
[[./gif/23aug30_23aug24_BBN0_rast.png]]
[[./gif/23aug30_23aug24_BBN0_rastB.png]]
[[./gif/23aug30_23aug24_BBN0_spikehistB.png]]
sd: not sure if params right, but unfortunately there’s not much L4 activity in BBN sims… not sure if due to depol block
sn: i should prob. start from ones used in paper
that one had more noticeable response in L4
sd: above was referring to paper sims, not much L4 activity either
sn: so as long as maintain physiological firing rates during spontaneous and stimulation, tweaking thalamocortical and
corticothalamic gain within ~25% range reasonable?
will try that or something similar
sd: yeah I think reasonable ... can play with IC->Thal and Thal->Cx prob conn and weights

** adjust conn/weights for getting stronger BBN response

some of the relevant parameters:
    # params[('ICThalInput', 'probE')] = [0.12, 0.26]     # [0.26]    # 0,1,2  
    # params[('ICThalInput', 'probI')] = [0.12, 0.26]                 # 0,1,2
    #params[('ICThalInput', 'weightE')] = [0.25, 0.5]
    #params[('ICThalInput', 'weightI')] = [0.25, 0.5]

values used in previous simulation (23aug24_BBN0_):
                            'weightE': 0.25,
                            'weightI': 0.25,
                            'probE': 0.12, 
                            'probI': 0.12,

here are the other params taken from the json file (data/v34_batch25/trial_2142/trial_2142_cfg.json):
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain', 'wmat']

        "thalamoCorticalGain": 2.1111391118965863,
        "intraThalamicGain": 0.9843624229766335,
        "EbkgThalamicGain": 3.9181565363409163,
        "IbkgThalamicGain": 3.9227144872233324,

and the whole wmat is also specified in json ... 

also, the json file was already getting loaded, so did not need the extra function to 'load from batch' config

easiest to just change IC -> Thal, that way spontaneous dynamics do not require retuning

*** 23aug30_BBN_A0

weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12

./myrun 48

  Spikes: 268783 (1.71 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 9613.97 s
   NGF1 : 1.707 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.633 Hz
   PV2 : 3.128 Hz
   VIP2 : 15.802 Hz
   NGF2 : 6.925 Hz
   IT3 : 0.112 Hz
   SOM3 : 0.715 Hz
   PV3 : 3.202 Hz
   VIP3 : 8.334 Hz
   NGF3 : 4.535 Hz
   ITP4 : 0.134 Hz
   ITS4 : 0.149 Hz
   SOM4 : 0.663 Hz
   PV4 : 2.853 Hz
   VIP4 : 5.679 Hz
   NGF4 : 5.155 Hz
   IT5A : 0.962 Hz
   CT5A : 0.202 Hz
   SOM5A : 1.716 Hz
   PV5A : 0.468 Hz
   VIP5A : 3.019 Hz
   NGF5A : 5.104 Hz
   IT5B : 2.301 Hz
   CT5B : 0.113 Hz
   PT5B : 0.071 Hz
   SOM5B : 13.554 Hz
   PV5B : 0.207 Hz
   VIP5B : 2.047 Hz
   NGF5B : 3.962 Hz
   IT6 : 0.541 Hz
   CT6 : 0.292 Hz
   SOM6 : 10.314 Hz
   PV6 : 88.349 Hz
   VIP6 : 83.212 Hz
   NGF6 : 29.702 Hz
   TC : 5.342 Hz
   TCM : 5.195 Hz
   HTC : 5.041 Hz
   IRE : 2.679 Hz
   IREM : 3.188 Hz
   TI : 1.672 Hz
   TIM : 2.897 Hz
   IC : 3.392 Hz

*** 23aug30_BBN_B0

weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19

./myrun 48

  Spikes: 289178 (1.84 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 9605.40 s
   NGF1 : 1.736 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.517 Hz
   PV2 : 3.032 Hz
   VIP2 : 15.990 Hz
   NGF2 : 6.650 Hz
   IT3 : 0.101 Hz
   SOM3 : 0.715 Hz
   PV3 : 4.125 Hz
   VIP3 : 7.869 Hz
   NGF3 : 4.456 Hz
   ITP4 : 0.117 Hz
   ITS4 : 0.138 Hz
   SOM4 : 0.663 Hz
   PV4 : 4.173 Hz
   VIP4 : 6.128 Hz
   NGF4 : 5.077 Hz
   IT5A : 0.873 Hz
   CT5A : 0.204 Hz
   SOM5A : 1.661 Hz
   PV5A : 0.514 Hz
   VIP5A : 3.315 Hz
   NGF5A : 5.052 Hz
   IT5B : 2.402 Hz
   CT5B : 0.177 Hz
   PT5B : 0.067 Hz
   SOM5B : 14.359 Hz
   PV5B : 0.226 Hz
   VIP5B : 1.818 Hz
   NGF5B : 4.118 Hz
   IT6 : 0.559 Hz
   CT6 : 0.308 Hz
   SOM6 : 10.388 Hz
   PV6 : 102.047 Hz
   VIP6 : 87.780 Hz
   NGF6 : 30.684 Hz
   TC : 5.927 Hz
   TCM : 5.983 Hz
   HTC : 5.532 Hz
   IRE : 2.738 Hz
   IREM : 3.038 Hz
   TI : 1.672 Hz
   TIM : 2.863 Hz
   IC : 3.392 Hz

* 23aug31
** check outputs from last two sims
*** 23aug30_BBN_A0

weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12

python -i simdat.py 23aug30_BBN_A0

NGF1 1.69 Hz
IT2 0.16 Hz
SOM2 9.74 Hz
PV2 3.19 Hz
VIP2 15.88 Hz
NGF2 6.41 Hz
IT3 0.11 Hz
SOM3 0.72 Hz
PV3 3.2 Hz
VIP3 8.27 Hz
NGF3 4.53 Hz
ITP4 0.13 Hz
ITS4 0.15 Hz
SOM4 0.65 Hz
PV4 2.86 Hz
VIP4 5.7 Hz
NGF4 5.26 Hz
IT5A 0.86 Hz
CT5A 0.12 Hz
SOM5A 1.69 Hz
PV5A 0.46 Hz
VIP5A 2.58 Hz
NGF5A 4.94 Hz
IT5B 2.29 Hz
CT5B 0.11 Hz
PT5B 0.07 Hz
SOM5B 13.4 Hz
PV5B 0.2 Hz
VIP5B 1.77 Hz
NGF5B 3.84 Hz
IT6 0.5 Hz
CT6 0.25 Hz
SOM6 10.02 Hz
PV6 88.91 Hz
VIP6 77.61 Hz
NGF6 29.75 Hz
TC 5.2 Hz
TCM 5.17 Hz
HTC 4.9 Hz
IRE 2.65 Hz
IREM 3.14 Hz
TI 1.67 Hz
TIM 2.89 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug31_23aug30_BBN_A0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug31_23aug30_BBN_A0_rastB.png]]

lk = ['IC', 'TC', 'TCM', 'IT2', 'IT3', 'ITP4','ITS4']
lclr = ['r','g','b','c','m','y','k']
sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in lk}

for k,clr in zip(lk, lclr): plot(sh[k][0],sh[k][1],clr)
xlim((4e3,6e3))
ax=gca()
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehist.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehist.png]]

xlim((4e3,8e3))

savefig(gifpath()+'_spikehistB.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistB.png]]

put thal, ctx hist in diff subplots

lplt = [1,1,1,2,2,2,2]

for k,clr,gdx in zip(lk, lclr,lplt): 
  subplot(2,1,gdx)
  plot(sh[k][0],sh[k][1],clr)

ax=subplot(2,1,1)
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr[0:3],lk[0:3])]
ax.legend(handles=lpatch,handlelength=1)
ax=subplot(2,1,2)
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr[3:],lk[3:])]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistC.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistC.png]]

ylim((0,.65))
savefig(gifpath()+'_spikehistD.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistD.png]]

looks like IT3 increases slightly for some of the stimuli, while other E neurons decrease
activation during stimulus, due to activation of interneurons ... 

dnumc
{'NGF1': 150, 'IT2': 338, 'SOM2': 5, 'PV2': 13, 'VIP2': 16, 'NGF2': 11, 'IT3': 4461, 'SOM3': 70, 'PV3': 176, 'VIP3': 211, 'NGF3': 150, 'ITP4': 837, 'ITS4': 837, 'SOM4': 24, 'PV4': 92, 'VIP4': 13, 'NGF4': 14, 'IT5A': 359, 'CT5A': 359, 'SOM5A': 43, 'PV5A': 73, 'VIP5A': 10, 'NGF5A': 8, 'IT5B': 471, 'CT5B': 471, 'PT5B': 471, 'SOM5B': 112, 'PV5B': 134, 'VIP5B': 17, 'NGF5B': 24, 'IT6': 1009, 'CT6': 1009, 'SOM6': 63, 'PV6': 84, 'VIP6': 12, 'NGF6': 38, 'TC': 116, 'TCM': 155, 'HTC': 38, 'IRE': 155, 'IREM': 155, 'TI': 51, 'TIM': 51, 'IC': 200}

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 12e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 12e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistE.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistG.png]]

so does look like inhib ramping up during stimulus ... check next simulation with diff params

*** 23aug30_BBN_B0

weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19

python -i simdat.py 23aug30_BBN_B0

NGF1 1.72 Hz
IT2 0.16 Hz
SOM2 9.62 Hz
PV2 3.1 Hz
VIP2 16.07 Hz
NGF2 6.15 Hz
IT3 0.1 Hz
SOM3 0.72 Hz
PV3 4.12 Hz
VIP3 7.8 Hz
NGF3 4.45 Hz
ITP4 0.12 Hz
ITS4 0.14 Hz
SOM4 0.65 Hz
PV4 4.16 Hz
VIP4 6.15 Hz
NGF4 5.18 Hz
IT5A 0.77 Hz
CT5A 0.12 Hz
SOM5A 1.64 Hz
PV5A 0.51 Hz
VIP5A 2.85 Hz
NGF5A 4.88 Hz
IT5B 2.39 Hz
CT5B 0.18 Hz
PT5B 0.07 Hz
SOM5B 14.2 Hz
PV5B 0.22 Hz
VIP5B 1.55 Hz
NGF5B 4.0 Hz
IT6 0.52 Hz
CT6 0.27 Hz
SOM6 10.1 Hz
PV6 102.74 Hz
VIP6 81.89 Hz
NGF6 30.75 Hz
TC 5.78 Hz
TCM 5.96 Hz
HTC 5.39 Hz
IRE 2.71 Hz
IREM 2.99 Hz
TI 1.67 Hz
TIM 2.85 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23sep7_23aug30_BBN_B0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23sep7_23aug30_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 12e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 12e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistE.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistG.png]]

during stimulus looks like even less ECTX firing here, but more synchronized, partly through
higher inhibition

* 23sep7
** next simulations (less inhib from IC -> Thal)

hmm, that may not help since thalamus to cortex is the current issue leading
to too much cortical inhibition activated ... adjusting thalamic to cortical
drive for E vs I will cause changes in spontaneous activity

ran before: 
 23aug30_BBN_A0 : weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12
 23aug30_BBN_B0 : weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19
both had too much cortical inhibition activated ... ? 

some parameters that may need adjustment:
cfg.EbkgThalamicGain = 4.0
cfg.IbkgThalamicGain = 4.0

cfg.thalamoCorticalGain = 1.0
cfg.intraThalamicGain = 1.0
cfg.corticoThalamicGain = 1.0

also TC and TCM should probably get activated differently from IC inputs
so may need to add separate gain factor for IC -> TC and IC -> TCM 

*** 23sep7_BBN_A0
*** 23sep7_BBN_B0
* 23oct6 - BBN ERPs
** opt for BBN

to start, can use avg CSD BBN ERP response in each layer

from NHP : /data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl

python

import numpy as np
import pickle
d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl','rb'))
d.keys() # dict_keys([44000.0, 20000.0])

type(d[44000.0]['CSD'])
d[44000.0]['CSD'].keys() # dict_keys(['A1', 'Thal', 'Empty'])
d[44000.0]['CSD']['A1'].keys() # dict_keys(['s2', 'g', 'i1', 'tt', 's2avg', 's2stderr', 'gavg', 'gstderr', 'i1avg', 'i1stderr'])

for k in ['s2avg', 'gavg', 'i1avg']: plot(d[44000.0]['CSD']['A1']['tt'], d[44000.0]['CSD']['A1'][k])

savefig('gif/23oct6_nhp_avg_csd_bbn_erp_a0.png') # [[./gif/23oct6_nhp_avg_csd_bbn_erp_a0.png]]

looks much different from ERPs in
 https://docs.google.com/presentation/d/1fBufKJtZsNOOGMmcXCTHjgU7cZlPMJFqPwm0hVfBPjw/edit#slide=id.g278ae243da3_0_84
slide 28

which CSD channels used in A1 model for s, g, i layers?

* 23oct31 - continue check BBN ERPs
** back to BBN ERP opt

d[44000.0]['CSD']['A1']['tt'][0] # 0.0
d[44000.0]['CSD']['A1']['tt'][-1] # 150.0

so 150 ms for the NHP ERP averages in s,g,i layers

info from EG:
https://docs.google.com/document/d/1E0EHdja1HpzQKHa0q5WqGRP386xjEYs_wHDLz2xanLI/edit
https://github.com/NathanKlineInstitute/a1dat/blob/erica/avgERP_forPaper.py

looks like the ERPs are smoothed using bandpass filter of 1-110 Hz
and in slides/A1 paper, used 300 ms instead of 150 ms used in OEvent paper

figure()

for k,clr in zip(['s2avg', 'gavg', 'i1avg'],['r','g','b']): plot(d[44000.0]['CSD']['A1']['tt'], bandpass(d[44000.0]['CSD']['A1'][k],1,110,44000),clr)

savefig('gif/23oct31_nhp_avg_csd_bbn_erp_smoothed_a0.png') # [[./gif/23oct31_nhp_avg_csd_bbn_erp_smoothed_a0.png

dERPLowPass = {}
for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[k] = bandpass(d[44000.0]['CSD']['A1'][k],1,110,44000)
pickle.dump(dERPLowPass,open('/data/samn/a1dat/data/bbn/avgERP/23nov1_50dB_bbn_avgERP_bandpass_1_110_Hz.pkl','wb'))
ok, will use that file for optimization/comparison with model

* 23nov1 - looking at BBN ERPs: model vs nhp
** model channels for s, g, i = 4, 10, 15

	## Get channel(s) to plot
		if region == 'supra':
			chan = 4 # chan 0-9
		elif region == 'gran':
			chan = 10  # chan 10-11
		elif region == 'infra':
			chan = 15	# chan 12-19

4, 10, 15

** extract model ERPs from BBN sim

from cfg.py can see when the BBN stimuli applied:
cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': list(np.arange(5000, 9000, 300)),
                   'weightE': 0.375,
                   'weightI': 0.375,
                   'probE': 0.19, 
                   'probI': 0.19,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

from 5 - 9 s interval of 300 ms between, and each BBN is 100 ms

conda activate py376

python -i simdat.py 23aug30_BBN_B0

loading data from 23aug30_BBN_B0
loaded simulation data 23aug30_BBN_B0 on 23nov1_
NGF1 1.72 Hz
IT2 0.16 Hz
SOM2 9.62 Hz
PV2 3.1 Hz
VIP2 16.07 Hz
NGF2 6.15 Hz
IT3 0.1 Hz
SOM3 0.72 Hz
PV3 4.12 Hz
VIP3 7.8 Hz
NGF3 4.45 Hz
ITP4 0.12 Hz
ITS4 0.14 Hz
SOM4 0.65 Hz
PV4 4.16 Hz
VIP4 6.15 Hz
NGF4 5.18 Hz
IT5A 0.77 Hz
CT5A 0.12 Hz
SOM5A 1.64 Hz
PV5A 0.51 Hz
VIP5A 2.85 Hz
NGF5A 4.88 Hz
IT5B 2.39 Hz
CT5B 0.18 Hz
PT5B 0.07 Hz
SOM5B 14.2 Hz
PV5B 0.22 Hz
VIP5B 1.55 Hz
NGF5B 4.0 Hz
IT6 0.52 Hz
CT6 0.27 Hz
SOM6 10.1 Hz
PV6 102.74 Hz
VIP6 81.89 Hz
NGF6 30.75 Hz
TC 5.78 Hz
TCM 5.96 Hz
HTC 5.39 Hz
IRE 2.71 Hz
IREM 2.99 Hz
TI 1.67 Hz
TIM 2.85 Hz
IC 3.38 Hz

next, get the LFP and derived CSD

simConfig['simData'].keys() # dict_keys(['LFP', 'spkt', 'spkid', 't', 'popRates', 'avgRate'])
LFP = simConfig['simData']['LFP']
len(LFP) # 240000

len(LFP[0]) # 20 <- 20 channels

LFP = np.array(LFP)
LFP.shape # (240000, 20)

tt = linspace(0,12e3,LFP.shape[0])
plot(tt,LFP[:,0])
xlabel('Time (ms)'); 

savefig('gif/23nov1_LFP_a0.png') # [[./gif/23nov1_LFP_a0.png]]

ylim((-.4,-0.05)); xlim((2e3,12e3))
savefig('gif/23nov1_LFP_a1.png') # [[./gif/23nov1_LFP_a1.png]]

CSD = getCSD(LFP, 1e3/0.05)

CSD.shape # (18, 240000)

plot(tt,CSD[0,:])
xlim((0,12e3))
savefig('gif/23nov1_CSD_a2.png') # [[./gif/23nov1_CSD_a2.png]]
ylim((-30,30))
savefig('gif/23nov1_CSD_a3.png') # [[./gif/23nov1_CSD_a3.png]]

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,12e3))

savefig('gif/23nov1_CSD_a4.png') # [[./gif/23nov1_CSD_a4.png]]

xlim((4e3,10e3))

savefig('gif/23nov1_CSD_a5.png') # [[./gif/23nov1_CSD_a5.png]]

now average the CSD ERPs ... take from BBN onset + 150 ms 

bbnT = np.arange(5000, 9000, 300)
array([5000, 5300, 5600, 5900, 6200, 6500, 6800, 7100, 7400, 7700, 8000,
       8300, 8600, 8900])

use modified code from a1dat/erp.py for cutting out the ERPs and averaging them... 

CSD.shape # (18, 240000)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,bandpass(avgERP[chan,:],1,110,sampr),clr)

xlabel('Time (ms)');
xlim((0,150))


savefig('gif/23nov1_model_CSD_ERP_avg_bandpass_a6.png') # [[./gif/23nov1_model_CSD_ERP_avg_bandpass_a6.png]]

now overlay for each channel ... model and NHP average (and filtered) ERPs

import pickle

d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/23nov1_50dB_bbn_avgERP_bandpass_1_110_Hz.pkl','rb'))

will also have to resample the data before running optimization 

ttnhpERP = np.linspace(0,150,len(d['s2avg']))

for clr,gdx,k in zip(['r','g','b'],[1,2,3],['s2avg','gavg','i1avg']):
  subplot(1,3,gdx)
  plot(ttnhpERP,d[k]/np.sum(d[k]),clr,linewidth=4)

for clr,gdx,chan in zip(['r','g','b'],[1,2,3],lchan): 
  subplot(1,3,gdx)
  y = bandpass(avgERP[chan,:],1,110,sampr)
  y = y / np.sum(y)
  plot(ttERP,y,clr)
  xlim((0,150))

savefig('gif/23nov1_model_nhp_CSD_ERP_avg_bandpass_compare_a7.png')
[[./gif/23nov1_model_nhp_CSD_ERP_avg_bandpass_compare_a7.png]]

look very different ... (thick lines are NHP, thin lines are model)

note that amplitudes are normalized ... 

** cmetzner version: https://github.com/ChristophMetzner/A1model/blob/main/batch_tu_mpi_ASSR.py

has some code for modifying the thal -> cx weights specific for E vs I inputs
cm thought could be too much activation of cx L4 I neurons by thal, while sd
though could be depolarization blockade of L4 E neurons ... so running different
grid searches to test 

cm has setup these params for modulation (thal -> cx at finer specificity):
 https://github.com/ChristophMetzner/A1model/blob/main/netParams_ASSR.py

** need to setup opt in optunaERP function in batch.py
* 23nov2 - more setup for ERP opt
** IC -> Thal, only seems to go to core

    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probE'],
            'weight': cfg.ICThalInput['weightE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probI'],
            'weight': cfg.ICThalInput['weightI'],
            'delay': cfg.delayBkg}  

do not see projections to thalamic matrix

** add IC->Thal cfg params

# these params control IC -> Thal
cfg.ICThalweightE = 0.375
cfg.ICThalweightI = 0.375
cfg.ICThalprobE = 0.19
cfg.ICThalprobI = 0.19

** sm suggests thalL4E==0.5 to avoid dep blockade
** next BBN sim (23nov2_BBN_A0)

# these params control IC -> Thal
cfg.ICThalweightE = 0.375
cfg.ICThalweightI = 0.25
cfg.ICThalprobE = 0.19
cfg.ICThalprobI = 0.12

# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.75 # [minF,maxF] 0.1 - 2
cfg.thalL4SOM = 0.75 # [minF,maxF]
cfg.thalL4E = 0.5 # [minF,maxF]

want to reduce thalamic triggered cortical inhibition,
but also reduce potential for L4 E depolarization blockade

also shortening sim duration (11 s) and start BBN at 3 s instead of 4

./myrun 48

  Spikes: 231225 (1.60 Hz)
  Simulated time: 11.0 s; 48 workers
  Run time: 5049.40 s
   NGF1 : 1.796 Hz
   IT2 : 0.019 Hz
   SOM2 : 7.000 Hz
   PV2 : 0.469 Hz
   VIP2 : 14.545 Hz
   NGF2 : 6.636 Hz
   IT3 : 0.111 Hz
   SOM3 : 0.038 Hz
   PV3 : 2.938 Hz
   VIP3 : 7.051 Hz
   NGF3 : 4.377 Hz
   ITP4 : 0.009 Hz
   ITS4 : 0.036 Hz
   SOM4 : 0.012 Hz
   PV4 : 0.716 Hz
   VIP4 : 7.084 Hz
   NGF4 : 4.383 Hz
   IT5A : 0.941 Hz
   CT5A : 0.301 Hz
   SOM5A : 0.820 Hz
   PV5A : 0.573 Hz
   VIP5A : 3.525 Hz
   NGF5A : 5.386 Hz
   IT5B : 2.236 Hz
   CT5B : 0.124 Hz
   PT5B : 0.082 Hz
   SOM5B : 13.158 Hz
   PV5B : 0.246 Hz
   VIP5B : 1.915 Hz
   NGF5B : 4.538 Hz
   IT6 : 0.239 Hz
   CT6 : 0.163 Hz
   SOM6 : 6.456 Hz
   PV6 : 94.373 Hz
   VIP6 : 85.612 Hz
   NGF6 : 18.388 Hz
   TC : 5.696 Hz
   TCM : 5.419 Hz
   HTC : 5.064 Hz
   IRE : 2.597 Hz
   IREM : 3.113 Hz
   TI : 1.678 Hz
   TIM : 2.916 Hz
   IC : 3.701 Hz
Saving output as data/23nov2_BBN_A0/23nov2_BBN_A0_data.pkl ... 

** setting up optuna ERP optimization

need to have the NHP data at 20 kHz ... 

that's sampling rate used in model

python

import numpy as np
import pickle
d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl','rb'))
d.keys() # dict_keys([44000.0, 20000.0])

so have 20 kHz data ... just need to smooth it 1-110 Hz for use in opt

dERPLowPass = {20000:{},44000:{}}
for sampr in [20000, 44000]:
  for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[sampr][k] = bandpass(d[sampr]['CSD']['A1'][k],1,110,sampr)

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr)
  xlabel('Time (ms)'); xlim((0,150))

savefig('gif/23nov2_nhp_erp_20khz_a0.png') # [[./gif/23nov2_nhp_erp_20khz_a0.png]]

savefig('gif/23nov2_nhp_erp_20khz_44kHz_a1.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_a1.png]]

looks much different with the 20 kHz vs 44 kHz ... 

also try w/o the bandpass filtering ... 

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr,linewidth=4)
  xlabel('Time (ms)'); xlim((0,150))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, d[sampr]['CSD']['A1'][k],clr)

savefig('gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_a2.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_a2.png]]

timing of ERP features is very distorted with the bandpass filter 1-110 Hz ... 

minf,maxf=1,1000
dERPLowPass = {20000:{},44000:{}}
for sampr in [20000, 44000]:
  for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[sampr][k] = bandpass(d[sampr]['CSD']['A1'][k],minf,maxf,sampr)

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr,linewidth=4)
  xlabel('Time (ms)'); xlim((0,150))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, d[sampr]['CSD']['A1'][k],clr)

savefig('gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png]]

better with the higher upper maxf of 1 kHz but still introduces some distortion to the ERPs ... will not smooth
them for the optimization ... and probably better to use the 44 kHz vs 20 kHz ... 

## pickle.dump(dERPLowPass,open('/data/samn/a1dat/data/bbn/avgERP/23nov2_50dB_bbn_avgERP_bandpass_1_110_Hz_20kHz_rate.pkl','wb'))

** check output from 23nov2_BBN_A0

python -i simdat.py 23nov2_BBN_A0

NGF1 1.78 Hz
IT2 0.02 Hz
SOM2 7.07 Hz
PV2 0.48 Hz
VIP2 14.62 Hz
NGF2 6.16 Hz
IT3 0.11 Hz
SOM3 0.04 Hz
PV3 2.94 Hz
VIP3 6.99 Hz
NGF3 4.38 Hz
ITP4 0.01 Hz
ITS4 0.04 Hz
SOM4 0.01 Hz
PV4 0.72 Hz
VIP4 7.13 Hz
NGF4 4.48 Hz
IT5A 0.83 Hz
CT5A 0.21 Hz
SOM5A 0.8 Hz
PV5A 0.57 Hz
VIP5A 3.05 Hz
NGF5A 5.24 Hz
IT5B 2.23 Hz
CT5B 0.12 Hz
PT5B 0.08 Hz
SOM5B 13.03 Hz
PV5B 0.24 Hz
VIP5B 1.64 Hz
NGF5B 4.41 Hz
IT6 0.21 Hz
CT6 0.12 Hz
SOM6 6.23 Hz
PV6 95.13 Hz
VIP6 79.97 Hz
NGF6 18.26 Hz
TC 5.58 Hz
TCM 5.4 Hz
HTC 4.94 Hz
IRE 2.57 Hz
IREM 3.07 Hz
TI 1.68 Hz
TIM 2.91 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov2_23nov2_BBN_A0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov2_23nov2_BBN_A0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistG.png]]

during BBN inputs still see the TC and TCM populations getting activated ~equally ... 
that should be checked/fixed!

also looks like L4 E neurons are still not getting activated enough

check CSD ERPs ... 

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)

tt = linspace(0,totalDur,LFP.shape[0])

CSD = getCSD(LFP, 1e3/0.05)

CSD.shape # (18, 220000)

plot(tt,CSD[0,:])
xlim((0,totalDur))
savefig('gif/23nov2_CSD_a2.png') #

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,totalDur))

savefig('gif/23nov2_CSD_a4.png') # [[./gif/23nov2_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig('gif/23nov2_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov2_model_BBN_avg_ERP_CSD_a5.png]]

so, probably firing activity should get adjusted ... then CSD opt ...

drawcellVm(simConfig) # did not record Vm ... 

** emails about NHP ERPs, recording sampling rates, and best frequencies

Hi,

I'm looking at NHP ERPs in response to BBN for optimizing the A1 model
to reproduce them. I noticed that the 20 vs 44 kHz dataset has pretty
different-looking ERPs. Do you recommend one or the other in the
attachment as prototypical ERPs to optimize towards?

I attached the average ERPs from BBN in 20 vs 44 kHz recordings. Red,
green, blue are the supra-, gran-, and infra-granular sink channel
average CSD ERP. Thick lines are also bandpass filtered between
1-1kHz, which distorts the waveforms, so will be avoided.

Thanks,
Sam

attachment: [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png]]


no> Just so I’m clear at what I’m looking at, is this data in response
to BBN from an A1 site whose BF is 20KHz (left plot) and then A1 site
whose BF is 44kHz (right plot)? Although we usually don’t have BFs
that high…max is usually 32KHz…is that a typo and the 44kHz is 32kHz?

sn> No, the 20 vs 44 kHz is the .mat file recording frequency. I think
20 kHz is from older data ...

no> Oh I see….yes the 20kHz is the sampling rate of the older system.
The CSD response to BBN may depend on the BF of the recording site, as
High BF sites tend to show a better more typical response to BBN
whereas lower tuned BF sites show a much mushier response. DO you know
the BFs of these two sites?  The plots on the right (44kHz) does show
a more typical response as the gran (green) trace is a sink as it
should be, whereas in the left plot it’s a source. Honestly though the
sampling rate of the system shouldn’t affect the profiles.

sn> The 44 kHz data is the same as shown in Fig 2 here:
 https://www.eneuro.org/content/eneuro/9/4/ENEURO.0281-21.2022.full.pdf
 I can go with that if you think it's OK, but If you know of an ideal
 example of s,g,i CSD ERP response to BBN I should probably use that
 instead of mixing together data from different NHPs/BFs, even at the
 44 kHz rate.

Here are the files used and their best frequencies (last column):

2-rb019020063@os.mat sampr: 44000.0 bestF: 500.0
2-rb023024010@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024011@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024012@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024052@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb029030006@os.mat sampr: 44000.0 bestF: 16000.0
2-rb029030009@os.mat sampr: 44000.0 bestF: 16000.0

Should I just use the ones with 11313 and 16000 best frequencies and
leave out the first file? or even just use the last 2?

no> Yes, I would use 2-rb023024011 or 2-rb023024052, it's a beautiful
BBN related profile. Ch 11 for supra, ch 15 for gran and ch 20 for
infra.

For some reason 2-rb029030 has a very weird profile, so I wouldn't use.

** make sure IC -> TC,HTC activates separately from IC -> TCM

was looking at A1 model response to BBN and seemed that TC and TCM
neurons responded similarly ... think TCM should respond less than TC
to core-like inputs. but looking at code see the following

    # cochlea/IC -> thal
    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probE'],
            'weight': cfg.ICThalInput['weightE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probI'],
            'weight': cfg.ICThalInput['weightI'],
            'delay': cfg.delayBkg}  

seems that IC only hits TC. but since TCM is defined as a TC type here:
netParams.popParams['TCM'] =    {'cellType': 'TC',  'cellModel': 'HH_reduced',  'ynormRange': layer['thal'],   'density': thalDensity} 

does that mean TCM would receive the IC inputs?

sd> ah yes, TCM will be receiving the same IC input as TC, as they are defined using the same cell type
sn> agree i should prob adjust that?
sn> will give that a try via postconds on pop instead of celltype
sd>  yeah I think makes sense
thanks
sn> putting that in samn branch

*** email NO about this

one more question

right now the model thalamic core and matrix get the same inputs from
inferior colliculus. I was thinking core-like inputs should hit
thalamic core more strongly than thalamic matrix. Do you agree?
Perhaps just down-modulating the strength of inputs to thalamic matrix
makes sense, so that some modulatory auditory stimulus component
reaches thalamic matrix, just less strongly than thalamic core. Do you
agree?

Thanks,
Sam

no> I am no expert but the matrix of MGB receives inputs from all 3 of
the IC divisions (the tonotopically organized CNIC and the other 2
non-tonotopically organized divisions) while MGBv receives inputs only
from the CNIC, so I agree that just lowering the strength of the core
like inputs to the matrix makes sense.

** make separate pathway for IC -> thalamic core and IC -> thalamic matrix (23nov2_BBN_B0)

will have weaker and lower probability of connection from IC -> Thalamic Matrix
compared to Thalamic Core

for example:

# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.375
cfg.ICThalweightICore = 0.25
cfg.ICThalprobECore = 0.19
cfg.ICThalprobICore = 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.2
cfg.ICThalweightEMatrix = cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalweightIMatrix = cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobEMatrix = cfg.ICThalprobECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobIMatrix = cfg.ICThalprobICore * cfg.ICThalMatrixCoreFactor

and then adjust netParams.py as follows:

    # cochlea/IC -> thal
    if cfg.ICThalInput:
        # IC -> thalamic core
        netParams.connParams['IC->ThalECore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probECore'],
            'weight': cfg.ICThalInput['weightECore'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalICore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probICore'],
            'weight': cfg.ICThalInput['weightICore'],
            'delay': cfg.delayBkg}

        # IC -> thalamic matrix
        netParams.connParams['IC->ThalEMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TCM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probEMatrix'],
            'weight': cfg.ICThalInput['weightEMatrix'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalIMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['IREM', 'TIM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probIMatrix'],
            'weight': cfg.ICThalInput['weightIMatrix'],
            'delay': cfg.delayBkg}  

ok, try that sim out, same as previous otherwise

also saving traces from each pop to check dep block

./myrun 48

  Simulated time: 11.0 s; 48 workers
  Run time: 5053.70 s
   NGF1 : 1.744 Hz
   IT2 : 0.020 Hz
   SOM2 : 7.945 Hz
   PV2 : 0.490 Hz
   VIP2 : 17.034 Hz
   NGF2 : 7.036 Hz
   IT3 : 0.127 Hz
   SOM3 : 0.038 Hz
   PV3 : 2.057 Hz
   VIP3 : 7.942 Hz
   NGF3 : 4.438 Hz
   ITP4 : 0.013 Hz
   ITS4 : 0.040 Hz
   SOM4 : 0.012 Hz
   PV4 : 0.462 Hz
   VIP4 : 7.378 Hz
   NGF4 : 4.461 Hz
   IT5A : 1.138 Hz
   CT5A : 0.305 Hz
   SOM5A : 0.870 Hz
   PV5A : 0.547 Hz
   VIP5A : 3.192 Hz
   NGF5A : 5.739 Hz
   IT5B : 2.146 Hz
   CT5B : 0.077 Hz
   PT5B : 0.088 Hz
   SOM5B : 12.580 Hz
   PV5B : 0.247 Hz
   VIP5B : 1.858 Hz
   NGF5B : 4.591 Hz
   IT6 : 0.200 Hz
   CT6 : 0.171 Hz
   SOM6 : 6.103 Hz
   PV6 : 77.460 Hz
   VIP6 : 88.430 Hz
   NGF6 : 17.562 Hz
   TC : 5.080 Hz
   TCM : 4.228 Hz
   HTC : 4.845 Hz
   IRE : 2.739 Hz
   IREM : 2.877 Hz
   TI : 1.745 Hz
   TIM : 3.156 Hz
   IC : 3.701 Hz

* 23nov3
** check output from 23nov2_BBN_B0

python -i simdat.py 23nov2_BBN_B0

NGF1 1.73 Hz
IT2 0.02 Hz
SOM2 8.04 Hz
PV2 0.5 Hz
VIP2 17.17 Hz
NGF2 6.53 Hz
IT3 0.13 Hz
SOM3 0.04 Hz
PV3 2.06 Hz
VIP3 7.89 Hz
NGF3 4.44 Hz
ITP4 0.01 Hz
ITS4 0.04 Hz
SOM4 0.01 Hz
PV4 0.46 Hz
VIP4 7.43 Hz
NGF4 4.56 Hz
IT5A 1.02 Hz
CT5A 0.22 Hz
SOM5A 0.85 Hz
PV5A 0.54 Hz
VIP5A 2.74 Hz
NGF5A 5.6 Hz
IT5B 2.14 Hz
CT5B 0.08 Hz
PT5B 0.09 Hz
SOM5B 12.45 Hz
PV5B 0.24 Hz
VIP5B 1.59 Hz
NGF5B 4.47 Hz
IT6 0.17 Hz
CT6 0.13 Hz
SOM6 5.88 Hz
PV6 78.03 Hz
VIP6 82.61 Hz
NGF6 17.42 Hz
TC 4.96 Hz
TCM 4.2 Hz
HTC 4.72 Hz
IRE 2.71 Hz
IREM 2.83 Hz
TI 1.75 Hz
TIM 3.15 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov2_BBN_B0_rast.png]]

ITP4, ITS4 rates still too low, even during stimulus
matrix firing a little less than before

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov2_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistE.png]]

ok, can see now that TCM (blue in top panel) is firing less than TC (green in top panel)
during the BBN stimuli

there also appears to be a little less suppression of the cortical excitatory neurons
during BBN, due to less activation of cortical interneurons

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistF.png]]

still need more activation of L4 excitatory neurons during stimulation

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistG.png]]

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov2_BBN_B0_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov2_BBN_B0_model_BBN_avg_ERP_CSD_a5.png]]

simConfig['simData']['V_soma'].keys()
dict_keys(['cell_0', 'cell_7393', 'cell_9948', 'cell_494', 'cell_7406', 'cell_12303', 'cell_8272', 'cell_12496', 'cell_8181', 'cell_5065', 'cell_8138', 'cell_12458', 'cell_507', 'cell_12651', 'cell_5452', 'cell_7276', 'cell_7420', 'cell_4995', 'cell_7779', 'cell_5602', 'cell_9972', 'cell_9685', 'cell_10981', 'cell_11990', 'cell_12806', 'cell_7300', 'cell_12137', 'cell_12857', 'cell_523', 'cell_9931', 'cell_12187', 'cell_8254', 'cell_9214', 'cell_9797', 'cell_12053', 'cell_12149', 'cell_534', 'cell_151', 'cell_6439', 'cell_8743', 'cell_8264', 'cell_489', 'cell_5241'])

how about neuronal Vm ...
dstartidx['ITP4'] # 5602
dstartidx['ITS4'] # 6439

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov2_BBN_B0_cell_Vm_a6.png]]

ITP4, ITS4 not activated much, and does not look like depolarization blockade ... 

** next sim, increase thal activation of L4 excitatory neurons (23nov3_BBN_A0)

and decrease thal activation of L4 inhibitory neurons
cfg.thalL4PV = 0.5 # [minF,maxF] 0.1 - 2
cfg.thalL4SOM = 0.5 # [minF,maxF]
cfg.thalL4E = 2.0 # [minF,maxF]

for prob of connections of IC -> Matrix, could keep same as core, just reduce
the weights ... to ~10%

# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.1
cfg.ICThalweightEMatrix = cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalweightIMatrix = cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobEMatrix = cfg.ICThalprobECore # * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobIMatrix = cfg.ICThalprobICore # * cfg.ICThalMatrixCoreFactor

and for core have this:
# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.375
cfg.ICThalweightICore = 0.25
cfg.ICThalprobECore = 0.19
cfg.ICThalprobICore = 0.12

cfg.simLabel = '23nov3_BBN_A0' 

./myrun 48

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 562744 (3.90 Hz)
  Simulated time: 11.0 s; 48 workers
  Run time: 5360.39 s
   NGF1 : 1.482 Hz
   IT2 : 0.813 Hz
   SOM2 : 6.327 Hz
   PV2 : 29.867 Hz
   VIP2 : 23.705 Hz
   NGF2 : 17.536 Hz
   IT3 : 0.119 Hz
   SOM3 : 3.046 Hz
   PV3 : 23.542 Hz
   VIP3 : 54.117 Hz
   NGF3 : 7.738 Hz
   ITP4 : 2.098 Hz
   ITS4 : 1.841 Hz
   SOM4 : 14.957 Hz
   PV4 : 7.751 Hz
   VIP4 : 10.881 Hz
   NGF4 : 13.162 Hz
   IT5A : 1.902 Hz
   CT5A : 1.509 Hz
   SOM5A : 10.273 Hz
   PV5A : 3.660 Hz
   VIP5A : 29.545 Hz
   NGF5A : 21.034 Hz
   IT5B : 7.403 Hz
   CT5B : 0.624 Hz
   PT5B : 0.160 Hz
   SOM5B : 24.932 Hz
   PV5B : 1.554 Hz
   VIP5B : 19.551 Hz
   NGF5B : 18.697 Hz
   IT6 : 2.038 Hz
   CT6 : 2.438 Hz
   SOM6 : 71.077 Hz
   PV6 : 0.062 Hz
   VIP6 : 1.281 Hz
   NGF6 : 144.560 Hz
   TC : 6.656 Hz
   TCM : 5.969 Hz
   HTC : 5.958 Hz
   IRE : 3.645 Hz
   IREM : 3.421 Hz
   TI : 1.929 Hz
   TIM : 2.927 Hz
   IC : 3.701 Hz

check output ... 

python -i simdat.py 23nov3_BBN_A0

NGF1 1.47 Hz
IT2 0.72 Hz
SOM2 6.2 Hz
PV2 30.48 Hz
VIP2 24.07 Hz
NGF2 15.26 Hz
IT3 0.02 Hz
SOM3 2.25 Hz
PV3 22.47 Hz
VIP3 53.56 Hz
NGF3 7.19 Hz
ITP4 2.0 Hz
ITS4 1.74 Hz
SOM4 14.28 Hz
PV4 7.4 Hz
VIP4 10.34 Hz
NGF4 12.68 Hz
IT5A 1.81 Hz
CT5A 1.42 Hz
SOM5A 9.33 Hz
PV5A 3.48 Hz
VIP5A 27.02 Hz
NGF5A 20.95 Hz
IT5B 7.4 Hz
CT5B 0.56 Hz
PT5B 0.16 Hz
SOM5B 23.72 Hz
PV5B 1.45 Hz
VIP5B 18.64 Hz
NGF5B 18.42 Hz
IT6 1.52 Hz
CT6 2.26 Hz
SOM6 68.85 Hz
PV6 0.0 Hz
VIP6 1.11 Hz
NGF6 143.99 Hz
TC 6.42 Hz
TCM 5.95 Hz
HTC 5.75 Hz
IRE 3.54 Hz
IREM 3.38 Hz
TI 1.93 Hz
TIM 2.92 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov3_BBN_A0_rast.png]]

ok, now very clear firing in L2, L3, L4 excitatory neurons

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov3_BBN_A0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,5)); subplot(3,1,3); ylim((1,35))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistF.png]]

should just show ITP4, ITS4 for the ectx ... 

lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((1,35))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistG.png]]

so L4 E neurons are firing more, but cant really say it's due to stimulus
and part of that is because TC is almost always firing, so the BBN input
is not driving TC much more ... well, a little more firing in TC ... may
need to strengthen that a bit and reduce TC -> L4E a bit so that there's
a detectable response to stimulus and background L4E is a little quieter

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-80,80))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov3_BBN_A0_CSD_a4.png]]
well, now granular layer (green) has much higher amplitude CSD

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov3_BBN_A0_model_BBN_avg_ERP_CSD_a5.png]]

granular CSD ERP looks a little better ...

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov3_BBN_A0_cell_Vm_a6.png]]

** next sim (23nov3_BBN_B0)

so may need to turn down cfg.thalL4E ... ? and increase IC -> TC ... ?

increase cfg.ICThalweightECore from 0.375 to 1.0
and decrease cfg.thalL4E from 2.0 to 1.0

that way TC more activated when IC firing, and L4E a little more dependent on IC->TC pathway
for activation

./myrun 48

  Simulated time: 11.0 s; 48 workers
  Run time: 5369.96 s
   NGF1 : 1.563 Hz
   IT2 : 0.126 Hz
   SOM2 : 3.091 Hz
   PV2 : 2.105 Hz
   VIP2 : 20.756 Hz
   NGF2 : 8.264 Hz
   IT3 : 0.163 Hz
   SOM3 : 1.784 Hz
   PV3 : 5.172 Hz
   VIP3 : 11.213 Hz
   NGF3 : 4.933 Hz
   ITP4 : 0.365 Hz
   ITS4 : 0.317 Hz
   SOM4 : 0.704 Hz
   PV4 : 0.890 Hz
   VIP4 : 6.252 Hz
   NGF4 : 6.026 Hz
   IT5A : 0.752 Hz
   CT5A : 0.167 Hz
   SOM5A : 2.976 Hz
   PV5A : 0.284 Hz
   VIP5A : 1.111 Hz
   NGF5A : 3.818 Hz
   IT5B : 2.140 Hz
   CT5B : 0.173 Hz
   PT5B : 0.056 Hz
   SOM5B : 17.787 Hz
   PV5B : 0.116 Hz
   VIP5B : 0.847 Hz
   NGF5B : 3.102 Hz
   IT6 : 0.500 Hz
   CT6 : 0.355 Hz
   SOM6 : 8.644 Hz
   PV6 : 90.089 Hz
   VIP6 : 93.479 Hz
   NGF6 : 25.187 Hz
   TC : 5.824 Hz
   TCM : 4.173 Hz
   HTC : 5.184 Hz
   IRE : 3.599 Hz
   IREM : 2.785 Hz
   TI : 1.760 Hz
   TIM : 3.078 Hz
   IC : 3.701 Hz

python -i simdat.py 23nov3_BBN_B0

NGF1 1.55 Hz
IT2 0.13 Hz
SOM2 3.05 Hz
PV2 2.15 Hz
VIP2 20.96 Hz
NGF2 7.66 Hz
IT3 0.16 Hz
SOM3 1.8 Hz
PV3 5.17 Hz
VIP3 11.17 Hz
NGF3 4.94 Hz
ITP4 0.37 Hz
ITS4 0.32 Hz
SOM4 0.69 Hz
PV4 0.9 Hz
VIP4 6.28 Hz
NGF4 6.16 Hz
IT5A 0.64 Hz
CT5A 0.08 Hz
SOM5A 2.95 Hz
PV5A 0.27 Hz
VIP5A 0.81 Hz
NGF5A 3.6 Hz
IT5B 2.14 Hz
CT5B 0.17 Hz
PT5B 0.05 Hz
SOM5B 17.64 Hz
PV5B 0.1 Hz
VIP5B 0.6 Hz
NGF5B 2.95 Hz
IT6 0.46 Hz
CT6 0.31 Hz
SOM6 8.37 Hz
PV6 90.82 Hz
VIP6 87.36 Hz
NGF6 25.13 Hz
TC 5.68 Hz
TCM 4.15 Hz
HTC 5.05 Hz
IRE 3.57 Hz
IREM 2.74 Hz
TI 1.76 Hz
TIM 3.07 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov3_BBN_B0_rast.png]]

looks better - can see clear time-locked response in L2/3 and L4

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov3_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistE.png]]

subplot(3,1,2); ylim((0,1)); subplot(3,1,3); ylim((1,10))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistF.png]]

lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

subplot(3,1,2); ylim((0,2)); subplot(3,1,3); ylim((0,10))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistG.png]]

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-30,30))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov3_BBN_B0_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov3_BBN_B0_model_BBN_avg_ERP_CSD_a5.png]]

CSD ERPs have a clearer shape, but not sure in right direction ...

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov3_BBN_B0_cell_Vm_a6.png]]

not all L4 cells firing now, but as population there's a clear response...

may need to optimize for ERP CSD since polarity could be reversed

* 23nov6
** continue with latest simulation

check overall CSD ERP

since even if waveforms look incorrect on channels, used, nearby channels could
have better-looking waveforms ... 

look in analysis/plostCSD.py for some useful functions

from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov3_BBN_B0/23nov3_BBN_B0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': 100, 'L2': 160, 'L3': 950, 'L4': 1250, 'L5A': 1334, 'L5B': 1550, 'L6': 2000}
sim.analysis.plotCSD(overlay='LFP',timeRange=[3.5e3,8.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD_a0.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_a0.png]]

can see sinks/sources, but looks like main sink is above L4 (somewhere in L3), while main
source is in L4 ... well some sinks in L4, but not as prominent ... 

savefig(gifpath()+'_CSD_a1.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_a1.png]]

sim.analysis.plotCSD(overlay='CSD',timeRange=[3.5e3,8.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a2.png]]

savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a3.png]]

** email about CSD

I made some of those modifications to the model (adjusting level of
activation between IC->Thalamic core vs matrix, and Thal->Ctx
excitatory vs Thal->Ctx interneurons), ... now we get a more
pronounced response in L4 after BBN stimulation (between 4-8 s in the
model, every 300 ms).

In the attached figures there's a rasterplot and CSD.

Does the CSD look somewhat realistic / similar to what you see in BBN experiments? 

There are prominent sinks during BBN, but slightly above the model's L4 (more in L3).

Perhaps it's OK to use the ~L3 location as the approximate granular
sink for purposes of optimization?

Let me know if anything else stands out.

attachments:
  [[./gif/23nov3_23nov3_BBN_B0_rast.png]]  
  [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a2.png]]
  [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a3.png]]

no> Is the first plot the response to BBN and the 2nd to the 40Hz stimuli?

I don't know Sam….Annie and I discussed it and we don't think these
CSD responses look correct. There should not be a source in the
granular layer (unless it's an inhibitory response) and the response
in the upper supra should not have such a low amplitude
either. Generally the CSD response amplitude in the upper and lower
Supra layer should be pretty equal. Sorry!

And in the 40HZ response similarly there should be an initial sink
in the granular layer.
 
You probably told me this already but what BF do you have this cortical
column tuned to?

sn> Both images I attached are responses to BBN at 300 ms intervals
(from 4-8 s), none of those images had 40 Hz inputs. One was a raster
plot, the other CSD. The BF is similar to NHP recordings.

Thanks for the feedback.

I'm thinking that the location of sinks/sources has more to do with
the location of E vs I synapses on the dendrites, so the only way to
move sinks/sources to physiological locations is to adjust that entire
setup, which is a big change to the model. Alternatively, there's a
chance that adjusting the relative input strengths of E vs I synapses
while keeping them fixed vertically would work. . .

jc> sorry, to clarify for me, does adjusting relative input strengths
meaning altering the synaptic weights while retaining the same overall
activity?

samn> good question. remains to be seen. we'd probably want about same
spontaneous firing rates, but allow for higher rates during auditory
stimulation.  hopefully strength adjustments enough...seems feasible
given ITS4 should have enough AMPA/NMDA activation within L4

** more adjustments -- need stronger excitatory activation within L4 to produce current sink there

try simple test of increasing cfg.thalL4E from 1.0 to 2.0
and thalL4PV and thalL4SOM from 0.5 to 0.25

also, no need for 11 s simulation ... just run BBN stimulation for 1 s (3-4 s) and then stop simulation after ~7 s
should be enough to look at basic BBN response

./myrun 48

   NGF1 : 1.286 Hz
   IT2 : 0.877 Hz
   SOM2 : 5.171 Hz
   PV2 : 23.549 Hz
   VIP2 : 11.652 Hz
   NGF2 : 18.086 Hz
   IT3 : 0.171 Hz
   SOM3 : 5.884 Hz
   PV3 : 30.593 Hz
   VIP3 : 59.826 Hz
   NGF3 : 8.314 Hz
   ITP4 : 2.429 Hz
   ITS4 : 2.134 Hz
   SOM4 : 17.975 Hz
   PV4 : 6.845 Hz
   VIP4 : 25.857 Hz
   NGF4 : 14.643 Hz
   IT5A : 1.740 Hz
   CT5A : 2.495 Hz
   SOM5A : 14.259 Hz
   PV5A : 4.226 Hz
   VIP5A : 22.794 Hz
   NGF5A : 22.768 Hz
   IT5B : 7.964 Hz
   CT5B : 1.682 Hz
   PT5B : 0.177 Hz
   SOM5B : 32.493 Hz
   PV5B : 1.106 Hz
   VIP5B : 10.786 Hz
   NGF5B : 19.482 Hz
   IT6 : 3.109 Hz
   CT6 : 2.903 Hz
   SOM6 : 82.354 Hz
   PV6 : 0.098 Hz
   VIP6 : 2.753 Hz
   NGF6 : 188.086 Hz
   TC : 8.578 Hz
   TCM : 6.191 Hz
   HTC : 7.274 Hz
   IRE : 3.914 Hz
   IREM : 3.320 Hz
   TI : 2.297 Hz
   TIM : 2.946 Hz
   IC : 1.662 Hz

python -i simdat.py 23nov6_BBN_A0

NGF1 1.35 Hz
IT2 0.32 Hz
SOM2 3.6 Hz
PV2 7.08 Hz
VIP2 1.0 Hz
NGF2 19.91 Hz
IT3 0.0 Hz
SOM3 0.04 Hz
PV3 33.25 Hz
VIP3 67.38 Hz
NGF3 7.83 Hz
ITP4 2.74 Hz
ITS4 2.49 Hz
SOM4 25.33 Hz
PV4 3.89 Hz
VIP4 2.23 Hz
NGF4 14.21 Hz
IT5A 1.31 Hz
CT5A 1.64 Hz
SOM5A 9.65 Hz
PV5A 6.11 Hz
VIP5A 47.5 Hz
NGF5A 26.5 Hz
IT5B 8.22 Hz
CT5B 0.73 Hz
PT5B 0.15 Hz
SOM5B 23.97 Hz
PV5B 0.89 Hz
VIP5B 20.82 Hz
NGF5B 24.92 Hz
IT6 1.69 Hz
CT6 2.67 Hz
SOM6 76.98 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 175.39 Hz
TC 6.95 Hz
TCM 6.55 Hz
HTC 6.42 Hz
IRE 3.35 Hz
IREM 3.39 Hz
TI 2.29 Hz
TIM 2.98 Hz
IC 0.0 Hz

savefig(gifpath()+'_rast.png') # [[./gif/23nov6_23nov6_BBN_A0_rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, totalDur)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, totalDur)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((0,25))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov6_23nov6_BBN_A0_spikehistG.png]]

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov6_BBN_A0/23nov6_BBN_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': 100, 'L2': 160, 'L3': 950, 'L4': 1250, 'L5A': 1334, 'L5B': 1550, 'L6': 2000}
sim.analysis.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov6_23nov6_BBN_A0_CSD_CSD_overlay_a2.png]]

** follow up email to no

well, I tweaked connection strength from thalamic core -> L4 E and I
neurons and got sinks in L4 during BBN ... firing activity is now too
high, so this will require some optimization to get right. At least it
shows that we can get ~the desired CSD profiles by tweaking some
parameters we have access to ...

attachments:
 [[./gif/23nov6_23nov6_BBN_A0_rast.png]]
 [[./gif/23nov6_23nov6_BBN_A0_CSD_CSD_overlay_a2.png]]

* 23nov7
** more discussion on CSD during BBN

CM That looks good! Will also run some more sims with increased
cfg.thalL4E and decreased cfg.thall4SOM,PV later 

Two quick comments:
The Allen Insitute paper Salva shared some days ago suggests that it
might be possible to shift the synapse locations (and thus change the
CSD) without a big effect on the firing rates (so maybe not that big
of a change to the model!?). It also suggests that CSD patterns in
supragranular layers might depend on feedback from higher areas. which
we could artificially inject during stimulation (not the most elegant
way of doing it but maybe the quickest) and thus we would also not
alter the spontaneous activity

samn: That sounds interesting to try, though synapses were placed on
the neurons based on known physiology/anatomy, so not sure we should
do that only to avoid re-tuning the model.

@salvadord
 what do you think?

top-down inputs another question ... we might get part of that effect
through thalamic matrix, but have to see if that top-down input should
be primarily cortical/excitatory ...
 
 cm I believe in the Allen paper it was primarily ecitatory  but will have to reread the paper

cm: I agree it would be a big change if we significantly moved away
from the experimental data.It might however be possible to first
change the weights as you suggested earlier and then potentially move
the synapses a little bit or change the percentage of synapses that go
onto a specific compartment slightly (let's say within experimental
variability), although I am not sure how much that would give us
because of the reduced morphology

samn: agree with that assessment. and agree that for cells such as ITS4
which are already compact/very simplified geometries, likely won't
have much room to move their synapses.

sd: to be fair I don’t think we had that much detailed data on the
dendritic placement of syns, particularly specific to macaque A1 …
plus the cells are just 5 compartments, so I don’t think the changes
should affect the spiking activity that significantly, and
particularly since we have weight normalization/democratization
(weights are adjusted so they produce similar effect on soma) … but
the changes might still affect the LFP/EEG significantly, so I think
it is worth trying

samn: i wasn't clear how much the synapses could move since they'll
still be localized within the boundaries of the cells, which are small
for ITS4. but agree it's worth a try & might help in other layers -
anyone here want to try that? i'll probably start with weight
adjustments

** email from no

This is does look better alright for the gran layer but the pattern of
sinks and sources in the supra layer is still off (it should be source
over a sink). Perhaps that will come with further modifications.

sn> great ... !

for correct patterns in supra-granular layers, a question came up
whether it will require: 1) additional top-down cortico-cortical
feedback, or 2) depends on either local cortical circuitry within A1
(L4 -> L2/3 pathway), or 3) from thalamic projections (matrix ->
L2/3)... we can likely achieve the right effect with any of these
modifications, but would prefer to stick to the correct neuroanatomy,
where possible ...

** avg ERP data at 20 kHz for optimization (on edge)

/home/samn/a1dat/data/bbn/avgERP/2-rb023024011@os.mat_20kHz_avgERP.pkl
/home/samn/a1dat/data/bbn/avgERP/2-rb023024052@os.mat_20kHz_avgERP.pkl

** install optuna 

pip install optuna
conda install sqlalchemy

apparently need sqlalchemy for optuna to import properly ...

python
import optuna

python
import netpyne
dir(netpyne.batch)
['Batch', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'absolute_import', 'asd_parallel', 'batch', 'division', 'evol', 'grid', 'optuna_parallel', 'print_function', 'standard_library', 'unicode_literals', 'utils']

now optuna visible in netpyne.batch

** back to opt setup

for now will just take correlation between avg granular CSD ERP
fitness is 'minimized', so will take -pearson correlation

python batch.py
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...

mpiexec -np 2 nrniv -python -mpi batch.py

 mpiexec -np 2 nrniv -python -mpi batch.py
numprocs=2
NEURON -- VERSION 8.0.2 HEAD (f0ca7454) 2022-02-02
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2021
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 "mod/APCounter2.mod" "mod/ar_traub.mod" "mod/beforestep_py.mod" "mod/CA1ika.mod" "mod/CA1ikdr.mod" "mod/CA1ina.mod" "mod/cadad.mod" "mod/cadecay_destexhe.mod" "mod/cad.mod" "mod/Cadynamics.mod" "mod/cadyn.mod" "mod/cagk.mod" "mod/cal_mh.mod" "mod/cal_mig.mod" "mod/cancr.mod" "mod/canin.mod" "mod/can_mig.mod" "mod/caolmw.mod" "mod/capr.mod" "mod/catcb.mod" "mod/cat_mig.mod" "mod/cat_traub.mod" "mod/ch_CavL.mod" "mod/ch_CavN.mod" "mod/ch_KCaS.mod" "mod/ch_Kdrfastngf.mod" "mod/ch_KvAngf.mod" "mod/ch_KvCaB.mod" "mod/ch_leak.mod" "mod/ch_Navngf.mod" "mod/cp2.mod" "mod/cp.mod" "mod/DynamicNetStim.mod" "mod/gabab.mod" "mod/h_BS.mod" "mod/HH2.mod" "mod/h_harnett.mod" "mod/HH_traub.mod" "mod/hin.mod" "mod/h_kole.mod" "mod/h_migliore.mod" "mod/htc.mod" "mod/Iahp.mod" "mod/ICal.mod" "mod/Ican.mod" "mod/ican_sidi.mod" "mod/icaolmw.mod" "mod/icapr.mod" "mod/iccr.mod" "mod/IC.mod" "mod/iconc_Ca.mod" "mod/iholmkop.mod" "mod/iholmw.mod" "mod/ihpyrkop.mod" "mod/IKM.mod" "mod/ikscr.mod" "mod/IKsin.mod" "mod/IL_gutnick.mod" "mod/IL.mod" "mod/IM_cortex.mod" "mod/ipulse3.mod" "mod/IT2.mod" "mod/IT.mod" "mod/kahppr.mod" "mod/kaolmkop.mod" "mod/kap_BS.mod" "mod/kapcb.mod" "mod/kapin.mod" "mod/kapyrkop.mod" "mod/kBK.mod" "mod/kca.mod" "mod/kcaolmw.mod" "mod/kcpr.mod" "mod/kctin.mod" "mod/kdmc_BS.mod" "mod/kdr2_orig.mod" "mod/kdr_BS.mod" "mod/kdrbwb.mod" "mod/kdrcr.mod" "mod/kdrin.mod" "mod/kdrolmkop.mod" "mod/kdrpr.mod" "mod/kdrpyrkop.mod" "mod/kl.mod" "mod/km.mod" "mod/kv.mod" "mod/MyExp2SynAlpha.mod" "mod/MyExp2SynBB.mod" "mod/my_exp2syn.mod" "mod/MyExp2SynNMDABB.mod" "mod/na_2.mod" "mod/naf2.mod" "mod/nafbwb.mod" "mod/nafcr.mod" "mod/nafolmkop.mod" "mod/nafpr.mod" "mod/nafpyrkop.mod" "mod/nafx.mod" "mod/nap_sidi.mod" "mod/nax_BS.mod" "mod/naz.mod" "mod/Nca.mod" "mod/ntIh.mod" "mod/ntleak.mod" "mod/ntt_int.mod" "mod/ntt.mod" "mod/pasi.mod" "mod/savedist.mod" "mod/tia.mod" "mod/vecstim.mod" "mod/wrap.mod"
bash: /opt/miniconda3/envs/py376/lib/libtinfo.so.6: no version information available (required by bash)
running batch...
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...
>>> 
running batch...
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...

debugging ...

* 23nov8
** continue setup for optuna ERP

apparently, this is a problem:
    params[('seeds', 'conn')] = [0]
    params[('seeds', 'stim')] = [0]

since when get rid of it, both optuna and evol seem to run ... 

also, need to make sure optuna, inspyred, sqlalchemy packages are installed
in order to use optuna or inspyred with netpyne

need to run with mpi or directly?

according to jc can run directly as
 python batch.py
unless using bulletin board (not doing that)

* 23nov9
** trying to start batch

according to jc can run directly as
 python batch.py
unless using bulletin board (not doing that)

even after restarting edge cannot get the batch to run ... 
so it's not an issue of zombie processes ... 

using evolution seems to start nrniv jobs, but creates full
population at once ... cant afford to run all of them
at once, and rather avoid large pop

can probably try grid to start anyway ...

* 23nov10
** try optuna example to make sure runs properly

from https://github.com/suny-downstate-medical-center/netpyne/blob/development/examples/optunaOptim/optuna_test.py

python -i optunaTest.py

need sklearn installed ... 

conda install scikit-learn

python -i optunaTest.py

[I 2023-11-10 08:08:27,483] Using an existing study with name 'test1' instead of creating a new one.
optunaTest.py:11: FutureWarning: suggest_uniform has been deprecated in v3.0.0. This feature will be removed in v6.0.0. See https://github.com/optuna/optuna/releases/tag/v3.0.0. Use suggest_float instead.
  x = trial.suggest_uniform('x', min_x, max_x)
[I 2023-11-10 08:08:27,546] Trial 10 finished with value: 0.7889987008429175 and parameters: {'x': 1.1117440116481525}. Best is trial 5 with value: 0.27876898863347926.
[I 2023-11-10 08:08:27,579] Trial 11 finished with value: 0.8448447328713707 and parameters: {'x': 1.0808456425216868}. Best is trial 5 with value: 0.27876898863347926.
[I 2023-11-10 08:08:27,612] Trial 12 finished with value: 0.7268634903091045 and parameters: {'x': 1.1474371047781258}. Best is trial 5 with value: 0.27876898863347926.
[I 2023-11-10 08:08:27,645] Trial 13 finished with value: 0.38772961234199815 and parameters: {'x': 2.622679381658007}. Best is trial 5 with value: 0.27876898863347926.
[I 2023-11-10 08:08:27,678] Trial 14 finished with value: 1.139511757085533 and parameters: {'x': 3.0674791600239946}. Best is trial 5 with value: 0.27876898863347926.
[I 2023-11-10 08:08:27,711] Trial 15 finished with value: 0.22492627912903987 and parameters: {'x': 2.4742639340378307}. Best is trial 15 with value: 0.22492627912903987.
[I 2023-11-10 08:08:27,745] Trial 16 finished with value: 6.902170141565098 and parameters: {'x': 4.627198154225352}. Best is trial 15 with value: 0.22492627912903987.
[I 2023-11-10 08:08:27,777] Trial 17 finished with value: 0.010439265703461372 and parameters: {'x': 2.102172724850918}. Best is trial 17 with value: 0.010439265703461372.
[I 2023-11-10 08:08:27,811] Trial 18 finished with value: 0.06389842145265216 and parameters: {'x': 2.252781370857609}. Best is trial 17 with value: 0.010439265703461372.
[I 2023-11-10 08:08:27,844] Trial 19 finished with value: 4.063256986807175 and parameters: {'x': 4.015752213643129}. Best is trial 17 with value: 0.010439265703461372.
{'x': 2.102172724850918}
0.010439265703461372
FrozenTrial(number=17, state=TrialState.COMPLETE, values=[0.010439265703461372], datetime_start=datetime.datetime(2023, 11, 10, 8, 8, 27, 750721), datetime_complete=datetime.datetime(2023, 11, 10, 8, 8, 27, 768822), params={'x': 2.102172724850918}, user_attrs={}, system_attrs={}, intermediate_values={}, distributions={'x': FloatDistribution(high=10.0, log=False, low=1.0, step=None)}, trial_id=18, value=None)
>>> 

ok, seemed to have worked now ... 

** retry batch.py with optuna

python batch.py

running batch...
Saving batch to data/optunaERP_23nov10_/optunaERP_23nov10__batch.json ... 
[I 2023-11-10 08:09:22,689] A new study created in RDB with name: optunaERP_23nov10_
set ICThalweightECore=0.7627168964940808
set ICThalweightICore=0.29542883774592615
set ICThalprobECore=0.1945618998343761
set ICThalprobICore=0.10827470926186814
set ICThalMatrixCoreFactor=0.0996924276891577
set thalL4PV=0.21037339654005263
set thalL4SOM=0.18771766488757063
set thalL4E=2.4606712923135188
Saving simConfig to data/optunaERP_23nov10_/trial_0/trial_0_cfg.json ... 
Submitting job  trial_0
#!/bin/bash

cd .
mpiexec -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23nov10_/trial_0/trial_0_cfg.json netParams=data/optunaERP_23nov10_/optunaERP_23nov10__netParams.py 
        
--------------------------------------------------------------------------------
Waiting for jobs from generation 0/100 ...
completed: 0

still does nothing ... just waits ... 

* 23nov15
** mpiexec issue

was that the jobs would not start and mpiexec returns value of 1 (error)
not clear why mpiexec fails
this occurs at different parts of the code, even at beginning of simulation
but standalone call to mpiexec in a separate file works

e.g. this in a file runs properly:

import subprocess
import shlex

def testMPI ():
  jobString = 'mpiexec -n 48 nrniv -python -mpi init.py simConfig=/home/samn/A1/data/optunaERP_23nov13_/gen_0/trial_0_cfg.json netParams=/home/samn/A1/data/optunaERP_23nov13_/optunaERP_23nov13__netParams.py'
  print('mpi_direct...')
  xout = subprocess.run(shlex.split(jobString),check=True)
  print('xout:',xout)
  quit()

testMPI()

but then including that in __init__.py of netpyne or netpyne batch leads to mpiexec failing and returning 1

** jc fixing optuna batch in netpyne
* 23nov16
** update nrniv

nrniv
NEURON -- VERSION 8.0.2 HEAD (f0ca7454) 2022-02-02
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2021
See http://neuron.yale.edu/neuron/credits

loading membrane mechanisms from x86_64/.libs/libnrnmech.so

pip install neuron --upgrade
Requirement already satisfied: neuron in /opt/miniconda3/envs/py376/lib/python3.7/site-packages (8.0.2)
Collecting neuron
  Downloading NEURON-8.2.3-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (14.9 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 14.9/14.9 MB 32.9 MB/s eta 0:00:00

Requirement already satisfied: numpy>=1.9.3 in /opt/miniconda3/envs/py376/lib/python3.7/site-packages (from neuron) (1.21.5)
Installing collected packages: neuron
  Attempting uninstall: neuron
    Found existing installation: NEURON 8.0.2
    Uninstalling NEURON-8.0.2:
      Successfully uninstalled NEURON-8.0.2
Successfully installed neuron-8.2.3
(py376) samn@edge:~/A1$ nrniv
NEURON -- VERSION 8.2.3 HEAD (f0ed37010) 2023-09-14
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2022
See http://neuron.yale.edu/neuron/credits

loading membrane mechanisms from x86_64/.libs/libnrnmech.so
Additional mechanisms from files
 "mod/APCounter2.mod" "mod/ar_traub.mod" "mod/beforestep_py.mod" "mod/CA1ika.mod" "mod/CA1ikdr.mod" "mod/CA1ina.mod" "mod/cadad.mod" "mod/cadecay_destexhe.mod" "mod/cad.mod" "mod/Cadynamics.mod" "mod/cadyn.mod" "mod/cagk.mod" "mod/cal_mh.mod" "mod/cal_mig.mod" "mod/cancr.mod" "mod/canin.mod" "mod/can_mig.mod" "mod/caolmw.mod" "mod/capr.mod" "mod/catcb.mod" "mod/cat_mig.mod" "mod/cat_traub.mod" "mod/ch_CavL.mod" "mod/ch_CavN.mod" "mod/ch_KCaS.mod" "mod/ch_Kdrfastngf.mod" "mod/ch_KvAngf.mod" "mod/ch_KvCaB.mod" "mod/ch_leak.mod" "mod/ch_Navngf.mod" "mod/cp2.mod" "mod/cp.mod" "mod/DynamicNetStim.mod" "mod/gabab.mod" "mod/h_BS.mod" "mod/HH2.mod" "mod/h_harnett.mod" "mod/HH_traub.mod" "mod/hin.mod" "mod/h_kole.mod" "mod/h_migliore.mod" "mod/htc.mod" "mod/Iahp.mod" "mod/ICal.mod" "mod/Ican.mod" "mod/ican_sidi.mod" "mod/icaolmw.mod" "mod/icapr.mod" "mod/iccr.mod" "mod/IC.mod" "mod/iconc_Ca.mod" "mod/iholmkop.mod" "mod/iholmw.mod" "mod/ihpyrkop.mod" "mod/IKM.mod" "mod/ikscr.mod" "mod/IKsin.mod" "mod/IL_gutnick.mod" "mod/IL.mod" "mod/IM_cortex.mod" "mod/ipulse3.mod" "mod/IT2.mod" "mod/IT.mod" "mod/kahppr.mod" "mod/kaolmkop.mod" "mod/kap_BS.mod" "mod/kapcb.mod" "mod/kapin.mod" "mod/kapyrkop.mod" "mod/kBK.mod" "mod/kca.mod" "mod/kcaolmw.mod" "mod/kcpr.mod" "mod/kctin.mod" "mod/kdmc_BS.mod" "mod/kdr2_orig.mod" "mod/kdr_BS.mod" "mod/kdrbwb.mod" "mod/kdrcr.mod" "mod/kdrin.mod" "mod/kdrolmkop.mod" "mod/kdrpr.mod" "mod/kdrpyrkop.mod" "mod/kl.mod" "mod/km.mod" "mod/kv.mod" "mod/MyExp2SynAlpha.mod" "mod/MyExp2SynBB.mod" "mod/my_exp2syn.mod" "mod/MyExp2SynNMDABB.mod" "mod/na_2.mod" "mod/naf2.mod" "mod/nafbwb.mod" "mod/nafcr.mod" "mod/nafolmkop.mod" "mod/nafpr.mod" "mod/nafpyrkop.mod" "mod/nafx.mod" "mod/nap_sidi.mod" "mod/nax_BS.mod" "mod/naz.mod" "mod/Nca.mod" "mod/ntIh.mod" "mod/ntleak.mod" "mod/ntt_int.mod" "mod/ntt.mod" "mod/pasi.mod" "mod/savedist.mod" "mod/tia.mod" "mod/vecstim.mod" "mod/wrap.mod"

rm -rf x86_64

nrnivmodl mod

Successfully created x86_64/special

* 23nov17
** test output from jc on optuna ERP run (23nov17_BBN_A0)

--------------------------------------------------------------------------------
[I 2023-11-17 00:13:56,502] Trial 99 finished with value: 0.30584415058932946 and parameters: {'ICThalweightECore': 0.7920837452839831, 'ICThalweightICore': 0.2524082331332354, 'ICThalprobECore': 0.1596128819000591, 'ICThalprobICore': 0.103973001529323, 'ICThalMatrixCoreFactor': 0.11687728148746239, 'thalL4PV': 0.22649570649843453, 'thalL4SOM': 0.2485599831371632, 'thalL4E': 2.012681630751576}. Best is trial 45 with value: -0.3771605814721075.

Best trial:  FrozenTrial(number=45, state=TrialState.COMPLETE, values=[-0.3771605814721075], datetime_start=datetime.datetime(2023, 11, 15, 1, 49, 4, 510245), datetime_complete=datetime.datetime(2023, 11, 15, 2, 39, 36, 891644), params={'ICThalweightECore': 0.8350476447841453, 'ICThalweightICore': 0.2114492149101151, 'ICThalprobECore': 0.163484173596043, 'ICThalprobICore': 0.0936669688856933, 'ICThalMatrixCoreFactor': 0.12084663297800038, 'thalL4PV': 0.21367245896786016, 'thalL4SOM': 0.24260966747847523, 'thalL4E': 1.9540886147587417}, user_attrs={}, system_attrs={}, intermediate_values={}, distributions={'ICThalweightECore': FloatDistribution(high=1.25, log=False, low=0.75, step=None), 'ICThalweightICore': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'ICThalprobECore': FloatDistribution(high=0.2375, log=False, low=0.1425, step=None), 'ICThalprobICore': FloatDistribution(high=0.15, log=False, low=0.09, step=None), 'ICThalMatrixCoreFactor': FloatDistribution(high=0.125, log=False, low=0.075, step=None), 'thalL4PV': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'thalL4SOM': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'thalL4E': FloatDistribution(high=2.5, log=False, low=1.5, step=None)}, trial_id=46, value=None)

Parameter importance:  {'ICThalprobECore': 0.3209580299577318, 'ICThalweightICore': 0.18132281116659227, 'thalL4PV': 0.10491052539963013, 'thalL4E': 0.0993846423782245, 'thalL4SOM': 0.09452077667305898, 'ICThalweightECore': 0.08701357394820283, 'ICThalprobICore': 0.06346955822510736, 'ICThalMatrixCoreFactor': 0.0484200822514521}

Best Solution with fitness = -0.3772:
 {'ICThalweightECore': 0.8350476447841453, 'ICThalweightICore': 0.2114492149101151, 'ICThalprobECore': 0.163484173596043, 'ICThalprobICore': 0.0936669688856933, 'ICThalMatrixCoreFactor': 0.12084663297800038, 'thalL4PV': 0.21367245896786016, 'thalL4SOM': 0.24260966747847523, 'thalL4E': 1.9540886147587417}

Saving to output.pkl...

--------------------------------------------------------------------------------
   Completed Optuna parameter optimization
--------------------------------------------------------------------------------

*** test params from jc (above)

Best Solution with fitness = -0.3772:
 {'ICThalweightECore': 0.8350476447841453, 'ICThalweightICore': 0.2114492149101151, 'ICThalprobECore': 0.163484173596043, 'ICThalprobICore': 0.0936669688856933, 'ICThalMatrixCoreFactor': 0.12084663297800038, 'thalL4PV': 0.21367245896786016, 'thalL4SOM': 0.24260966747847523, 'thalL4E': 1.9540886147587417}

some of the values stayed close to original, but others moved quite a bit (e.g. ICThalweightECore)
most of the values that changed were reductions in IC -> Thal

will see how it looks ...

./myrun 48

  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 290193 (4.43 Hz)
  Simulated time: 5.0 s; 48 workers
  Run time: 2222.66 s
   NGF1 : 1.204 Hz
   IT2 : 1.323 Hz
   SOM2 : 2.480 Hz
   PV2 : 18.831 Hz
   VIP2 : 16.113 Hz
   NGF2 : 16.560 Hz
   IT3 : 0.226 Hz
   SOM3 : 8.641 Hz
   PV3 : 28.949 Hz
   VIP3 : 54.770 Hz
   NGF3 : 8.301 Hz
   ITP4 : 2.425 Hz
   ITS4 : 2.113 Hz
   SOM4 : 17.487 Hz
   PV4 : 6.730 Hz
   VIP4 : 26.200 Hz
   NGF4 : 14.814 Hz
   IT5A : 1.900 Hz
   CT5A : 2.014 Hz
   SOM5A : 16.181 Hz
   PV5A : 3.306 Hz
   VIP5A : 20.133 Hz
   NGF5A : 18.975 Hz
   IT5B : 7.883 Hz
   CT5B : 0.995 Hz
   PT5B : 0.167 Hz
   SOM5B : 33.233 Hz
   PV5B : 1.124 Hz
   VIP5B : 10.275 Hz
   NGF5B : 16.925 Hz
   IT6 : 3.065 Hz
   CT6 : 2.895 Hz
   SOM6 : 79.708 Hz
   PV6 : 0.145 Hz
   VIP6 : 2.764 Hz
   NGF6 : 173.700 Hz
   TC : 7.687 Hz
   TCM : 5.922 Hz
   HTC : 6.378 Hz
   IRE : 3.861 Hz
   IREM : 3.457 Hz
   TI : 1.976 Hz
   TIM : 2.800 Hz
   IC : 2.326 Hz
Saving output as data/23nov17_BBN_A0/23nov17_BBN_A0_data.pkl ... 
Finished saving!
  Done; saving time = 157.74 s.

check the output ...

python -i simdat.py 23nov17_BBN_A0

NGF1 1.59 Hz
IT2 0.36 Hz
SOM2 1.0 Hz
PV2 27.31 Hz
VIP2 35.62 Hz
NGF2 12.45 Hz
IT3 0.02 Hz
SOM3 0.0 Hz
PV3 19.63 Hz
VIP3 57.27 Hz
NGF3 7.39 Hz
ITP4 1.76 Hz
ITS4 1.68 Hz
SOM4 5.08 Hz
PV4 8.41 Hz
VIP4 21.38 Hz
NGF4 17.57 Hz
IT5A 1.49 Hz
CT5A 2.05 Hz
SOM5A 5.07 Hz
PV5A 4.58 Hz
VIP5A 36.4 Hz
NGF5A 23.62 Hz
IT5B 7.08 Hz
CT5B 0.86 Hz
PT5B 0.18 Hz
SOM5B 20.82 Hz
PV5B 1.55 Hz
VIP5B 20.18 Hz
NGF5B 21.21 Hz
IT6 1.12 Hz
CT6 1.82 Hz
SOM6 61.63 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 125.32 Hz
TC 6.66 Hz
TCM 5.27 Hz
HTC 4.61 Hz
IRE 3.59 Hz
IREM 3.3 Hz
TI 1.9 Hz
TIM 3.0 Hz
IC 0.4 Hz

savefig(gifpath()+'_rast.png') # [[./gif/23nov17_23nov17_BBN_A0_rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, totalDur)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, totalDur)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((0,25))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov17_23nov17_BBN_A0_spikehistG.png]]

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov17_BBN_A0/23nov17_BBN_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov17_23nov17_BBN_A0_CSD__CSD_overlay_a2.png]]

might be a little better overall, with better source/sink in supragranular layers too? and more spiking
activity in supragranular layers ... 

check CSD waveforms ... 

python -i simdat.py 23nov17_BBN_A0

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-50,50))
xlim((0,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov17_23nov17_BBN_A0_CSD_a4.png]]

bbnT = np.arange(3000, 4000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov17_23nov17_BBN_A0_model_BBN_avg_ERP_CSD_a5.png]]

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))

ttnhpERP = np.linspace(0,150,len(d['avgCSD'][0]))

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k]/np.sum(d['avgCSD'][k]),clr,linewidth=4)

savefig('gif/23nov17_model_nhp_CSD_ERP_avg_a7.png') # [[./gif/23nov17_model_nhp_CSD_ERP_avg_a7.png]]

hmm, this granular ERP looks strange ... very different from the one in eneuro paper
figure 2 ... better check

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k],clr,linewidth=4)

savefig('gif/23nov17_model_nhp_CSD_ERP_avg_a8.png') # [[./gif/23nov17_model_nhp_CSD_ERP_avg_a8.png]]

better fix up for optimization ... 

or it's correct ... ? 

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]): plot(ttnhpERP,d['avgCSD'][k],clr,linewidth=4)

savefig('gif/23nov17_model_nhp_CSD_ERP_avg_a9.png') # [[./gif/23nov17_model_nhp_CSD_ERP_avg_a9.png]]

pearsonr(d['avgCSD'][g], avgERP[10,:]) # (-0.5064748860367594, 3.1186792894376994e-195)

hmm ... that's not a good fit and not same as in batch run that JC ran ... will compare against his data

** email no

From what I mentioned at today's meeting, here's the latest output
that was aiming to optimize the granular waveform. The optimization
didn't get far enough ... still fixing up/debugging the code.

Just to confirm - supragranular layer CSD has inverse pattern of
sources/sinks compared to NHP?

Best,
Sam

attachments:
 [[./gif/23nov17_23nov17_BBN_A0_CSD__CSD_overlay_a2.png]]
 [[./gif/23nov17_23nov17_BBN_A0_rast.png]]

* 23nov20
** output data info from jc - check reason for discrepancy from edge output

https://drive.google.com/file/d/1dMs66PNrLCE28Xg_wFdq5qZ6pojaVTfG/view?usp=drive_web

saved untarred into data/trial45/

data/trial45/trial_45.run shows different rates from that obtained on NKI edge computer
with presumably same parameters ... 

have these values in trial_45_cfg.json :

        "thalL4E": 1.9540886147587417,
        "thalL4PV": 0.21367245896786016,
        "thalL4SOM": 0.24260966747847523,
        "thalamoCorticalGain": 2.1111391118965863,

        "ICThalMatrixCoreFactor": 0.12084663297800038,
        "ICThalprobECore": 0.163484173596043,
        "ICThalprobEMatrix": 0.19,
        "ICThalprobICore": 0.0936669688856933,
        "ICThalprobIMatrix": 0.12,
        "ICThalweightECore": 0.8350476447841453,
        "ICThalweightEMatrix": 0.1,
        "ICThalweightICore": 0.2114492149101151,
        "ICThalweightIMatrix": 0.025,


 {'ICThalweightECore': 0.8350476447841453, 'ICThalweightICore': 0.2114492149101151, 'ICThalprobECore': 0.163484173596043, 
  'ICThalprobICore': 0.0936669688856933, 'ICThalMatrixCoreFactor': 0.12084663297800038, 
  'thalL4PV': 0.21367245896786016, 'thalL4SOM': 0.24260966747847523, 'thalL4E': 1.9540886147587417}

note that these parameters:
 ICThalweightEMatrix and ICThalweightIMatrix
are not set properly ... they are set based on initial values
as so:
 cfg.ICThalweightEMatrix = cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
 cfg.ICThalweightIMatrix = cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor
and not updated after cfg.ICThalweightECore, cfg.ICThalMatrixCoreFactor get updated by optimizer ... 

that might be at least part of the reason why get a difference from what jc ran ... 

will try with the values used by jc and compare ...

with these set explicitly as:
        "ICThalweightEMatrix": 0.1,
        "ICThalweightIMatrix": 0.025,

*** 23nov20_BBN_A0

test same params as before but hold
cfg.ICThalweightEMatrix = 0.1 # cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalweightIMatrix = 0.025 # cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor

for comparison with jc output ...

./myrun 48

  Simulated time: 5.0 s; 48 workers
  Run time: 2245.11 s
   NGF1 : 1.210 Hz
   IT2 : 1.333 Hz
   SOM2 : 2.480 Hz
   PV2 : 18.677 Hz
   VIP2 : 16.488 Hz
   NGF2 : 16.660 Hz
   IT3 : 0.226 Hz
   SOM3 : 8.641 Hz
   PV3 : 29.040 Hz
   VIP3 : 54.747 Hz
   NGF3 : 8.312 Hz
   ITP4 : 2.443 Hz
   ITS4 : 2.138 Hz
   SOM4 : 17.774 Hz
   PV4 : 6.611 Hz
   VIP4 : 24.923 Hz
   NGF4 : 14.814 Hz
   IT5A : 1.887 Hz
   CT5A : 1.978 Hz
   SOM5A : 16.410 Hz
   PV5A : 3.208 Hz
   VIP5A : 19.867 Hz
   NGF5A : 18.850 Hz
   IT5B : 7.866 Hz
   CT5B : 0.969 Hz
   PT5B : 0.155 Hz
   SOM5B : 33.178 Hz
   PV5B : 1.082 Hz
   VIP5B : 10.863 Hz
   NGF5B : 16.575 Hz
   IT6 : 3.040 Hz
   CT6 : 2.925 Hz
   SOM6 : 79.498 Hz
   PV6 : 0.145 Hz
   VIP6 : 2.909 Hz
   NGF6 : 173.679 Hz
   TC : 7.648 Hz
   TCM : 5.929 Hz
   HTC : 6.351 Hz
   IRE : 3.858 Hz
   IREM : 3.467 Hz
   TI : 2.000 Hz
   TIM : 2.852 Hz
   IC : 2.326 Hz

hmm, the rates are still more similar to previous sim on edge than the sim that jc ran on dmc hpc

* 23nov21
** output from last run (23nov20_BBN_A0)

python -i simdat.py 23nov20_BBN_A0

NGF1 1.64 Hz
IT2 0.35 Hz
SOM2 0.8 Hz
PV2 26.38 Hz
VIP2 39.56 Hz
NGF2 12.18 Hz
IT3 0.02 Hz
SOM3 0.0 Hz
PV3 19.51 Hz
VIP3 56.47 Hz
NGF3 7.3 Hz
ITP4 1.78 Hz
ITS4 1.69 Hz
SOM4 5.25 Hz
PV4 8.23 Hz
VIP4 16.08 Hz
NGF4 17.36 Hz
IT5A 1.29 Hz
CT5A 1.74 Hz
SOM5A 5.37 Hz
PV5A 4.73 Hz
VIP5A 38.0 Hz
NGF5A 22.0 Hz
IT5B 6.38 Hz
CT5B 0.9 Hz
PT5B 0.13 Hz
SOM5B 19.79 Hz
PV5B 1.46 Hz
VIP5B 23.94 Hz
NGF5B 19.62 Hz
IT6 1.17 Hz
CT6 1.92 Hz
SOM6 61.95 Hz
PV6 0.0 Hz
VIP6 0.67 Hz
NGF6 128.18 Hz
TC 6.43 Hz
TCM 5.19 Hz
HTC 4.32 Hz
IRE 3.74 Hz
IREM 3.3 Hz
TI 2.08 Hz
TIM 3.04 Hz
IC 0.4 Hz

savefig(gifpath()+'_rast.png') # [[./gif/23nov21_23nov20_BBN_A0_rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, totalDur)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, totalDur)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((0,25))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov21_23nov20_BBN_A0_spikehistG.png]]

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov20_BBN_A0/23nov20_BBN_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov21_23nov20_BBN_A0_CSD__CSD_overlay_a2.png]]

looks similar to previous ... but not similar to what jc got seen in data/trial45/gen_45/trial_45.run
note the firing rates from jc trial 45 are very different:
   NGF1 : 1.465 Hz
   IT2 : 0.571 Hz
   SOM2 : 9.946 Hz
   PV2 : 10.769 Hz
   VIP2 : 12.990 Hz
   NGF2 : 18.649 Hz
   IT3 : 0.038 Hz
   SOM3 : 4.418 Hz
   PV3 : 30.578 Hz
   VIP3 : 58.826 Hz
   NGF3 : 7.628 Hz
   ITP4 : 1.674 Hz
   ITS4 : 1.614 Hz
   SOM4 : 6.381 Hz
   PV4 : 8.684 Hz
   VIP4 : 45.925 Hz
   NGF4 : 15.212 Hz
   IT5A : 2.137 Hz
   CT5A : 2.879 Hz
   SOM5A : 12.349 Hz
   PV5A : 5.544 Hz
   VIP5A : 9.670 Hz
   NGF5A : 23.007 Hz
   IT5B : 9.052 Hz
   CT5B : 2.670 Hz
   PT5B : 0.264 Hz
   SOM5B : 31.158 Hz
   PV5B : 0.907 Hz
   VIP5B : 7.652 Hz
   NGF5B : 20.698 Hz
   IT6 : 1.058 Hz
   CT6 : 2.629 Hz
   SOM6 : 81.989 Hz
   PV6 : 0.000 Hz
   VIP6 : 1.007 Hz
   NGF6 : 180.306 Hz
   TC : 10.026 Hz
   TCM : 6.590 Hz
   HTC : 10.168 Hz
   IRE : 4.189 Hz
   IREM : 3.353 Hz
   TI : 2.178 Hz
   TIM : 2.995 Hz
   IC : 3.034 Hz

** made a github bug report issue for optuna/mpiexec problem

https://github.com/suny-downstate-medical-center/netpyne/issues/797

** back to fixing opt -- use quit call at end of sim and jc's updated optuna_parallel.py

mpiexec -n 48 nrniv -python -mpi init.py simConfig=/home/samn/A1/data/optunaERP_23nov13_/gen_0/trial_0_cfg.json netParams=/home/samn/A1/data/optunaERP_23nov13_/optunaERP_23nov13__netParams.py

mpiexec -n 48 python init.py simConfig=/home/samn/A1/data/optunaERP_23nov13_/gen_0/trial_0_cfg.json netParams=/home/samn/A1/data/optunaERP_23nov13_/optunaERP_23nov13__netParams.py

seems to run within batch if use a quit() in the first call to nrniv, since the processes were asleep ... 

*** discuss

sn: weird...the nrniv w/o mpiexec was going to sleep too
but when i put quit at the end of it then the mpiexec nrniv jobs seem to start
    jobString = f"""#!/bin/bash
    echo '{paramLabels}'
    echo '{candidate}'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id())'
    echo $?
    
    {command}    
    """
including the real simulations starting afterwards with {command}
so looks like i'll be able to run the optimization here on my hpc ... not sure how that impacts netpyne fix more generally. about the other cfg question for variable init, any suggestion?

jc: I would move that calculation into the netParams script --> since the cfg is loaded as a json cannot handle calculations whereas netParams script is duplicated as a .py

sn: well, in the opt, it seems to hang after first simulation job has run and saved its output (node data not deleted though)
this should work ... if sim.rank == 0: quit()
jc:  Its very interesting-- seems like without explicit termination, the nrniv sim just "holds" onto all resources
sn: yeah...but doesn't happen to everyone for some reason
jc:  But for whatever reason the OS on our machines has a more aggressive resource controller
samn: someone in netpyne channel mentioned having to call quit() in init.py too (which didn't help in my case)
might be good to put a note out for people having the issue

** move ICThalweightEMatrix, ICThalweightIMatrix from cfg.py to netParams.py since derived variables

        # these next two parameters are derived, so should be set here in case used by batch/optimization; because cfg.py
        # gets copied as a .json file without re-interpreting the other variables
        cfg.ICThalInput['weightEMatrix'] = cfg.ICThalInput['weightECore'] * cfg.ICThalInput['MatrixCoreFactor']
        cfg.ICThalInput['weightIMatrix'] = cfg.ICThalInput['weightICore'] * cfg.ICThalInput['MatrixCoreFactor']        

** check batch optuna again

python batch.py

ok, starts

* 23nov27
** check optunaERP

got up to generation 51 and then stopped running further

--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2023-11-23 07:50:57,568] Trial 50 finished with value: 0.4563950058140542 and parameters: {'ICThalweightECore': 1.0047767680295816, 'ICThalweightICore': 0.20314132760330628, 'ICThalprobECore': 0.1987543176869942, 'ICThalprobICore': 0.13053252854790076, 'ICThalMatrixCoreFactor': 0.1033840095586608, 'thalL4PV': 0.2864475043974267, 'thalL4SOM': 0.25735206374600267, 'thalL4E': 1.731640678069453}. Best is trial 5 with value: -0.21006259709685773.
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.104974142821265, 0.2539959156218882, 0.19462225517664392, 0.13338951980951447, 0.09105126037040462, 0.2717127478436534, 0.2582557702882284, 2.0897230037818404]
set ICThalweightECore=1.104974142821265
set ICThalweightICore=0.2539959156218882
set ICThalprobECore=0.19462225517664392
set ICThalprobICore=0.13338951980951447
set ICThalMatrixCoreFactor=0.09105126037040462
set thalL4PV=0.2717127478436534
set thalL4SOM=0.2582557702882284
set thalL4E=2.0897230037818404
Saving simConfig to data/optunaERP_23nov21_/gen_51/trial_51_cfg.json ... 
Submitting job  trial_51
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[1.104974142821265, 0.2539959156218882, 0.19462225517664392, 0.13338951980951447, 0.09105126037040462, 0.2717127478436534, 0.2582557702882284, 2.0897230037818404]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23nov21_/gen_51/trial_51_cfg.json netParams=data/optunaERP_23nov21_/optunaERP_23nov21__netParams.py     
    
--------------------------------------------------------------------------------

that was a few days ago, why did it get stuck there? 

will kill opt and hopefully it will run from where it left off ...

temporarily put this into batch.py:
    b.batchLabel = 'optunaERP_'+'23nov21_' # getdatestr()

so that continues from where left off ... 

python batch.py

running batch...
in run for optuna
Saving batch to data/optunaERP_23nov21_/optunaERP_23nov21__batch.json ... 
[I 2023-11-27 09:13:05,485] Using an existing study with name 'optunaERP_23nov21_' instead of creating a new one.
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.101935773969861, 0.3031092352999408, 0.1958504072709164, 0.12638798015958952, 0.09060738180236011, 0.27885465181966196, 0.267133518190499, 2.078163229635472]
set ICThalweightECore=1.101935773969861
set ICThalweightICore=0.3031092352999408
set ICThalprobECore=0.1958504072709164
set ICThalprobICore=0.12638798015958952
set ICThalMatrixCoreFactor=0.09060738180236011
set thalL4PV=0.27885465181966196
set thalL4SOM=0.267133518190499
set thalL4E=2.078163229635472
Saving simConfig to data/optunaERP_23nov21_/gen_52/trial_52_cfg.json ... 
Submitting job  trial_52
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[1.101935773969861, 0.3031092352999408, 0.1958504072709164, 0.12638798015958952, 0.09060738180236011, 0.27885465181966196, 0.267133518190499, 2.078163229635472]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23nov21_/gen_52/trial_52_cfg.json netParams=data/optunaERP_23nov21_/optunaERP_23nov21__netParams.py     
    
--------------------------------------------------------------------------------


* 23nov29
** optunaERP up to ~gen 100 this morning

fitness func
[[-2.08166817e-17 -2.77555756e-17 -2.08166817e-17 ...  5.42101086e-21
  -1.10114283e-21 -6.35274710e-23]]
fitness is 0.45962189940735276
--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2023-11-29 06:51:01,693] Trial 99 finished with value: 0.45962189940735276 and parameters: {'ICThalweightECore': 1.0861941796520829, 'ICThalweightICore': 0.18874486368990995, 'ICThalprobECore': 0.1897906229979512, 'ICThalprobICore': 0.12977219274157129, 'ICThalMatrixCoreFactor': 0.09524017363313124, 'thalL4PV': 0.2811418225884781, 'thalL4SOM': 0.27696744725544914, 'thalL4E': 1.9747914055554519}. Best is trial 5 with value: -0.21006259709685773.
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.109631086747637, 0.22663363998253527, 0.1973836582263519, 0.1360738450162457, 0.09205427178614739, 0.2849403038214461, 0.28150874145621796, 1.8734366318256528]

best so far is generation 5 ... 

* 23dec1
** up to ~gen 159 this afternoon

best so far is now trial 152

fitness is -0.30631775152229357
--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2023-12-01 03:15:35,160] Trial 152 finished with value: -0.30631775152229357 and parameters: {'ICThalweightECore': 1.0592777928271448, 'ICThalweightICore': 0.3010148972169486, 'ICThalprobECore': 0.2084546581359147, 'ICThalprobICore': 0.13607374047392148, 'ICThalMatrixCoreFactor': 0.08942165875855669, 'thalL4PV': 0.2761551780556245, 'thalL4SOM': 0.2881416409955241, 'thalL4E': 2.1000452762590345}. Best is trial 152 with value: -0.30631775152229357.
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.0597320466919644, 0.3038336985665273, 0.2081198719486322, 0.1363473946772622, 0.08524021086743791, 0.27724870840628973, 0.28870709608733475, 1.8875935068404976]

* 23dec7
** check output -->> not great, ERP waveforms not good enough, and neuronal firing rates get too high

best so far is still trial 152, and now optunaERP is over 300 iterations ... it's still going ... maybe since
got interrupted and then continued, will go to ~350 generations ...

output db is sql lite database ... should store parameters and fitness, but nothing else
can instrument the fitness function to store more information, including ERP

https://docs.python.org/3/library/sqlite3.html

python
import sqlite3
con = sqlite3.connect("data/optunaERP_23nov21_/optunaERP_23nov21__storage.db")
cur = con.cursor()
x = cur.fetchall()

# Getting all tables from sqlite_master
sql_query = """SELECT name FROM sqlite_master  WHERE type='table';"""

res = cur.execute("SELECT * FROM sqlite_master")

res = cur.execute(sql_query)
print(cur.fetchall()) #
 [('studies',), ('version_info',), ('study_directions',), ('study_user_attributes',), ('study_system_attributes',), ('trials',), ('trial_user_attributes',), ('trial_system_attributes',), ('trial_params',), ('trial_values',), ('trial_intermediate_values',), ('trial_heartbeats',), ('alembic_version',)]

sqq = """SELECT * from trial_values;"""
res=cur.execute(sqq)
x = cur.fetchall()
# print(cur.fetchall())

>>> x[0]
(1, 1, 0, 0.4399730235814988, 'FINITE')
>>> x[1]
(2, 2, 0, 0.4567614068318504, 'FINITE')
>>> x[2]
(3, 3, 0, 0.2539277571966818, 'FINITE')
>>> x[151]
(152, 153, 0, -0.30631775152229357, 'FINITE')

lfit = [X[3] for X in x]

from pylab import *
ion()
plot(lfit,'b'); plot(lfit,'bo')
xlabel('Trial'); ylabel('Fitness (-r)')

savefig('gif/23dec7_optunaERP_output_fitness_trial_a0.png') # [[./gif/23dec7_optunaERP_output_fitness_trial_a0.png]]

no clear pattern of progress ... best occurs at generation 152 ... 

con.close()

easier to use optuna functions for loading/displaying study ... 

https://optuna.readthedocs.io/en/stable/reference/generated/optuna.load_study.html

import optuna
from optuna.visualization import plot_optimization_history

loaded_study = optuna.load_study(study_name=None, storage="sqlite:///data/optunaERP_23nov21_/optunaERP_23nov21__storage.db")
[I 2023-12-07 07:37:00,083] Study name was omitted but trying to load 'optunaERP_23nov21_' because that was the only study found in the storage.

plotly_config = {"staticPlot": True}
fig = plot_optimization_history(loaded_study)
fig.show(config=plotly_config)

[[./gif/23dec7_optunaERP_opthistory_a1.png]]   <<-- best case shows quick improvement, with some further improvement as progresses ... 

may as well contineu to the end and possibly longer ... 

other good tut on optuna: https://www.kaggle.com/code/bextuychiev/no-bs-guide-to-hyperparameter-tuning-with-optuna

from optuna.visualization import plot_param_importances
fig = plot_param_importances(loaded_study)
fig.show()

[[./gif/23dec7_optunaERP_paramimportance_a2.png]] 
interesting, shows importance of specific params to the fitness ... looks like ICThalprobECore, ICThalMatrixCoreFactor,
and ICThalweightECore are most important params, followed by thalL4E, thalL4SOM, ICThalprobICore, ICThalweightICore, and thalL4PV ... 

dir(optuna.visualization)

fig = optuna.visualization.plot_timeline(loaded_study); fig.show()
[[./gif/23dec7_optunaERP_timeline_a3.png]] <- just shows progress of optimization

fig = optuna.visualization.plot_intermediate_values(loaded_study); fig.show() # useless for this opt
fig = optuna.visualization.plot_contour(loaded_study); fig.show() # 

fig = optuna.visualization.plot_rank(loaded_study); fig.show() # interesting & interactive in the browser, allows seeing
any param value of a trial 
[[./gif/23dec7_optunaERP_rank_a4.png]]

dir(loaded_study)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_ask', '_directions', '_get_trials', '_is_multi_objective', '_log_completed_trial', '_pop_waiting_trial_id', '_should_skip_enqueue', '_stop_flag', '_storage', '_study_id', '_tell', '_thread_local', 'add_trial', 'add_trials', 'ask', 'best_params', 'best_trial', 'best_trials', 'best_value', 'direction', 'directions', 'enqueue_trial', 'get_trials', 'metric_names', 'optimize', 'pruner', 'sampler', 'set_metric_names', 'set_system_attr', 'set_user_attr', 'stop', 'study_name', 'system_attrs', 'tell', 'trials', 'trials_dataframe', 'user_attrs']

study = loaded_study
study.best_value # -0.30631775152229357
study.best_trial # FrozenTrial(number=152, state=TrialState.COMPLETE, values=[-0.30631775152229357], datetime_start=datetime.datetime(2023, 12, 1, 2, 25, 29, 7805), datetime_complete=datetime.datetime(2023, 12, 1, 3, 15, 35, 149729), params={'ICThalweightECore': 1.0592777928271448, 'ICThalweightICore': 0.3010148972169486, 'ICThalprobECore': 0.2084546581359147, 'ICThalprobICore': 0.13607374047392148, 'ICThalMatrixCoreFactor': 0.08942165875855669, 'thalL4PV': 0.2761551780556245, 'thalL4SOM': 0.2881416409955241, 'thalL4E': 2.1000452762590345}, user_attrs={}, system_attrs={}, intermediate_values={}, distributions={'ICThalweightECore': FloatDistribution(high=1.25, log=False, low=0.75, step=None), 'ICThalweightICore': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'ICThalprobECore': FloatDistribution(high=0.2375, log=False, low=0.1425, step=None), 'ICThalprobICore': FloatDistribution(high=0.15, log=False, low=0.09, step=None), 'ICThalMatrixCoreFactor': FloatDistribution(high=0.125, log=False, low=0.075, step=None), 'thalL4PV': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'thalL4SOM': FloatDistribution(high=0.3125, log=False, low=0.1875, step=None), 'thalL4E': FloatDistribution(high=2.5, log=False, low=1.5, step=None)}, trial_id=153, value=None)
study.best_params # {'ICThalweightECore': 1.0592777928271448, 'ICThalweightICore': 0.3010148972169486, 'ICThalprobECore': 0.2084546581359147, 'ICThalprobICore': 0.13607374047392148, 'ICThalMatrixCoreFactor': 0.08942165875855669, 'thalL4PV': 0.2761551780556245, 'thalL4SOM': 0.2881416409955241, 'thalL4E': 2.1000452762590345}

should run best params ... see how they look in ~8s sim ... 

can stop optimization temporarily, and then continue afterwards ... 

ok, set these params based on best from optunaERP:
# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 1.0592777928271448 # 0.8350476447841453 # 1.0
cfg.ICThalweightICore = 0.3010148972169486 # 0.2114492149101151 # 0.25
cfg.ICThalprobECore = 0.2084546581359147 # 0.163484173596043 # 0.19
cfg.ICThalprobICore = 0.13607374047392148 # 0.0936669688856933 # 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.08942165875855669 # 0.1 # this is used to scale weights to thalamic matrix neurons in netParams.py
cfg.ICThalprobEMatrix = cfg.ICThalprobECore 
cfg.ICThalprobIMatrix = cfg.ICThalprobICore 


# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.2761551780556245 # 0.21367245896786016 # 0.25 
cfg.thalL4SOM = 0.2881416409955241 # 0.24260966747847523 # 0.25 
cfg.thalL4E = 2.1000452762590345 # 1.9540886147587417 # 2.0 

and set duration to 11e3 ... 

with BBN 'startTime': list(np.arange(4000, 8000, 300))

simLabel is 23dec7_BBN_A0

./myrun 48

10.9s
  Done; run time = 5221.34 s; real-time ratio: 0.00.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 1088396 (7.55 Hz)
  Simulated time: 11.0 s; 48 workers
  Run time: 5221.34 s
   NGF1 : 1.430 Hz
   IT2 : 0.178 Hz
   SOM2 : 0.727 Hz
   PV2 : 3.797 Hz
   VIP2 : 4.239 Hz
   NGF2 : 30.800 Hz
   IT3 : 0.104 Hz
   SOM3 : 2.316 Hz
   PV3 : 71.996 Hz
   VIP3 : 78.865 Hz
   NGF3 : 11.356 Hz
   ITP4 : 1.471 Hz
   ITS4 : 1.378 Hz
   SOM4 : 5.213 Hz
   PV4 : 12.898 Hz
   VIP4 : 42.322 Hz
   NGF4 : 16.558 Hz
   IT5A : 1.052 Hz
   CT5A : 10.420 Hz
   SOM5A : 20.574 Hz
   PV5A : 7.965 Hz
   VIP5A : 9.444 Hz
   NGF5A : 57.943 Hz
   IT5B : 11.578 Hz
   CT5B : 13.707 Hz
   PT5B : 1.445 Hz
   SOM5B : 66.454 Hz
   PV5B : 0.873 Hz
   VIP5B : 7.500 Hz
   NGF5B : 44.742 Hz
   IT6 : 6.163 Hz
   CT6 : 8.833 Hz
   SOM6 : 33.723 Hz
   PV6 : 0.038 Hz
   VIP6 : 0.099 Hz
   NGF6 : 288.450 Hz
   TC : 27.009 Hz
   TCM : 10.540 Hz
   HTC : 18.830 Hz
   IRE : 9.511 Hz
   IREM : 1.760 Hz
   TI : 3.185 Hz
   TIM : 2.989 Hz
   IC : 3.701 Hz
Saving output as data/23dec7_BBN_A0/23dec7_BBN_A0_data.pkl ... 
Finished saving!
  Done; saving time = 169.95 s.

python -i simdat.py 23dec7_BBN_A0

NGF1 1.42 Hz
IT2 0.09 Hz
SOM2 0.48 Hz
PV2 3.81 Hz
VIP2 4.15 Hz
NGF2 27.48 Hz
IT3 0.0 Hz
SOM3 1.47 Hz
PV3 70.84 Hz
VIP3 78.32 Hz
NGF3 10.78 Hz
ITP4 1.36 Hz
ITS4 1.27 Hz
SOM4 4.67 Hz
PV4 12.63 Hz
VIP4 42.6 Hz
NGF4 16.05 Hz
IT5A 0.96 Hz
CT5A 10.36 Hz
SOM5A 19.55 Hz
PV5A 7.85 Hz
VIP5A 8.51 Hz
NGF5A 58.66 Hz
IT5B 11.57 Hz
CT5B 13.68 Hz
PT5B 1.45 Hz
SOM5B 64.97 Hz
PV5B 0.78 Hz
VIP5B 7.04 Hz
NGF5B 45.01 Hz
IT6 5.63 Hz
CT6 8.58 Hz
SOM6 31.71 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 292.62 Hz
TC 26.68 Hz
TCM 10.54 Hz
HTC 18.53 Hz
IRE 9.42 Hz
IREM 1.71 Hz
TI 3.18 Hz
TIM 2.99 Hz
IC 3.69 Hz

should also check firing rates during spontaneous state ... 

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec7_23dec7_BBN_A0_rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, totalDur)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, totalDur)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((0,25))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23dec7_23dec7_BBN_A0_spikehistG.png]]

many of the firing rates are now too high ... ? 

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23dec7_BBN_A0/23dec7_BBN_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # 

def gifpath(): return 'gif/23dec7_23dec7_BBN_A0'
savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23dec7_23dec7_BBN_A0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[2e3,10e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/23dec7_23dec7_BBN_A0_CSD__CSD_overlay_a3.png]]

python -i simdat.py 23dec7_BBN_A0

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-50,50))
xlim((0,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23dec7_23dec7_BBN_A0_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23dec7_23dec7_BBN_A0_model_BBN_avg_ERP_CSD_a5.png]]

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))

ttnhpERP = np.linspace(0,150,len(d['avgCSD'][0]))

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k]/np.sum(d['avgCSD'][k]),clr,linewidth=4)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/np.sum(avgERP[chan,:]),clr)
  gdx+=1


savefig(gifpath()+'_model_nhp_CSD_ERP_avg_a7.png') # [[./gif/23dec7_23dec7_BBN_A0_model_nhp_CSD_ERP_avg_a7.png]]

not looking too great ... 

** email no

Here's the latest version after running L4 ERP optimization for a while. I don't think the results are as good as what I sent previously, especially since baseline firing rates are now way too high. Note that BBN stimulation occurs between 4-8 s.

Sam 

attachments: 
  [[./gif/23dec7_23dec7_BBN_A0_rast.png]]
  [[./gif/23dec7_23dec7_BBN_A0_model_BBN_avg_ERP_CSD_a5.png]]
  [[./gif/23dec7_23dec7_BBN_A0_CSD_a4.png]]

* 23dec8 - need to adjust optimization, EE,EI pop-specific gain control
** adjustments to optimization 

take into account neuronal firing rates as additional constraint - weight ERP fitness and firing rates as
contributors to overall fitness - problem there is the two can pull optimization in different directions

looks like optuna supports multiobjective optimization:
 https://optuna.readthedocs.io/en/stable/tutorial/20_recipes/002_multi_objective.html

may want to include additional corticothalamic TRN top-down weight/probability as parameter to
prevent runaway excitation

for firing rates, can use baseline period - prior to BBN stimulation - as constraint
on firing rates. so need to run simulation of initial network

** baseline simulation; measure firing rates of all pops from 2-4 s (23dec8_Rate_A0)

ok, put back these params as had them before:
# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.8350476447841453 # 1.0
cfg.ICThalweightICore = 0.2114492149101151 # 0.25
cfg.ICThalprobECore = 0.163484173596043 # 0.19
cfg.ICThalprobICore = 0.0936669688856933 # 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.1 # this is used to scale weights to thalamic matrix neurons in netParams.py
cfg.ICThalprobEMatrix = cfg.ICThalprobECore 
cfg.ICThalprobIMatrix = cfg.ICThalprobICore 

# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.21367245896786016 # 0.25 
cfg.thalL4SOM = 0.24260966747847523 # 0.25 
cfg.thalL4E = 1.9540886147587417 # 2.0 

set duration to 5 s ... will only use period from 2-4 s to constrain firing rates later on

./myrun 48

  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 296102 (4.52 Hz)
  Simulated time: 5.0 s; 48 workers
  Run time: 2227.12 s
   NGF1 : 1.131 Hz
   IT2 : 1.555 Hz
   SOM2 : 7.040 Hz
   PV2 : 27.508 Hz
   VIP2 : 13.275 Hz
   NGF2 : 17.900 Hz
   IT3 : 0.229 Hz
   SOM3 : 8.678 Hz
   PV3 : 29.880 Hz
   VIP3 : 55.090 Hz
   NGF3 : 8.566 Hz
   ITP4 : 2.634 Hz
   ITS4 : 2.254 Hz
   SOM4 : 21.035 Hz
   PV4 : 5.846 Hz
   VIP4 : 20.723 Hz
   NGF4 : 14.771 Hz
   IT5A : 2.173 Hz
   CT5A : 1.794 Hz
   SOM5A : 18.010 Hz
   PV5A : 2.969 Hz
   VIP5A : 21.244 Hz
   NGF5A : 18.775 Hz
   IT5B : 8.039 Hz
   CT5B : 0.804 Hz
   PT5B : 0.144 Hz
   SOM5B : 33.734 Hz
   PV5B : 1.023 Hz
   VIP5B : 11.162 Hz
   NGF5B : 16.033 Hz
   IT6 : 3.171 Hz
   CT6 : 3.088 Hz
   SOM6 : 80.561 Hz
   PV6 : 0.145 Hz
   VIP6 : 4.109 Hz
   NGF6 : 176.695 Hz
   TC : 7.117 Hz
   TCM : 5.758 Hz
   HTC : 6.249 Hz
   IRE : 4.134 Hz
   IREM : 3.614 Hz
   TI : 1.924 Hz
   TIM : 2.796 Hz
   IC : 2.245 Hz
Saving output as data/23dec8_Rate_A0/23dec8_Rate_A0_data.pkl ... 
Finished saving!
  Done; saving time = 154.73 s.

python -i simdat.py 23dec8_Rate_A0

NGF1 1.4 Hz
IT2 0.84 Hz
SOM2 11.6 Hz
PV2 39.77 Hz
VIP2 16.5 Hz
NGF2 15.91 Hz
IT3 0.02 Hz
SOM3 0.16 Hz
PV3 26.91 Hz
VIP3 62.42 Hz
NGF3 8.37 Hz
ITP4 2.09 Hz
ITS4 1.83 Hz
SOM4 9.92 Hz
PV4 8.12 Hz
VIP4 22.0 Hz
NGF4 16.79 Hz
IT5A 2.29 Hz
CT5A 2.51 Hz
SOM5A 9.02 Hz
PV5A 4.1 Hz
VIP5A 25.2 Hz
NGF5A 29.12 Hz
IT5B 8.34 Hz
CT5B 1.69 Hz
PT5B 0.22 Hz
SOM5B 28.16 Hz
PV5B 1.04 Hz
VIP5B 10.71 Hz
NGF5B 23.96 Hz
IT6 2.03 Hz
CT6 2.63 Hz
SOM6 72.73 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 167.63 Hz
TC 9.43 Hz
TCM 4.59 Hz
HTC 7.74 Hz
IRE 6.47 Hz
IREM 4.32 Hz
TI 1.18 Hz
TIM 2.43 Hz
IC 10.95 Hz

savefig(gifpath()+'_rast.png') # [[./gif/23dec8_23dec8_Rate_A0_rast.png]]

firing rates very non-uniform

check ~rate of each population between 2-4 s ... 

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}

drate # 
{'NGF1': 1.62, 'IT2': 0.57, 'SOM2': 7.1, 'PV2': 26.88, 'VIP2': 23.94, 'NGF2': 16.64, 'IT3': 0.02, 'SOM3': 0.01, 'PV3': 22.82, 'VIP3': 58.41, 'NGF3': 7.48, 'ITP4': 2.12, 'ITS4': 1.83, 'SOM4': 10.35, 'PV4': 5.92, 'VIP4': 23.92, 'NGF4': 16.75, 'IT5A': 1.68, 'CT5A': 1.59, 'SOM5A': 8.34, 'PV5A': 3.99, 'VIP5A': 33.25, 'NGF5A': 24.75, 'IT5B': 8.12, 'CT5B': 0.47, 'PT5B': 0.13, 'SOM5B': 21.38, 'PV5B': 1.41, 'VIP5B': 19.94, 'NGF5B': 20.04, 'IT6': 0.99, 'CT6': 2.23, 'SOM6': 65.87, 'PV6': 0.0, 'VIP6': 8.92, 'NGF6': 136.08, 'TC': 5.5, 'TCM': 6.42, 'HTC': 5.05, 'IRE': 3.3, 'IREM': 3.42, 'TI': 2.02, 'TIM': 2.92, 'IC': 0.0}

can use some variant of this drate in optimization later on ... 

hmm, IT5B is already at an overly elevated firing rate ... ~8Hz ... may want to push it down a bit during the next optimization ... rather
than maintaining it at this elevated level ... 

IT5B probably got to such a high rate since gains from L2 and L4 E neurons -> IT5B were probably high due to previously
lower firing rates of IT2, ITP4, ITS4 ... 

simConfig['simConfig']['thalL4E'] # 1.9540886147587417
scfg = simConfig['simConfig']

scfg['EELayerGain'] # {1: 1.0, 2: 1.1392556114489, 3: 0.2627680775261009, 4: 0.7953549349740079, 5A: 1.107062263790829, 5B: 0.1873673565713772, 6: 1.2260292755940738}

** add post-synaptic population specific EE, EI gain control for the cortical E,I neurons

# E -> E based on postsynaptic cortical E neuron population
cfg.EEPopGain = {'IT2': 1.0, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 1.0, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}

and then in this rule:
#------------------------------------------------------------------------------
## E -> E
if cfg.addConn and cfg.EEGain > 0.0:
    for pre in Epops:
        for post in Epops:
            for l in layerGainLabels:  # used to tune each layer group independently
                if connDataSource['E->E/I'] in ['Allen_V1', 'Allen_custom']:
                    prob = '%f * exp(-dist_2D/%f)' % (pmat[pre][post], lmat[pre][post])
                else:
                    prob = pmat[pre][post]
                netParams.connParams['EE_'+pre+'_'+post+'_'+l] = { 
                    'preConds': {'pop': pre}, 
                    'postConds': {'pop': post, 'ynorm': layer[l]},
                    'synMech': ESynMech,
                    'probability': prob,
                    'weight': wmat[pre][post] * cfg.EEGain * cfg.EELayerGain[l] * cfg.EEPopGain[post], 
                    'synMechWeightFactor': cfg.synWeightFractionEE,
                    'delay': 'defaultDelay+dist_3D/propVelocity',
                    'synsPerConn': 1,
                    'sec': 'dend_all'}

will first manually tweak down CT5B EETypeGain ... 

and also this for EI Gain based on postsynaptic cortical I population

# gains from E -> I based on postsynaptic cortical I neuron population
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.0, 'VIP5A': 1.0, 'NGF5A': 1.0, 'SOM5B': 1.0, 'PV5B': 1.0, 'VIP5B': 1.0, 'NGF5B': 1.0, 'SOM6': 1.0, 'PV6': 1.0, 'VIP6': 1.0, 'NGF6': 1.0}

with this:

#------------------------------------------------------------------------------
## E -> I       ## MODIFIED FOR NMDAR MANIPULATION!! 
if cfg.addConn and cfg.EIGain > 0.0:
    for pre in Epops:
        for post in Ipops:
            for postType in Itypes:
                if postType in post: # only create rule if celltype matches pop
                    for l in layerGainLabels:  # used to tune each layer group independently
                        if connDataSource['E->E/I'] in ['Allen_V1', 'Allen_custom']:
                            prob = '%f * exp(-dist_2D/%f)' % (pmat[pre][post], lmat[pre][post])
                        else:
                            prob = pmat[pre][post]
                        
                        if 'NGF' in post:
                            synWeightFactor = cfg.synWeightFractionENGF
                        else:
                            synWeightFactor = cfg.synWeightFractionEI #cfg.synWeightFractionEI_CustomCort  #cfg.synWeightFractionEI
                        netParams.connParams['EI_'+pre+'_'+post+'_'+postType+'_'+l] = { 
                            'preConds': {'pop': pre}, 
                            'postConds': {'pop': post, 'cellType': postType, 'ynorm': layer[l]},
                            'synMech': ESynMech,
                            'probability': prob,
                            'weight': wmat[pre][post] * cfg.EIGain * cfg.EICellTypeGain[postType] * cfg.EILayerGain[l] * cfg.EIPopGain[post], 
                            'synMechWeightFactor': synWeightFactor,
                            'delay': 'defaultDelay+dist_3D/propVelocity',
                            'synsPerConn': 1,
                            'sec': 'proximal'}
                
** try down-tweaking IT5B rate manually (23dec8_Rate_A1)

down the IT5B gain by 10%
cfg.EEPopGain = {'IT2': 1.0, 'IT3': 1.0, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.9, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}

./myrun 48 

  Simulated time: 5.0 s; 48 workers
  Run time: 2229.03 s
   NGF1 : 1.102 Hz
   IT2 : 1.718 Hz
   SOM2 : 4.160 Hz
   PV2 : 10.292 Hz
   VIP2 : 7.963 Hz
   NGF2 : 17.960 Hz
   IT3 : 0.223 Hz
   SOM3 : 9.649 Hz
   PV3 : 32.717 Hz
   VIP3 : 56.826 Hz
   NGF3 : 8.611 Hz
   ITP4 : 2.729 Hz
   ITS4 : 2.346 Hz
   SOM4 : 22.922 Hz
   PV4 : 5.947 Hz
   VIP4 : 23.954 Hz
   NGF4 : 14.857 Hz
   IT5A : 1.989 Hz
   CT5A : 2.265 Hz
   SOM5A : 19.024 Hz
   PV5A : 2.922 Hz
   VIP5A : 15.356 Hz
   NGF5A : 19.100 Hz
   IT5B : 7.584 Hz
   CT5B : 1.134 Hz
   PT5B : 0.199 Hz
   SOM5B : 35.980 Hz
   PV5B : 0.829 Hz
   VIP5B : 8.512 Hz
   NGF5B : 16.008 Hz
   IT6 : 3.007 Hz
   CT6 : 3.146 Hz
   SOM6 : 83.052 Hz
   PV6 : 0.145 Hz
   VIP6 : 2.255 Hz
   NGF6 : 185.200 Hz
   TC : 8.021 Hz
   TCM : 5.970 Hz
   HTC : 6.881 Hz
   IRE : 3.826 Hz
   IREM : 3.214 Hz
   TI : 2.212 Hz
   TIM : 2.968 Hz
   IC : 2.245 Hz

IT5B a little lower now ... 

python -i simdat.py 23dec8_Rate_A1

savefig(gifpath()+'_rast.png') # [[./gif/23dec8_23dec8_Rate_A1_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 1.65, 'IT2': 0.29, 'SOM2': 2.3, 'PV2': 9.5, 'VIP2': 16.44, 'NGF2': 18.32, 'IT3': 0.01, 'SOM3': 0.01, 'PV3': 26.79, 'VIP3': 65.83, 'NGF3': 7.94, 'ITP4': 2.19, 'ITS4': 1.88, 'SOM4': 11.65, 'PV4': 5.79, 'VIP4': 26.12, 'NGF4': 16.5, 'IT5A': 1.96, 'CT5A': 2.47, 'SOM5A': 10.08, 'PV5A': 3.63, 'VIP5A': 25.6, 'NGF5A': 27.06, 'IT5B': 9.0, 'CT5B': 0.91, 'PT5B': 0.19, 'SOM5B': 24.52, 'PV5B': 0.99, 'VIP5B': 17.38, 'NGF5B': 22.02, 'IT6': 1.15, 'CT6': 2.42, 'SOM6': 71.68, 'PV6': 0.0, 'VIP6': 4.67, 'NGF6': 161.62, 'TC': 6.57, 'TCM': 6.77, 'HTC': 6.11, 'IRE': 3.16, 'IREM': 3.55, 'TI': 1.97, 'TIM': 2.85, 'IC': 0.0}

HMM, actually IT5B is a little higher rate now during the 2-4 s interval ...

try even lower for IT5B -- 0.8

23dec8_Rate_A2

./myrun 48

  Simulated time: 5.0 s; 48 workers
  Run time: 2233.36 s
   NGF1 : 1.024 Hz
   IT2 : 1.897 Hz
   SOM2 : 5.680 Hz
   PV2 : 16.338 Hz
   VIP2 : 11.463 Hz
   NGF2 : 16.940 Hz
   IT3 : 0.222 Hz
   SOM3 : 10.220 Hz
   PV3 : 31.328 Hz
   VIP3 : 55.036 Hz
   NGF3 : 8.521 Hz
   ITP4 : 2.810 Hz
   ITS4 : 2.434 Hz
   SOM4 : 24.765 Hz
   PV4 : 5.782 Hz
   VIP4 : 21.785 Hz
   NGF4 : 14.743 Hz
   IT5A : 2.091 Hz
   CT5A : 2.036 Hz
   SOM5A : 19.705 Hz
   PV5A : 2.508 Hz
   VIP5A : 13.778 Hz
   NGF5A : 16.600 Hz
   IT5B : 6.692 Hz
   CT5B : 0.953 Hz
   PT5B : 0.165 Hz
   SOM5B : 36.640 Hz
   PV5B : 0.700 Hz
   VIP5B : 7.088 Hz
   NGF5B : 13.917 Hz
   IT6 : 2.841 Hz
   CT6 : 3.126 Hz
   SOM6 : 79.469 Hz
   PV6 : 0.145 Hz
   VIP6 : 1.564 Hz
   NGF6 : 172.589 Hz
   TC : 7.519 Hz
   TCM : 5.661 Hz
   HTC : 6.573 Hz
   IRE : 3.833 Hz
   IREM : 3.046 Hz
   TI : 2.336 Hz
   TIM : 2.976 Hz
   IC : 2.245 Hz
Saving output as data/23dec8_Rate_A2/23dec8_Rate_A2_data.pkl ... 

a bit better for IT5B ...

python -i simdat.py 23dec8_Rate_A2

** multi-phase optimization

iterate on these phases:
 phase 1: optimize ERP waveforms
 phase 2: tweak firing rates ... can use a simple homeostatic rule:
          if population firing rate is above (below) target, reduce (increase) the population E gain by a small fraction (~1%)
 
phase 2 could be done from within batch.py , load the data, then save tweaks for population gains to file and
have cfg.py or netParams.py load it ... 

that way optuna only cares about a single objective and the firing rate opt can be a post-simulation adaptation

* 23dec11
** check output from 23dec8_Rate_A2, adjust for lower baseline firing rates for IT5B

python -i simdat.py 23dec8_Rate_A2

NGF1 1.55 Hz
IT2 0.1 Hz
SOM2 0.6 Hz
PV2 5.46 Hz
VIP2 12.25 Hz
NGF2 13.18 Hz
IT3 0.0 Hz
SOM3 0.0 Hz
PV3 30.73 Hz
VIP3 67.17 Hz
NGF3 7.86 Hz
ITP4 1.57 Hz
ITS4 1.62 Hz
SOM4 3.96 Hz
PV4 8.96 Hz
VIP4 42.77 Hz
NGF4 17.07 Hz
IT5A 1.46 Hz
CT5A 4.35 Hz
SOM5A 7.14 Hz
PV5A 4.51 Hz
VIP5A 16.7 Hz
NGF5A 33.12 Hz
IT5B 8.68 Hz
CT5B 2.65 Hz
PT5B 0.34 Hz
SOM5B 29.78 Hz
PV5B 0.67 Hz
VIP5B 3.47 Hz
NGF5B 26.21 Hz
IT6 1.51 Hz
CT6 2.43 Hz
SOM6 78.11 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 185.11 Hz
TC 11.56 Hz
TCM 6.06 Hz
HTC 8.95 Hz
IRE 5.56 Hz
IREM 3.3 Hz
TI 1.84 Hz
TIM 2.67 Hz
IC 10.95 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec8_Rate_A2_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 1.55, 'IT2': 0.34, 'SOM2': 2.9, 'PV2': 13.81, 'VIP2': 21.47, 'NGF2': 18.09, 'IT3': 0.01, 'SOM3': 0.01, 'PV3': 25.19, 'VIP3': 65.09, 'NGF3': 7.96, 'ITP4': 2.11, 'ITS4': 1.86, 'SOM4': 12.08, 'PV4': 5.5, 'VIP4': 23.46, 'NGF4': 16.21, 'IT5A': 2.56, 'CT5A': 2.18, 'SOM5A': 11.76, 'PV5A': 2.73, 'VIP5A': 20.7, 'NGF5A': 21.69, 'IT5B': 9.06, 'CT5B': 0.64, 'PT5B': 0.16, 'SOM5B': 26.37, 'PV5B': 0.79, 'VIP5B': 13.91, 'NGF5B': 17.71, 'IT6': 0.83, 'CT6': 2.34, 'SOM6': 67.88, 'PV6': 0.0, 'VIP6': 3.08, 'NGF6': 146.05, 'TC': 5.93, 'TCM': 6.55, 'HTC': 5.66, 'IRE': 3.0, 'IREM': 3.65, 'TI': 2.01, 'TIM': 2.87, 'IC': 0.0}

drate['IT5B'] # 9.06

may as well just run for 4 s while adjusting weights to IT5B ... 

23dec11_Rate_A3

cfg.EEPopGain = {'IT2': 1.0, 'IT3': 1.0, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.5, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}

./myrun 48

   NGF1 : 0.493 Hz
   IT2 : 2.728 Hz
   SOM2 : 7.050 Hz
   PV2 : 21.808 Hz
   VIP2 : 0.688 Hz
   NGF2 : 18.500 Hz
   IT3 : 0.274 Hz
   SOM3 : 13.732 Hz
   PV3 : 35.760 Hz
   VIP3 : 54.492 Hz
   NGF3 : 9.002 Hz
   ITP4 : 3.671 Hz
   ITS4 : 3.084 Hz
   SOM4 : 41.652 Hz
   PV4 : 3.170 Hz
   VIP4 : 8.827 Hz
   NGF4 : 12.107 Hz
   IT5A : 2.904 Hz
   CT5A : 1.429 Hz
   SOM5A : 28.482 Hz
   PV5A : 0.618 Hz
   VIP5A : 1.389 Hz
   NGF5A : 6.125 Hz
   IT5B : 4.224 Hz
   CT5B : 0.431 Hz
   PT5B : 0.141 Hz
   SOM5B : 44.511 Hz
   PV5B : 0.294 Hz
   VIP5B : 0.547 Hz
   NGF5B : 4.531 Hz
   IT6 : 3.049 Hz
   CT6 : 3.784 Hz
   SOM6 : 80.385 Hz
   PV6 : 0.178 Hz
   VIP6 : 0.273 Hz
   NGF6 : 175.270 Hz
   TC : 6.257 Hz
   TCM : 5.155 Hz
   HTC : 5.791 Hz
   IRE : 3.620 Hz
   IREM : 2.247 Hz
   TI : 3.040 Hz
   TIM : 3.480 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A3

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A3_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 0.83, 'IT2': 0.41, 'SOM2': 4.4, 'PV2': 18.81, 'VIP2': 0.38, 'NGF2': 21.55, 'IT3': 0.0, 'SOM3': 0.07, 'PV3': 34.58, 'VIP3': 74.27, 'NGF3': 8.97, 'ITP4': 3.01, 'ITS4': 2.66, 'SOM4': 32.44, 'PV4': 2.05, 'VIP4': 8.15, 'NGF4': 12.64, 'IT5A': 4.32, 'CT5A': 2.24, 'SOM5A': 22.99, 'PV5A': 0.03, 'VIP5A': 0.8, 'NGF5A': 9.31, 'IT5B': 7.69, 'CT5B': 0.49, 'PT5B': 0.21, 'SOM5B': 39.79, 'PV5B': 0.0, 'VIP5B': 0.0, 'NGF5B': 5.38, 'IT6': 0.74, 'CT6': 3.26, 'SOM6': 74.17, 'PV6': 0.0, 'VIP6': 0.0, 'NGF6': 170.57, 'TC': 6.09, 'TCM': 6.29, 'HTC': 5.68, 'IRE': 3.44, 'IREM': 2.97, 'TI': 2.66, 'TIM': 3.27, 'IC': 0.0}

drate['IT5B'] # 7.69

IT3 now at 0, PV5A, PV5B, VIP5A, VIP5B, PV6, VIP6 are all too low, 

so increase those 

and NGF6 too high ...

so decrease that one ...

23dec11_Rate_A4
cfg.EEPopGain = {'IT2': 1.0, 'IT3': 1.25, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.5, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.25, 'VIP5A': 1.25, 'NGF5A': 1.0, 'SOM5B': 1.0, 'PV5B': 1.25, 'VIP5B': 1.25, 'NGF5B': 1.0, 'SOM6': 1.0, 'PV6': 1.25, 'VIP6': 1.25, 'NGF6': 0.75}

./myrun 48

  Spikes: 241795 (4.61 Hz)
  Simulated time: 4.0 s; 48 workers
  Run time: 1737.34 s
   NGF1 : 0.537 Hz
   IT2 : 1.458 Hz
   SOM2 : 14.700 Hz
   PV2 : 31.923 Hz
   VIP2 : 1.031 Hz
   NGF2 : 23.075 Hz
   IT3 : 0.559 Hz
   SOM3 : 13.685 Hz
   PV3 : 39.515 Hz
   VIP3 : 51.758 Hz
   NGF3 : 10.247 Hz
   ITP4 : 3.186 Hz
   ITS4 : 2.724 Hz
   SOM4 : 32.989 Hz
   PV4 : 3.635 Hz
   VIP4 : 9.519 Hz
   NGF4 : 13.429 Hz
   IT5A : 2.996 Hz
   CT5A : 1.238 Hz
   SOM5A : 28.464 Hz
   PV5A : 1.069 Hz
   VIP5A : 3.750 Hz
   NGF5A : 4.781 Hz
   IT5B : 4.329 Hz
   CT5B : 0.315 Hz
   PT5B : 0.166 Hz
   SOM5B : 44.429 Hz
   PV5B : 0.545 Hz
   VIP5B : 0.609 Hz
   NGF5B : 3.448 Hz
   IT6 : 3.126 Hz
   CT6 : 3.812 Hz
   SOM6 : 85.672 Hz
   PV6 : 0.208 Hz
   VIP6 : 1.568 Hz
   NGF6 : 143.539 Hz
   TC : 6.115 Hz
   TCM : 4.842 Hz
   HTC : 5.716 Hz
   IRE : 3.748 Hz
   IREM : 2.444 Hz
   TI : 2.760 Hz
   TIM : 3.220 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A4

NGF1 1.12 Hz
IT2 0.23 Hz
SOM2 1.8 Hz
PV2 13.54 Hz
VIP2 0.75 Hz
NGF2 21.36 Hz
IT3 0.01 Hz
SOM3 0.03 Hz
PV3 35.92 Hz
VIP3 74.32 Hz
NGF3 9.12 Hz
ITP4 2.77 Hz
ITS4 2.49 Hz
SOM4 27.92 Hz
PV4 2.02 Hz
VIP4 4.85 Hz
NGF4 11.71 Hz
IT5A 3.81 Hz
CT5A 3.0 Hz
SOM5A 23.21 Hz
PV5A 0.64 Hz
VIP5A 4.0 Hz
NGF5A 10.5 Hz
IT5B 9.52 Hz
CT5B 0.65 Hz
PT5B 0.24 Hz
SOM5B 40.22 Hz
PV5B 0.04 Hz
VIP5B 0.0 Hz
NGF5B 5.71 Hz
IT6 1.26 Hz
CT6 3.57 Hz
SOM6 87.57 Hz
PV6 0.0 Hz
VIP6 2.75 Hz
NGF6 150.47 Hz
TC 6.49 Hz
TCM 6.41 Hz
HTC 6.32 Hz
IRE 3.68 Hz
IREM 3.59 Hz
TI 2.31 Hz
TIM 2.8 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A4_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 0.79, 'IT2': 0.48, 'SOM2': 6.8, 'PV2': 21.12, 'VIP2': 0.44, 'NGF2': 21.64, 'IT3': 0.01, 'SOM3': 0.07, 'PV3': 35.57, 'VIP3': 72.12, 'NGF3': 9.0, 'ITP4': 3.11, 'ITS4': 2.74, 'SOM4': 34.29, 'PV4': 1.91, 'VIP4': 2.46, 'NGF4': 12.5, 'IT5A': 4.08, 'CT5A': 1.89, 'SOM5A': 23.91, 'PV5A': 0.32, 'VIP5A': 2.05, 'NGF5A': 6.81, 'IT5B': 7.37, 'CT5B': 0.39, 'PT5B': 0.24, 'SOM5B': 40.85, 'PV5B': 0.02, 'VIP5B': 0.0, 'NGF5B': 3.42, 'IT6': 1.17, 'CT6': 3.77, 'SOM6': 84.9, 'PV6': 0.0, 'VIP6': 1.38, 'NGF6': 140.62, 'TC': 6.18, 'TCM': 5.9, 'HTC': 5.84, 'IRE': 3.53, 'IREM': 2.92, 'TI': 2.64, 'TIM': 3.18, 'IC': 0.0}

drate['IT3'] # 0.01
drate['IT5B'] # 7.37
drate['PV5A'] # 0.32
drate['PV5B'] # 0.02
drate['VIP5A'] # 2.05
drate['VIP5B'] # 0.0
drate['NGF5A'] # 6.81
drate['NGF5B'] # 3.42
drate['PV6'] # 0.0
drate['VIP6'] # 1.38
drate['NGF6'] # 140.62

still need more adjustment ... 

23dec11_Rate_A5

cfg.EEPopGain = {'IT2': 1.0, 'IT3': 1.5, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.25, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.5, 'VIP5A': 1.5, 'NGF5A': 1.0, 'SOM5B': 1.0, 'PV5B': 1.5, 'VIP5B': 1.5, 'NGF5B': 1.0, 'SOM6': 1.0, 'PV6': 1.5, 'VIP6': 1.5, 'NGF6': 0.5}

./myrun 48

  Run time: 1732.79 s
   NGF1 : 0.883 Hz
   IT2 : 1.338 Hz
   SOM2 : 20.800 Hz
   PV2 : 5.808 Hz
   VIP2 : 6.531 Hz
   NGF2 : 14.200 Hz
   IT3 : 0.758 Hz
   SOM3 : 16.580 Hz
   PV3 : 22.669 Hz
   VIP3 : 9.221 Hz
   NGF3 : 7.760 Hz
   ITP4 : 1.192 Hz
   ITS4 : 1.112 Hz
   SOM4 : 7.750 Hz
   PV4 : 2.635 Hz
   VIP4 : 9.750 Hz
   NGF4 : 10.607 Hz
   IT5A : 0.528 Hz
   CT5A : 0.258 Hz
   SOM5A : 16.077 Hz
   PV5A : 0.997 Hz
   VIP5A : 2.194 Hz
   NGF5A : 1.969 Hz
   IT5B : 0.149 Hz
   CT5B : 0.069 Hz
   PT5B : 0.033 Hz
   SOM5B : 30.259 Hz
   PV5B : 0.555 Hz
   VIP5B : 0.938 Hz
   NGF5B : 1.885 Hz
   IT6 : 2.429 Hz
   CT6 : 1.326 Hz
   SOM6 : 29.529 Hz
   PV6 : 55.801 Hz
   VIP6 : 73.386 Hz
   NGF6 : 42.908 Hz
   TC : 5.088 Hz
   TCM : 3.421 Hz
   HTC : 4.784 Hz
   IRE : 2.817 Hz
   IREM : 2.299 Hz
   TI : 2.455 Hz
   TIM : 3.325 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A5

NGF1 1.61 Hz
IT2 0.04 Hz
SOM2 12.0 Hz
PV2 4.46 Hz
VIP2 11.56 Hz
NGF2 5.82 Hz
IT3 0.13 Hz
SOM3 0.06 Hz
PV3 3.05 Hz
VIP3 9.36 Hz
NGF3 4.64 Hz
ITP4 0.52 Hz
ITS4 0.62 Hz
SOM4 1.62 Hz
PV4 0.0 Hz
VIP4 1.08 Hz
NGF4 6.29 Hz
IT5A 0.3 Hz
CT5A 0.0 Hz
SOM5A 2.3 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 1.62 Hz
IT5B 0.36 Hz
CT5B 0.0 Hz
PT5B 0.03 Hz
SOM5B 14.29 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 0.62 Hz
IT6 0.04 Hz
CT6 0.19 Hz
SOM6 0.08 Hz
PV6 95.1 Hz
VIP6 102.5 Hz
NGF6 6.29 Hz
TC 3.86 Hz
TCM 3.94 Hz
HTC 4.03 Hz
IRE 2.12 Hz
IREM 2.28 Hz
TI 2.67 Hz
TIM 3.57 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A5_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 1.41, 'IT2': 0.07, 'SOM2': 18.1, 'PV2': 5.0, 'VIP2': 10.72, 'NGF2': 6.82, 'IT3': 0.15, 'SOM3': 0.06, 'PV3': 3.12, 'VIP3': 9.23, 'NGF3': 4.78, 'ITP4': 0.63, 'ITS4': 0.66, 'SOM4': 1.73, 'PV4': 0.04, 'VIP4': 1.96, 'NGF4': 7.64, 'IT5A': 0.35, 'CT5A': 0.0, 'SOM5A': 2.85, 'PV5A': 0.0, 'VIP5A': 0.1, 'NGF5A': 1.56, 'IT5B': 0.23, 'CT5B': 0.0, 'PT5B': 0.03, 'SOM5B': 15.62, 'PV5B': 0.0, 'VIP5B': 0.03, 'NGF5B': 0.52, 'IT6': 0.03, 'CT6': 0.2, 'SOM6': 0.12, 'PV6': 87.82, 'VIP6': 106.5, 'NGF6': 5.79, 'TC': 3.69, 'TCM': 3.54, 'HTC': 3.54, 'IRE': 2.42, 'IREM': 2.47, 'TI': 2.35, 'TIM': 3.39, 'IC': 0.0}

drate['IT3'] # 0.15
drate['IT5B'] # 0.23
drate['PV5A'] # 0.0
drate['PV5B'] # 0.0
drate['VIP5A'] # 0.1
drate['VIP5B'] # 0.03
drate['NGF5A'] # 1.56
drate['NGF5B'] # 0.52
drate['PV6'] # 87.82
drate['VIP6'] # 106.5
drate['NGF6'] # 5.79

some better, some worse ... readjust ... 

with IT5B now ~0, the other L5B pops are quiet

and now interneurons in L6 took opposite patterns (NGF6 slower, others much too fast)

23dec11_Rate_A6

cfg.EEPopGain = {'IT2': 1.5, 'IT3': 1.5, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.375, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.25, 'VIP5A': 1.25, 'NGF5A': 0.75, 'SOM5B': 1.0, 'PV5B': 1.25, 'VIP5B': 1.25, 'NGF5B': 0.75, 'SOM6': 1.0, 'PV6': 1.25, 'VIP6': 1.25, 'NGF6': 0.75}

./myrun 48

   NGF1 : 0.403 Hz
   IT2 : 5.970 Hz
   SOM2 : 48.450 Hz
   PV2 : 7.462 Hz
   VIP2 : 2.062 Hz
   NGF2 : 17.875 Hz
   IT3 : 0.371 Hz
   SOM3 : 13.609 Hz
   PV3 : 34.818 Hz
   VIP3 : 22.036 Hz
   NGF3 : 8.573 Hz
   ITP4 : 2.498 Hz
   ITS4 : 2.025 Hz
   SOM4 : 26.457 Hz
   PV4 : 2.382 Hz
   VIP4 : 4.731 Hz
   NGF4 : 11.018 Hz
   IT5A : 2.889 Hz
   CT5A : 0.298 Hz
   SOM5A : 26.595 Hz
   PV5A : 0.667 Hz
   VIP5A : 3.861 Hz
   NGF5A : 1.031 Hz
   IT5B : 1.262 Hz
   CT5B : 0.128 Hz
   PT5B : 0.104 Hz
   SOM5B : 40.452 Hz
   PV5B : 0.494 Hz
   VIP5B : 0.781 Hz
   NGF5B : 1.333 Hz
   IT6 : 2.746 Hz
   CT6 : 2.942 Hz
   SOM6 : 66.463 Hz
   PV6 : 0.208 Hz
   VIP6 : 8.295 Hz
   NGF6 : 98.408 Hz
   TC : 4.912 Hz
   TCM : 3.762 Hz
   HTC : 4.500 Hz
   IRE : 3.694 Hz
   IREM : 1.949 Hz
   TI : 2.935 Hz
   TIM : 3.545 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A6

NGF1 0.54 Hz
IT2 6.19 Hz
SOM2 98.2 Hz
PV2 0.0 Hz
VIP2 1.56 Hz
NGF2 16.18 Hz
IT3 0.03 Hz
SOM3 4.17 Hz
PV3 32.59 Hz
VIP3 22.99 Hz
NGF3 7.52 Hz
ITP4 2.39 Hz
ITS4 1.93 Hz
SOM4 28.46 Hz
PV4 0.41 Hz
VIP4 0.15 Hz
NGF4 8.5 Hz
IT5A 3.38 Hz
CT5A 0.05 Hz
SOM5A 25.77 Hz
PV5A 0.0 Hz
VIP5A 2.6 Hz
NGF5A 0.12 Hz
IT5B 2.79 Hz
CT5B 0.02 Hz
PT5B 0.12 Hz
SOM5B 37.84 Hz
PV5B 0.0 Hz
VIP5B 0.12 Hz
NGF5B 0.0 Hz
IT6 0.55 Hz
CT6 2.78 Hz
SOM6 57.51 Hz
PV6 0.0 Hz
VIP6 12.75 Hz
NGF6 76.55 Hz
TC 4.14 Hz
TCM 4.33 Hz
HTC 4.79 Hz
IRE 3.68 Hz
IREM 2.3 Hz
TI 2.98 Hz
TIM 3.65 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A6_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 0.51, 'IT2': 5.69, 'SOM2': 86.8, 'PV2': 0.0, 'VIP2': 2.72, 'NGF2': 16.59, 'IT3': 0.03, 'SOM3': 2.68, 'PV3': 32.68, 'VIP3': 27.29, 'NGF3': 7.65, 'ITP4': 2.36, 'ITS4': 1.89, 'SOM4': 25.15, 'PV4': 0.97, 'VIP4': 0.38, 'NGF4': 11.11, 'IT5A': 3.72, 'CT5A': 0.07, 'SOM5A': 24.07, 'PV5A': 0.0, 'VIP5A': 2.65, 'NGF5A': 0.31, 'IT5B': 2.25, 'CT5B': 0.02, 'PT5B': 0.14, 'SOM5B': 37.3, 'PV5B': 0.0, 'VIP5B': 0.21, 'NGF5B': 0.02, 'IT6': 0.55, 'CT6': 2.76, 'SOM6': 58.33, 'PV6': 0.0, 'VIP6': 11.67, 'NGF6': 74.74, 'TC': 4.17, 'TCM': 4.04, 'HTC': 3.93, 'IRE': 3.63, 'IREM': 2.03, 'TI': 2.97, 'TIM': 3.67, 'IC': 0.0}

drate['IT2'] # 5.69
drate['IT3'] # 0.03
drate['IT5B'] # 2.25
drate['PV5A'] # 0.0
drate['PV5B'] # 0.0
drate['VIP5A'] # 2.65
drate['VIP5B'] # 0.21
drate['NGF5A'] # 0.31
drate['NGF5B'] # 0.02
drate['PV6'] # 0.0
drate['VIP6'] # 11.67
drate['NGF6'] # 74.74

again, some better, and some worse ... now IT2 too active and IT3 too silent

will apply some more adjustments ...

23dec11_Rate_A7

cfg.EEPopGain = {'IT2': 1.375, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.0, 'IT5B': 0.375, 'CT5B': 1.0, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.375, 'VIP5A': 1.25, 'NGF5A': 0.75, 'SOM5B': 1.0, 'PV5B': 1.375, 'VIP5B': 1.375, 'NGF5B': 0.875, 'SOM6': 1.0, 'PV6': 1.375, 'VIP6': 1.25, 'NGF6': 0.7}

./myrun 48

  Run time: 1735.04 s
   NGF1 : 0.277 Hz
   IT2 : 6.260 Hz
   SOM2 : 54.600 Hz
   PV2 : 15.288 Hz
   VIP2 : 1.438 Hz
   NGF2 : 16.475 Hz
   IT3 : 0.461 Hz
   SOM3 : 19.156 Hz
   PV3 : 34.234 Hz
   VIP3 : 18.079 Hz
   NGF3 : 8.384 Hz
   ITP4 : 2.737 Hz
   ITS4 : 2.210 Hz
   SOM4 : 30.522 Hz
   PV4 : 2.404 Hz
   VIP4 : 5.404 Hz
   NGF4 : 11.571 Hz
   IT5A : 2.212 Hz
   CT5A : 0.276 Hz
   SOM5A : 28.851 Hz
   PV5A : 0.771 Hz
   VIP5A : 3.583 Hz
   NGF5A : 0.875 Hz
   IT5B : 1.081 Hz
   CT5B : 0.086 Hz
   PT5B : 0.088 Hz
   SOM5B : 43.099 Hz
   PV5B : 0.545 Hz
   VIP5B : 1.109 Hz
   NGF5B : 1.427 Hz
   IT6 : 2.723 Hz
   CT6 : 3.239 Hz
   SOM6 : 69.848 Hz
   PV6 : 0.211 Hz
   VIP6 : 0.341 Hz
   NGF6 : 95.053 Hz
   TC : 5.018 Hz
   TCM : 3.812 Hz
   HTC : 4.716 Hz
   IRE : 3.669 Hz
   IREM : 1.949 Hz
   TI : 2.915 Hz
   TIM : 3.470 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A7

NGF1 0.34 Hz
IT2 8.07 Hz
SOM2 116.0 Hz
PV2 0.0 Hz
VIP2 0.5 Hz
NGF2 12.09 Hz
IT3 0.11 Hz
SOM3 14.6 Hz
PV3 31.95 Hz
VIP3 15.79 Hz
NGF3 7.1 Hz
ITP4 2.76 Hz
ITS4 2.21 Hz
SOM4 34.42 Hz
PV4 0.57 Hz
VIP4 0.62 Hz
NGF4 10.07 Hz
IT5A 2.43 Hz
CT5A 0.03 Hz
SOM5A 29.51 Hz
PV5A 0.0 Hz
VIP5A 1.9 Hz
NGF5A 0.0 Hz
IT5B 2.81 Hz
CT5B 0.01 Hz
PT5B 0.11 Hz
SOM5B 43.55 Hz
PV5B 0.0 Hz
VIP5B 0.29 Hz
NGF5B 0.0 Hz
IT6 0.7 Hz
CT6 3.16 Hz
SOM6 63.98 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 79.16 Hz
TC 4.65 Hz
TCM 4.48 Hz
HTC 4.58 Hz
IRE 3.59 Hz
IREM 2.33 Hz
TI 2.92 Hz
TIM 3.47 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A7_rast.png]]

drate = {pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()}
{'NGF1': 0.34, 'IT2': 6.55, 'SOM2': 101.5, 'PV2': 4.12, 'VIP2': 1.31, 'NGF2': 14.45, 'IT3': 0.09, 'SOM3': 8.67, 'PV3': 32.25, 'VIP3': 22.35, 'NGF3': 7.4,  'ITP4': 2.73, 'ITS4': 2.19, 'SOM4': 32.17, 'PV4': 0.78, 'VIP4': 0.31, 'NGF4': 11.39, 'IT5A': 2.98, 'CT5A': 0.04, 'SOM5A': 26.83, 'PV5A': 0.0, 'VIP5A': 2.7,  'NGF5A': 0.0,  'IT5B': 1.92, 'CT5B': 0.01, 'PT5B': 0.12, 'SOM5B': 40.37, 'PV5B': 0.0, 'VIP5B': 0.59, 'NGF5B': 0.0, 'IT6': 0.58, 'CT6': 3.14, 'SOM6': 62.33, 'PV6': 0.0, 'VIP6': 0.0, 'NGF6': 73.41, 'TC': 4.42, 'TCM': 4.1, 'HTC': 4.29, 'IRE': 3.39, 'IREM': 2.13, 'TI': 2.9, 'TIM': 3.53, 'IC': 0.0}

drate['IT2'] # 6.55
drate['IT3'] # 0.09
drate['IT5B'] # 1.92
drate['PV5A'] # 0.0
drate['PV5B'] # 0.0
drate['VIP5A'] # 2.7
drate['VIP5B'] # 0.59
drate['NGF5A'] # 0.0
drate['NGF5B'] # 0.0
drate['PV6'] # 0.0
drate['VIP6'] # 11.67
drate['NGF6'] # 73.41

IT2, NGF6 too fast ... IT3, PV5A, PV5B, NGF5A, NGF5B, PV6 too slow ... could automate this process later ... 

23dec11_Rate_A8

cfg.EEPopGain = {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1, 'IT5B': 0.375, 'CT5B': 1.1, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.4, 'VIP5B': 1.4, 'NGF5B': 0.9, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.4, 'NGF6': 0.65}

./myrun 48

   NGF1 : 0.303 Hz
   IT2 : 3.240 Hz
   SOM2 : 48.350 Hz
   PV2 : 113.615 Hz
   VIP2 : 0.609 Hz
   NGF2 : 18.850 Hz
   IT3 : 0.507 Hz
   SOM3 : 14.558 Hz
   PV3 : 32.190 Hz
   VIP3 : 37.231 Hz
   NGF3 : 9.303 Hz
   ITP4 : 3.415 Hz
   ITS4 : 2.721 Hz
   SOM4 : 37.870 Hz
   PV4 : 2.706 Hz
   VIP4 : 5.750 Hz
   NGF4 : 11.911 Hz
   IT5A : 2.375 Hz
   CT5A : 0.371 Hz
   SOM5A : 28.905 Hz
   PV5A : 0.955 Hz
   VIP5A : 2.222 Hz
   NGF5A : 1.031 Hz
   IT5B : 1.607 Hz
   CT5B : 0.144 Hz
   PT5B : 0.115 Hz
   SOM5B : 44.583 Hz
   PV5B : 0.536 Hz
   VIP5B : 0.812 Hz
   NGF5B : 1.531 Hz
   IT6 : 2.732 Hz
   CT6 : 4.061 Hz
   SOM6 : 79.746 Hz
   PV6 : 0.211 Hz
   VIP6 : 0.523 Hz
   NGF6 : 105.914 Hz
   TC : 5.626 Hz
   TCM : 4.109 Hz
   HTC : 5.412 Hz
   IRE : 3.747 Hz
   IREM : 1.732 Hz
   TI : 3.315 Hz
   TIM : 3.555 Hz
   IC : 0.000 Hz

python -i simdat.py 23dec11_Rate_A8

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23dec11_23dec11_Rate_A8_rast.png]]

drate = OrderedDict({pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()})
OrderedDict([('NGF1', 0.41), ('IT2', 2.75), ('SOM2', 81.5), ('PV2', 135.96), ('VIP2', 0.06), ('NGF2', 17.09), ('IT3', 0.05), ('SOM3', 1.31), ('PV3', 26.18), ('VIP3', 49.61), ('NGF3', 8.04), ('ITP4', 3.46), ('ITS4', 2.74), ('SOM4', 41.15), ('PV4', 0.88), ('VIP4', 0.0), ('NGF4', 11.04), ('IT5A', 3.24), ('CT5A', 0.2), ('SOM5A', 25.9), ('PV5A', 0.14), ('VIP5A', 1.35), ('NGF5A', 0.12), ('IT5B', 2.7), ('CT5B', 0.05), ('PT5B', 0.15), ('SOM5B', 40.06), ('PV5B', 0.0), ('VIP5B', 0.0), ('NGF5B', 0.04), ('IT6', 0.6), ('CT6', 4.0), ('SOM6', 73.39), ('PV6', 0.0), ('VIP6', 0.0), ('NGF6', 87.2), ('TC', 4.65), ('TCM', 4.36), ('HTC', 4.88), ('IRE', 3.96), ('IREM', 1.85), ('TI', 3.34), ('TIM', 3.54), ('IC', 0.0)])

for k,r in drate.items(): print(k,r)
NGF1 0.41
IT2 2.75
SOM2 81.5     <-- high
PV2 135.96    <-- high
VIP2 0.06     <-- low
NGF2 17.09
IT3 0.05      <-- low
SOM3 1.31
PV3 26.18
VIP3 49.61    <<-- high
NGF3 8.04
ITP4 3.46
ITS4 2.74
SOM4 41.15    <<-- high
PV4 0.88      <<-- low
VIP4 0.0      <<-- low
NGF4 11.04
IT5A 3.24
CT5A 0.2      <<-- low
SOM5A 25.9
PV5A 0.14     <<-- low
VIP5A 1.35
NGF5A 0.12
IT5B 2.7
CT5B 0.05     <<-- low
PT5B 0.15     <<-- low
SOM5B 40.06
PV5B 0.0      <<-- low
VIP5B 0.0     <<-- low
NGF5B 0.04    <<-- low
IT6 0.6       <<-- low
CT6 4.0
SOM6 73.39
PV6 0.0     <<-- low
VIP6 0.0     <<-- low
NGF6 87.2     <<-- high
TC 4.65
TCM 4.36
HTC 4.88
IRE 3.96
IREM 1.85
TI 3.34
TIM 3.54
IC 0.0

some populations better, but many populations are still silent or overactive

could start with these or similar EEPopGain, EIPopGain values, but then automate adjustments after each ERP
optimization step to push up/down the gains to push a population's firing towards target...
rules could be:
  if E or I population fires < 1 Hz during 2-4 s, push up its gain by 5%
  if E fires > 7 Hz push down its gain by 5%
  if I fires > 50 Hz push down its gain by 5%

could also later separate the rate optimization into a separate function ... does not require optuna
since it's a simple homeostatic rule 

* 23dec15
** continue 2-step batch opt setup

save the current EEPopGain, EIPopGain to opt/EEPopGain.pkl and opt/EIPopGain.pkl so that batch
would have something to work with 

python
import pickle
EEPopGain = {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1, 'IT5B': 0.375, 'CT5B': 1.1, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
pickle.dump(EEPopGain,open('opt/EEPopGain.pkl','wb'))
EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.4, 'VIP5B': 1.4, 'NGF5B': 0.9, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.4, 'NGF6': 0.65}
pickle.dump(EIPopGain,open('opt/EIPopGain.pkl','wb'))

if those files do not exist, cfg.py will use the values in cfg.py, otherwise cfg.py will load those values

modified the batch.py code to adjust the EEPopGain, EIPopGain based on population firing rates, and save them to opt/EEPopGain.pkl , opt/EIPopGain.pkl

also modified batch.py to save other output including drate, dgain, fitness + ERP (as dout.pkl), for each iteration, in the batch iteration subfolder

this function in batch.py will adjust the rate gains:

    def adjustRateGain (drate, dgain, gaininc = 0.05, mingain = 0.25, maxgain = 3.0):
      dgain = {'EEGain':pickle.load(open('/opt/EEPopGain.pkl','rb')),
               'EIGain':pickle.load(open('/opt/EIPopGain.pkl','rb'))}
      for pop in drate.keys():
        if isinhib(pop):
          if drate[pop] < 0.5:
            dgain['EIGain'][pop] += gaininc
            if dgain['EIGain'][pop] > maxgain: dgain['EIGain'][pop] = maxgain
          elif drate[pop] > 75.0:
            dgain['EIGain'][pop] -= gaininc
            if dgain['EIGain'][pop] < mingain: dgain['EIGain'][pop] = mingain
        else:
          if drate[pop] < 0.5:
            dgain['EIGain'][pop] += gaininc
            if dgain['EEGain'][pop] > maxgain: dgain['EEGain'][pop] = maxgain
          elif drate[pop] > 8.0:
            dgain['EIGain'][pop] -= gaininc
            if dgain['EEGain'][pop] < mingain: dgain['EEGain'][pop] = mingain
      return dgain

can tweak that rule if it does not work ... 

** try out the 2-phase batch

    b.batchLabel = 'optunaERP_'+'23dec15_' # getdatestr()

python batch.py

running batch...
in run for optuna
Saving batch to data/optunaERP_23dec15_/optunaERP_23dec15__batch.json ... 
 Warning: an exception occurred when running Optuna optimization:
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 277, in run
    optunaOptim(self, pc)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 210, in optunaOptim
    batch.saveScripts()
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 195, in saveScripts
    self.save(targetFile)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 173, in save
    sim.saveJSON(filename, dataSave)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/sim/save.py", line 61, in saveJSON
    str_ = json.dumps(data, indent=4, sort_keys=True, separators=(',', ': '), ensure_ascii=False, cls=NpSerializer)
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/__init__.py", line 238, in dumps
    **kw).encode(obj)
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 201, in encode
    chunks = list(chunks)
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 431, in _iterencode
    yield from _iterencode_dict(o, _current_indent_level)
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 405, in _iterencode_dict
    yield from chunks
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 405, in _iterencode_dict
    yield from chunks
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 405, in _iterencode_dict
    yield from chunks
  [Previous line repeated 1 more time]
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 438, in _iterencode
    o = _default(o)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/sim/utils.py", line 1048, in default
    return super(NpSerializer, self).default(obj)
  File "/opt/miniconda3/envs/py376/lib/python3.7/json/encoder.py", line 179, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Batch is not JSON serializable

fixup by passing in b.cfg.saveFolder ? 

will see if it gets updated properly ... 

python batch.py

Traceback (most recent call last):
  File "batch.py", line 3341, in <module>
    b = optunaERP()
  File "batch.py", line 1259, in optunaERP
    fitnessFuncArgs['saveFolder'] = b.cfg.saveFolder # so can access info from fitness function
AttributeError: 'NoneType' object has no attribute 'saveFolder'

no, cant pass since b not initialized yet ... 

could try a counter that updates on each iteration 

python batch.py

running batch...
in run for optuna
Saving batch to data/optunaERP_23dec15_/optunaERP_23dec15__batch.json ... 
loaded EEPopGain: {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1, 'IT5B': 0.375, 'CT5B': 1.1, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
loaded EIPopGain: {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.4, 'VIP5B': 1.4, 'NGF5B': 0.9, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.4, 'NGF6': 0.65}
[I 2023-12-15 11:57:13,537] A new study created in RDB with name: optunaERP_23dec15_
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [0.9673767416651534, 0.25852631300425866, 0.21003943785323698, 0.10311520469852643, 0.09649357122751051, 0.24195641147862829, 0.25493407320568284, 1.7803975983031903]
set ICThalweightECore=0.9673767416651534
set ICThalweightICore=0.25852631300425866
set ICThalprobECore=0.21003943785323698
set ICThalprobICore=0.10311520469852643
set ICThalMatrixCoreFactor=0.09649357122751051
set thalL4PV=0.24195641147862829
set thalL4SOM=0.25493407320568284
set thalL4E=1.7803975983031903
Saving simConfig to data/optunaERP_23dec15_/gen_0/trial_0_cfg.json ... 
Submitting job  trial_0
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[0.9673767416651534, 0.25852631300425866, 0.21003943785323698, 0.10311520469852643, 0.09649357122751051, 0.24195641147862829, 0.25493407320568284, 1.7803975983031903]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23dec15_/gen_0/trial_0_cfg.json netParams=data/optunaERP_23dec15_/optunaERP_23dec15__netParams.py     
    
--------------------------------------------------------------------------------
subprocess.run returned non-zero exit status. trying to continue.
Waiting for jobs from generation 0/300 ...
fitness func
[[-4.16333634e-18 -1.38777878e-18 -1.38777878e-17 ...  1.52465931e-21
   4.23516474e-22 -5.29395592e-24]]
[W 2023-12-15 12:46:17,651] Trial 0 failed with parameters: {'ICThalweightECore': 0.9673767416651534, 'ICThalweightICore': 0.25852631300425866, 'ICThalprobECore': 0.21003943785323698, 'ICThalprobICore': 0.10311520469852643, 'ICThalMatrixCoreFactor': 0.09649357122751051, 'thalL4PV': 0.24195641147862829, 'thalL4SOM': 0.25493407320568284, 'thalL4E': 1.7803975983031903} because of the following error: ValueError('operands could not be broadcast together with shapes (3000,) (2000,) (3000,) ').
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/study/_optimize.py", line 200, in _run_trial
    value_or_values = func(trial)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 256, in func
    return evaluator(batch, candidate, trial.number, **args)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 173, in evaluator
    fitness = fitnessFunc(simData, **fitnessFuncArgs)
  File "batch.py", line 1239, in fitnessFunc
    ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)
  File "/home/samn/A1/erp.py", line 34, in getAvgERP
    avgERP[chan,:] += dat[chan, sidx:eidx]
ValueError: operands could not be broadcast together with shapes (3000,) (2000,) (3000,) 
[W 2023-12-15 12:46:17,652] Trial 0 failed with value None.
operands could not be broadcast together with shapes (3000,) (2000,) (3000,) 
 Warning: an exception occurred when running Optuna optimization:
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 277, in run
    optunaOptim(self, pc)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 264, in optunaOptim
    importance = optuna.importance.get_param_importances(study=study)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/__init__.py", line 108, in get_param_importances
    res = evaluator.evaluate(study, params=params, target=target)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_fanova/_evaluator.py", line 92, in evaluate
    distributions = _get_distributions(study, params=params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 71, in _get_distributions
    _check_evaluate_args(completed_trials, params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 114, in _check_evaluate_args
    raise ValueError("Cannot evaluate parameter importances without completed trials.")
ValueError: Cannot evaluate parameter importances without completed trials.

hmm, a bug ... 

may have had wrong duration in optunaERP (5000 instead of 5500 in cfg.py)

try again ... 

python batch.py

still some errors:

python batch.py
running batch...
in run for optuna
Saving batch to data/optunaERP_23dec15_/optunaERP_23dec15__batch.json ... 
loaded EEPopGain: {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1, 'IT5B': 0.375, 'CT5B': 1.1, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
loaded EIPopGain: {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.4, 'VIP5B': 1.4, 'NGF5B': 0.9, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.4, 'NGF6': 0.65}
[I 2023-12-16 18:13:29,339] A new study created in RDB with name: optunaERP_23dec15_
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.046110440781173, 0.24181602567590285, 0.22867816674692637, 0.12201871138298867, 0.09395178687665158, 0.22863860300036107, 0.22454285443221417, 1.544051807663807]
set ICThalweightECore=1.046110440781173
set ICThalweightICore=0.24181602567590285
set ICThalprobECore=0.22867816674692637
set ICThalprobICore=0.12201871138298867
set ICThalMatrixCoreFactor=0.09395178687665158
set thalL4PV=0.22863860300036107
set thalL4SOM=0.22454285443221417
set thalL4E=1.544051807663807
Saving simConfig to data/optunaERP_23dec15_/gen_0/trial_0_cfg.json ... 
Submitting job  trial_0
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[1.046110440781173, 0.24181602567590285, 0.22867816674692637, 0.12201871138298867, 0.09395178687665158, 0.22863860300036107, 0.22454285443221417, 1.544051807663807]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23dec15_/gen_0/trial_0_cfg.json netParams=data/optunaERP_23dec15_/optunaERP_23dec15__netParams.py     
    
--------------------------------------------------------------------------------
subprocess.run returned non-zero exit status. trying to continue.
Waiting for jobs from generation 0/300 ...
fitness func
[[ 1.11022302e-17  1.38777878e-18  0.00000000e+00 ... -5.08219768e-22
  -2.54109884e-22  2.11758237e-23]]
fitness is 0.5266326762568756
saveFolder is: data/optunaERP_23dec15_/gen_0
checking firing rates
[W 2023-12-16 19:20:35,430] Trial 0 failed with parameters: {'ICThalweightECore': 1.046110440781173, 'ICThalweightICore': 0.24181602567590285, 'ICThalprobECore': 0.22867816674692637, 'ICThalprobICore': 0.12201871138298867, 'ICThalMatrixCoreFactor': 0.09395178687665158, 'thalL4PV': 0.22863860300036107, 'thalL4SOM': 0.22454285443221417, 'thalL4E': 1.544051807663807} because of the following error: ValueError('invalid __array_struct__').
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/study/_optimize.py", line 200, in _run_trial
    value_or_values = func(trial)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 256, in func
    return evaluator(batch, candidate, trial.number, **args)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 173, in evaluator
    fitness = fitnessFunc(simData, **fitnessFuncArgs)
  File "batch.py", line 1250, in fitnessFunc
    drate = getdrate(simData,tlim=[2e3,4e3])
  File "batch.py", line 1190, in getdrate
    spkID= np.array(simConfig['simData']['spkid'])
ValueError: invalid __array_struct__
[W 2023-12-16 19:20:35,431] Trial 0 failed with value None.
invalid __array_struct__
 Warning: an exception occurred when running Optuna optimization:
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 277, in run
    optunaOptim(self, pc)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 264, in optunaOptim
    importance = optuna.importance.get_param_importances(study=study)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/__init__.py", line 108, in get_param_importances
    res = evaluator.evaluate(study, params=params, target=target)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_fanova/_evaluator.py", line 92, in evaluate
    distributions = _get_distributions(study, params=params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 71, in _get_distributions
    _check_evaluate_args(completed_trials, params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 114, in _check_evaluate_args
    raise ValueError("Cannot evaluate parameter importances without completed trials.")
ValueError: Cannot evaluate parameter importances without completed trials.

* 23dec20
** continue 2-phase batch setup/fixup
* 23dec21
** continue 2-phase batch setup/fixup

sd mentioned can get access to sim.cfg object from batch fitness function 
 via fitnessFuncArgs eg. fitnessFuncArgs["cfg"] = sim.cfg 

will try that ... 

does not work properly unless initialize the sim

python

from netpyne import sim

cfg, netParams = sim.readCmdLineArgs(simConfigDefault='cfg.py', netParamsDefault='netParams.py')
sim.initialize(
    simConfig = cfg, 	
    netParams = netParams)  				# create network object and set cfg and net params
sim.net.createPops()               			# instantiate network populations
sim.net.createCells()              			# instantiate network cells based on defined populations

alltags = sim._gatherAllCellTags()                      # gather cell tags; see https://github.com/Neurosim-lab/netpyne/blob/development/netpyne/sim/gather.py

* 23dec22
** continue 2-phase batch setup/fixup

will save simConfig['net'] to disk so can load it properly from batch
not best way to run the batch in case network changes later ... but
faster to start this way

python -i simdat.py 23dec11_Rate_A8

type(simConfig['net'])

or just save dstartidx, dendidx, dnumc ... much smaller files

dstartidx
{'NGF1': 1, 'IT2': 151, 'SOM2': 489, 'PV2': 494, 'VIP2': 507, 'NGF2': 523, 'IT3': 534, 'SOM3': 4995, 'PV3': 5065, 'VIP3': 5241, 'NGF3': 5452, 'ITP4': 5602, 'ITS4': 6439, 'SOM4': 7276, 'PV4': 7300, 'VIP4': 7393, 'NGF4': 7406, 'IT5A': 7420, 'CT5A': 7779, 'SOM5A': 8138, 'PV5A': 8181, 'VIP5A': 8254, 'NGF5A': 8264, 'IT5B': 8272, 'CT5B': 8743, 'PT5B': 9214, 'SOM5B': 9685, 'PV5B': 9797, 'VIP5B': 9931, 'NGF5B': 9948, 'IT6': 9972, 'CT6': 10981, 'SOM6': 11990, 'PV6': 12053, 'VIP6': 12137, 'NGF6': 12149, 'TC': 12187, 'TCM': 12303, 'HTC': 12458, 'IRE': 12496, 'IREM': 12651, 'TI': 12806, 'TIM': 12857, 'IC': 12908}

dendidx
{'NGF1': 150, 'IT2': 488, 'SOM2': 493, 'PV2': 506, 'VIP2': 522, 'NGF2': 533, 'IT3': 4994, 'SOM3': 5064, 'PV3': 5240, 'VIP3': 5451, 'NGF3': 5601, 'ITP4': 6438, 'ITS4': 7275, 'SOM4': 7299, 'PV4': 7391, 'VIP4': 7405, 'NGF4': 7419, 'IT5A': 7778, 'CT5A': 8137, 'SOM5A': 8180, 'PV5A': 8253, 'VIP5A': 8263, 'NGF5A': 8271, 'IT5B': 8742, 'CT5B': 9213, 'PT5B': 9684, 'SOM5B': 9796, 'PV5B': 9930, 'VIP5B': 9947, 'NGF5B': 9971, 'IT6': 10980, 'CT6': 11989, 'SOM6': 12052, 'PV6': 12136, 'VIP6': 12148, 'NGF6': 12186, 'TC': 12302, 'TCM': 12457, 'HTC': 12495, 'IRE': 12650, 'IREM': 12805, 'TI': 12856, 'TIM': 12907, 'IC': 13107}

dnumc
{'NGF1': 150, 'IT2': 338, 'SOM2': 5, 'PV2': 13, 'VIP2': 16, 'NGF2': 11, 'IT3': 4461, 'SOM3': 70, 'PV3': 176, 'VIP3': 211, 'NGF3': 150, 'ITP4': 837, 'ITS4': 837, 'SOM4': 24, 'PV4': 92, 'VIP4': 13, 'NGF4': 14, 'IT5A': 359, 'CT5A': 359, 'SOM5A': 43, 'PV5A': 73, 'VIP5A': 10, 'NGF5A': 8, 'IT5B': 471, 'CT5B': 471, 'PT5B': 471, 'SOM5B': 112, 'PV5B': 134, 'VIP5B': 17, 'NGF5B': 24, 'IT6': 1009, 'CT6': 1009, 'SOM6': 63, 'PV6': 84, 'VIP6': 12, 'NGF6': 38, 'TC': 116, 'TCM': 155, 'HTC': 38, 'IRE': 155, 'IREM': 155, 'TI': 51, 'TIM': 51, 'IC': 200}
 

pickle.dump(dstartidx,open('opt/dstartidx.pkl','wb'))
pickle.dump(dendidx,open('opt/dendidx.pkl','wb'))
pickle.dump(dnumc,open('opt/dnumc.pkl','wb'))

git add opt/dstartidx.pkl opt/dendidx.pkl opt/dnumc.pkl

git commit -m 'save net/population info for batch.py optunaERP'

ok, try it out ... 

python batch.py

running batch...
in run for optuna
Saving batch to data/optunaERP_23dec22_/optunaERP_23dec22__batch.json ... 
loaded EEPopGain: {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1, 'IT5B': 0.375, 'CT5B': 1.1, 'PT5B': 1.0, 'IT6': 1.0, 'CT6': 1.0}
loaded EIPopGain: {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.4, 'VIP5B': 1.4, 'NGF5B': 0.9, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.4, 'NGF6': 0.65}
[I 2023-12-22 09:46:04,430] A new study created in RDB with name: optunaERP_23dec22_
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.0178117750396865, 0.25326012842665524, 0.21156933840065142, 0.10245955581065115, 0.10670486662869166, 0.2504102934148817, 0.24890260053295996, 1.814555856130986]
set ICThalweightECore=1.0178117750396865
set ICThalweightICore=0.25326012842665524
set ICThalprobECore=0.21156933840065142
set ICThalprobICore=0.10245955581065115
set ICThalMatrixCoreFactor=0.10670486662869166
set thalL4PV=0.2504102934148817
set thalL4SOM=0.24890260053295996
set thalL4E=1.814555856130986
Saving simConfig to data/optunaERP_23dec22_/gen_0/trial_0_cfg.json ... 
Submitting job  trial_0
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[1.0178117750396865, 0.25326012842665524, 0.21156933840065142, 0.10245955581065115, 0.10670486662869166, 0.2504102934148817, 0.24890260053295996, 1.814555856130986]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23dec22_/gen_0/trial_0_cfg.json netParams=data/optunaERP_23dec22_/optunaERP_23dec22__netParams.py     
    
--------------------------------------------------------------------------------
subprocess.run returned non-zero exit status. trying to continue.
Waiting for jobs from generation 0/600 ...
fitness func
[[ 2.77555756e-18 -2.77555756e-18  1.38777878e-18 ...  1.69406589e-22
   3.81164826e-22 -2.64697796e-23]]
fitness is 0.592444222098089
saveFolder is: data/optunaERP_23dec22_/gen_0
checking firing rates
adjustRateGain
[W 2023-12-22 10:57:21,635] Trial 0 failed with parameters: {'ICThalweightECore': 1.0178117750396865, 'ICThalweightICore': 0.25326012842665524, 'ICThalprobECore': 0.21156933840065142, 'ICThalprobICore': 0.10245955581065115, 'ICThalMatrixCoreFactor': 0.10670486662869166, 'thalL4PV': 0.2504102934148817, 'thalL4SOM': 0.24890260053295996, 'thalL4E': 1.814555856130986} because of the following error: FileNotFoundError(2, 'No such file or directory').
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/study/_optimize.py", line 200, in _run_trial
    value_or_values = func(trial)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 256, in func
    return evaluator(batch, candidate, trial.number, **args)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 173, in evaluator
    fitness = fitnessFunc(simData, **fitnessFuncArgs)
  File "batch.py", line 1231, in fitnessFunc
    dgain = adjustRateGain(drate)
  File "batch.py", line 1184, in adjustRateGain
    dgain = {'EEGain':pickle.load(open('/opt/EEPopGain.pkl','rb')),
FileNotFoundError: [Errno 2] No such file or directory: '/opt/EEPopGain.pkl'
[W 2023-12-22 10:57:21,636] Trial 0 failed with value None.
[Errno 2] No such file or directory: '/opt/EEPopGain.pkl'
 Warning: an exception occurred when running Optuna optimization:
Traceback (most recent call last):
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/batch.py", line 277, in run
    optunaOptim(self, pc)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/batch/optuna_parallel.py", line 264, in optunaOptim
    importance = optuna.importance.get_param_importances(study=study)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/__init__.py", line 108, in get_param_importances
    res = evaluator.evaluate(study, params=params, target=target)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_fanova/_evaluator.py", line 92, in evaluate
    distributions = _get_distributions(study, params=params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 71, in _get_distributions
    _check_evaluate_args(completed_trials, params)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/optuna/importance/_base.py", line 114, in _check_evaluate_args
    raise ValueError("Cannot evaluate parameter importances without completed trials.")
ValueError: Cannot evaluate parameter importances without completed trials.

hmm, still a bug...

path is opt/, not /opt/ ... fix

python batch.py

* 24jan4
** checking status

got up to gen 228 but then crashed due to no room left on device

Traceback (most recent call last):
  File "init.py", line 50, in <module>
    sim.saveData()  
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/sim/save.py", line 204, in saveData
    pickle.dump(dataSave, fileObj)
OSError: [Errno 28] No space left on device
bash: /opt/miniconda3/envs/py376/lib/libtinfo.so.6: no version information available (required by bash)


best generation so far is # 204 ... 

[I 2024-01-03 16:46:05,188] Trial 227 finished with value: 0.5910998154738234 and parameters: {'ICThalweightECore': 1.0207375445030564, 'ICThalweightICore': 0.22471971176125247, 'ICThalprobECore': 0.222940566561699, 'ICThalprobICore': 0.11479059268556521, 'ICThalMatrixCoreFactor': 0.11417435547816837, 'thalL4PV': 0.3110276151624976, 'thalL4SOM': 0.26274839909690995, 'thalL4E': 2.4462029272592063}. Best is trial 204 with value: -0.6033535809904317.
['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [0.9845736653910143, 0.22846243115953266, 0.21917375376045103, 0.11869060701544966, 0.08739052582877606, 0.28040983668276975, 0.23347841805968966, 2.0460667264675263]




['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E'] [1.1366391725804097, 0.21503725192597786, 0.21638972066571394, 0.11831534696879886, 0.11412487872986073, 0.261333644625591, 0.2612645277258505, 2.3199103007567827]
set ICThalweightECore=1.1366391725804097
set ICThalweightICore=0.21503725192597786
set ICThalprobECore=0.21638972066571394
set ICThalprobICore=0.11831534696879886
set ICThalMatrixCoreFactor=0.11412487872986073
set thalL4PV=0.261333644625591
set thalL4SOM=0.2612645277258505
set thalL4E=2.3199103007567827
Saving simConfig to data/optunaERP_23dec23_/gen_204/trial_204_cfg.json ... 
Submitting job  trial_204
#!/bin/bash
    echo '['ICThalweightECore', 'ICThalweightICore', 'ICThalprobECore', 'ICThalprobICore', 'ICThalMatrixCoreFactor', 'thalL4PV', 'thalL4SOM', 'thalL4E']'
    echo '[1.1366391725804097, 0.21503725192597786, 0.21638972066571394, 0.11831534696879886, 0.11412487872986073, 0.261333644625591, 0.2612645277258505, 2.3199103007567827]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_23dec23_/gen_204/trial_204_cfg.json netParams=data/optunaERP_23dec23_/optunaERP_23dec23__netParams.py     
    
--------------------------------------------------------------------------------
subprocess.run returned non-zero exit status. trying to continue.
Waiting for jobs from generation 204/600 ...
fitness func
[[ 2.22044605e-17  2.22044605e-17  5.55111512e-18 ... -6.77626358e-21
   2.54109884e-22  1.37642854e-22]]
fitness is -0.6033535809904317
saveFolder is: data/optunaERP_23dec23_/gen_204
checking firing rates
drate: {'NGF1': 0.33, 'IT2': 6.53, 'SOM2': 138.3, 'PV2': 57.73, 'VIP2': 1.03, 'NGF2': 10.0, 'IT3': 0.26, 'SOM3': 16.7, 'PV3': 23.03, 'VIP3': 16.19, 'NGF3': 7.14, 'ITP4': 2.54, 'ITS4': 2.22, 'SOM4': 23.25, 'PV4': 3.37, 'VIP4': 8.04, 'NGF4': 15.71, 'IT5A': 2.82, 'CT5A': 0.07, 'SOM5A': 26.4, 'PV5A': 0.52, 'VIP5A': 3.3, 'NGF5A': 0.56, 'IT5B': 1.27, 'CT5B': 0.01, 'PT5B': 0.14, 'SOM5B': 39.82, 'PV5B': 0.07, 'VIP5B': 7.74, 'NGF5B': 0.12, 'IT6': 0.49, 'CT6': 2.81, 'SOM6': 62.41, 'PV6': 0.0, 'VIP6': 0.83, 'NGF6': 70.83, 'TC': 4.69, 'TCM': 4.07, 'HTC': 4.62, 'IRE': 3.36, 'IREM': 1.7, 'TI': 3.25, 'TIM': 3.75, 'IC': 0.0}
adjustRateGain
TC not found in dgain[EEGain]
TCM not found in dgain[EEGain]
HTC not found in dgain[EEGain]
IRE not found in dgain[EIGain]
IREM not found in dgain[EIGain]
TI not found in dgain[EIGain]
TIM not found in dgain[EIGain]
IC not found in dgain[EEGain]
dgain: {'EEGain': {'IT2': 1.3125, 'IT3': 1.6, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1500000000000001, 'IT5B': 0.375, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.0}, 'EIGain': {'NGF1': 1.05, 'SOM2': 0.95, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.45, 'VIP6': 1.4, 'NGF6': 0.65}}
saving iteration output.
--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2024-01-02 14:13:02,649] Trial 204 finished with value: -0.6033535809904317 and parameters: {'ICThalweightECore': 1.1366391725804097, 'ICThalweightICore': 0.21503725192597786, 'ICThalprobECore': 0.21638972066571394, 'ICThalprobICore': 0.11831534696879886, 'ICThalMatrixCoreFactor': 0.11412487872986073, 'thalL4PV': 0.261333644625591, 'thalL4SOM': 0.2612645277258505, 'thalL4E': 2.3199103007567827}. Best is trial 204 with value: -0.6033535809904317.

ok, will have to stop the optimization, free up space, and continue ... 

not sure why individual node data is saved and kept around ... 

ok, freed up node data and still have very high disk use on data drive:
 df data
Filesystem      1K-blocks       Used Available Use% Mounted on
/dev/nvme0n1p5 2333370712 1798325460 416442248  82% /data

whole drive is ~2 TB ... could probably avoid saving Vm and raster ... ? most of data probably the laminar LFP ... 

meanwhile, should check the best params to see how they look ... 

these are the params:

# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 1.1366391725804097  # 0.8350476447841453 # 1.0
cfg.ICThalweightICore = 0.21503725192597786 # 0.2114492149101151 # 0.25
cfg.ICThalprobECore = 0.21638972066571394   # 0.163484173596043 # 0.19
cfg.ICThalprobICore = 0.11831534696879886   # 0.0936669688856933 # 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.11412487872986073 # 0.1 # this is used to scale weights to thalamic matrix neurons in netParams.py
cfg.ICThalprobEMatrix = cfg.ICThalprobECore 
cfg.ICThalprobIMatrix = cfg.ICThalprobICore 

# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.261333644625591   # 0.21367245896786016 # 0.25 
cfg.thalL4SOM = 0.2612645277258505 # 0.24260966747847523 # 0.25 
cfg.thalL4E = 2.3199103007567827   # 1.9540886147587417 # 2.0 

but also have to use the same EEPopGain and EIPopGain after the rate adjustment ... 

so which to use? the one from before or after gen 204? 

will use these in the cfg.py file:
dgain: {'EEGain': {'IT2': 1.3125, 'IT3': 1.6, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.0, 'CT5A': 1.1500000000000001, 'IT5B': 0.375, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.0}, 'EIGain': {'NGF1': 1.05, 'SOM2': 0.95, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.45, 'VIP6': 1.4, 'NGF6': 0.65}}

and turn off loading from opt/EEPopGain.pkl, opt/EIPopGain.pkl for the test ... 

./myrun 48

* 24jan5
** continue from last entry - checking output from optimization

  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 380732 (5.28 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 3203.56 s
   NGF1 : 0.413 Hz
   IT2 : 2.259 Hz
   SOM2 : 47.491 Hz
   PV2 : 74.476 Hz
   VIP2 : 0.818 Hz
   NGF2 : 22.236 Hz
   IT3 : 0.666 Hz
   SOM3 : 15.705 Hz
   PV3 : 39.825 Hz
   VIP3 : 51.327 Hz
   NGF3 : 10.611 Hz
   ITP4 : 2.998 Hz
   ITS4 : 2.556 Hz
   SOM4 : 29.881 Hz
   PV4 : 7.065 Hz
   VIP4 : 17.874 Hz
   NGF4 : 15.013 Hz
   IT5A : 1.744 Hz
   CT5A : 3.416 Hz
   SOM5A : 30.558 Hz
   PV5A : 2.419 Hz
   VIP5A : 3.273 Hz
   NGF5A : 2.750 Hz
   IT5B : 3.380 Hz
   CT5B : 3.372 Hz
   PT5B : 0.446 Hz
   SOM5B : 57.788 Hz
   PV5B : 0.858 Hz
   VIP5B : 0.477 Hz
   NGF5B : 3.250 Hz
   IT6 : 3.856 Hz
   CT6 : 4.310 Hz
   SOM6 : 95.192 Hz
   PV6 : 2.843 Hz
   VIP6 : 3.934 Hz
   NGF6 : 159.507 Hz
   TC : 11.955 Hz
   TCM : 5.086 Hz
   HTC : 9.971 Hz
   IRE : 4.983 Hz
   IREM : 1.703 Hz
   TI : 3.353 Hz
   TIM : 3.487 Hz
   IC : 2.115 Hz
Saving output as data/24jan4_A0/24jan4_A0_data.pkl ... 

python -i simdat.py 24jan4_A0

NGF1 0.86 Hz
IT2 0.01 Hz
SOM2 0.6 Hz
PV2 0.0 Hz
VIP2 0.0 Hz
NGF2 23.73 Hz
IT3 0.0 Hz
SOM3 0.0 Hz
PV3 74.86 Hz
VIP3 95.94 Hz
NGF3 10.99 Hz
ITP4 1.43 Hz
ITS4 1.35 Hz
SOM4 1.04 Hz
PV4 14.36 Hz
VIP4 57.38 Hz
NGF4 16.64 Hz
IT5A 0.51 Hz
CT5A 12.84 Hz
SOM5A 21.93 Hz
PV5A 4.85 Hz
VIP5A 0.0 Hz
NGF5A 7.0 Hz
IT5B 9.41 Hz
CT5B 12.76 Hz
PT5B 1.31 Hz
SOM5B 81.19 Hz
PV5B 1.1 Hz
VIP5B 0.0 Hz
NGF5B 5.71 Hz
IT6 3.83 Hz
CT6 4.67 Hz
SOM6 132.27 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 274.03 Hz
TC 26.94 Hz
TCM 9.05 Hz
HTC 19.45 Hz
IRE 8.19 Hz
IREM 1.44 Hz
TI 3.94 Hz
TIM 3.22 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24jan5_24jan4_A0_rast.png]]

this raster plot looks pretty hyperactive already ... 

drate = OrderedDict({pop:round(getrate(dspkT,dspkID,pop,dnumc,tlim=[2e3,4e3]),2) for pop in dspkT.keys()})
OrderedDict([('NGF1', 0.39), ('IT2', 2.79), ('SOM2', 83.4), ('PV2', 153.38), ('VIP2', 0.0), ('NGF2', 16.95), ('IT3', 0.06), ('SOM3', 2.14), ('PV3', 28.86), ('VIP3', 49.55), ('NGF3', 7.99), ('ITP4', 3.69), ('ITS4', 3.0), ('SOM4', 44.02), ('PV4', 1.14), ('VIP4', 0.0), ('NGF4', 11.64), ('IT5A', 2.9), ('CT5A', 0.36), ('SOM5A', 25.93), ('PV5A', 0.13), ('VIP5A', 5.8), ('NGF5A', 0.06), ('IT5B', 2.77), ('CT5B', 0.08), ('PT5B', 0.18), ('SOM5B', 41.32), ('PV5B', 0.02), ('VIP5B', 0.0), ('NGF5B', 0.15), ('IT6', 1.22), ('CT6', 4.09), ('SOM6', 79.05), ('PV6', 0.0), ('VIP6', 0.0), ('NGF6', 105.49), ('TC', 5.25), ('TCM', 5.04), ('HTC', 5.5), ('IRE', 3.59), ('IREM', 1.57), ('TI', 3.6), ('TIM', 3.88), ('IC', 0.0)])

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-50,50))
xlim((0,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/24jan5_24jan4_A0_CSD_a4.png]]

bbnT = np.arange(4000, 5000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24jan5_24jan4_A0_model_BBN_avg_ERP_CSD_a5.png]]

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))

ttnhpERP = np.linspace(0,150,len(d['avgCSD'][0]))

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k]/np.sum(d['avgCSD'][k]),clr,linewidth=4)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/np.sum(avgERP[chan,:]),clr)
  gdx+=1

savefig(gifpath()+'_model_nhp_CSD_ERP_avg_a7.png') # [[./gif/24jan5_24jan4_A0_model_nhp_CSD_ERP_avg_a7.png]]

hmm, even granular CSD does not look good here ... other layers much worse

pearsonr(d['avgCSD'][g], avgERP[10,:]) # (-0.21386081020305422, 2.2554050583725798e-32)

that correlation value is very different from the fitness value found during optimization; so should
check that it was run in same way ... maybe the population synaptic gains differ

how does overall CSD look ? 

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/24jan4_A0/24jan4_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24jan5_24jan4_A0_CSD__CSD_overlay_a2.png]]

check fitness score ...

python -i simdat.py 24jan4_A0

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]
lnhpchan = [11-1, 15-1, 20-1]
bbnT = np.arange(4000, 5000, 300)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from scipy.stats import pearsonr
from erp import getAvgERP

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))
ttavgERPNHP = d['ttavg']
avgCSDNHP = d['avgCSD'] # s2, g, i1 channels for primary CSD sinks are at indices 10, 14, 19

fitness = -pearsonr(avgCSDNHP[lnhpchan[1],:],avgERP[lchan[1]])[0]

0.21386081020305422

that's much different from fitness reported during optimization ... 

can take a look at the data from that generation instead ... 

data/optunaERP_23dec23_/gen_204/trial_204_data.pkl

python -i simdat.py None

simConfig, dstartidx, dendidx, dnumc, dspkID, dspkT = loadsimdat(name,lpop=[], fullpath='data/optunaERP_23dec23_/gen_204/trial_204_data.pkl')

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]
lnhpchan = [11-1, 15-1, 20-1]
bbnT = np.arange(4000, 5000, 300)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from scipy.stats import pearsonr
from erp import getAvgERP

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))
ttavgERPNHP = d['ttavg']
avgCSDNHP = d['avgCSD'] # s2, g, i1 channels for primary CSD sinks are at indices 10, 14, 19

fitness = -pearsonr(avgCSDNHP[lnhpchan[1],:],avgERP[lchan[1]])[0]

-0.6033535809904317

ok, so that's same as reported during the optimization ... difference might be the synaptic gain values ... 

how do waveforms and activity look?

pravgrates(dspkT,dspkID,dnumc,tlim=(250,totalDur))

NGF1 0.32 Hz
IT2 4.27 Hz
SOM2 80.46 Hz
PV2 40.7 Hz
VIP2 1.14 Hz
NGF2 27.46 Hz
IT3 1.71 Hz
SOM3 35.63 Hz
PV3 22.62 Hz
VIP3 13.42 Hz
NGF3 14.95 Hz
ITP4 1.9 Hz
ITS4 1.72 Hz
SOM4 19.32 Hz
PV4 9.05 Hz
VIP4 16.72 Hz
NGF4 16.03 Hz
IT5A 1.54 Hz
CT5A 0.36 Hz
SOM5A 38.87 Hz
PV5A 1.72 Hz
VIP5A 2.06 Hz
NGF5A 0.57 Hz
IT5B 1.02 Hz
CT5B 0.26 Hz
PT5B 0.12 Hz
SOM5B 55.12 Hz
PV5B 0.49 Hz
VIP5B 3.5 Hz
NGF5B 0.46 Hz
IT6 2.31 Hz
CT6 2.88 Hz
SOM6 64.93 Hz
PV6 4.49 Hz
VIP6 10.65 Hz
NGF6 93.85 Hz
TC 6.21 Hz
TCM 3.83 Hz
HTC 6.11 Hz
IRE 3.98 Hz
IREM 1.75 Hz
TI 3.04 Hz
TIM 3.59 Hz
IC 2.16 Hz

excitatory neuron rates are o.k. 

simstr = 'optunaERP_23dec23__gen_204'

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_rast.png]]

xlim((3e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_rastB.png]]

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_model_BBN_avg_ERP_CSD_a5.png]]

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))

ttnhpERP = np.linspace(0,150,len(d['avgCSD'][0]))

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k]/abs(np.sum(d['avgCSD'][k])),clr,linewidth=4)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  gdx+=1

note that in previous comparisons of waveforms was not taking into account the polarity properly, so accidentally
had reversed it when divided by np.sum, which is sometimes negative ... so now taking care to divide by abs of sum
(div by sum is just for easier comparison of nhp vs model ERP) ... looking now, the L4 CSD ERP does have some
similarity in direction and overall trend, though the amplitude looks exaggerated for model compared to NHP

supra- and infra-granular looks wrong, but that was not optimized for

savefig(gifpath()+'_model_nhp_CSD_ERP_avg_a7.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_model_nhp_CSD_ERP_avg_a7.png]]

and how about full color CSD for this simulation?

from netpyne import sim

fn = 'data/optunaERP_23dec23_/gen_204/trial_204_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_CSD__CSD_overlay_a2.png]]

so, may want to either continue the optimization or add constraints for the CSD in supra- and infra-granular layers ... 

if the ERP fit after synaptic gain modulation is reducing the goodness-of-fit, can just use the previous synaptic gains
but overall that added constraint on firing rates seems useful ... 

sim.plotting.plotCSD(overlay='CSD',timeRange=[4.5e3,5.0e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24jan5_optunaERP_23dec23__gen_204_CSD__CSD_overlay_a3.png]]

** put generation 203 EEPopGain, EIPopGain into cfg.py for now

since generation 204 had decent L4 CSD ERP match, will have the EEPopGain, EIPopGain it used in cfg.py for now

dg = pickle.load(open('data/optunaERP_23dec23_/gen_203/dgain.pkl','rb'))
dg['EEGain']
{'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.05, 'CT5A': 1.1500000000000001, 'IT5B': 0.425, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.05}

dg['EIGain']
{'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.3499999999999999, 'NGF6': 0.65}

* 24jan8
** email from NO on CSD ERPs

I have a few questions and comments on this.

So does the BBN stimulation begin at 4000ms in the first figure? What
is the activity in the CSD prior to 4000ms? And the second figure is
just a zoomed in BBN response? What is the SOA of the BBN…it's not
624ms is t? Also what is the duration of the BBN bursts?

I think the CSD response in the Layers 3-6 looks good, the sink and
sources do seem to line up like the should.

I have a comment about the layer 1-2 sink source pair that I probably
should've mentioned before sorry...the amplitude of that pair is much
stronger than the activity in the other layers and when we do see
activity in layer 1 (which is not that often tbh) it is of less or
equal amplitude to activity in the other layers and is generally only
a source. I've attached a figure 3B from Peter’s 2021 MMN paper (which
is pretty much the only paper where we talk about layer 1 activity)
and layer 1 shows a source.

I know we have discussed that the model might not account for
horizontal connections from other cortical columns that terminate in
layer 1, but do you think we can assume that their absence gives rise
to this layer 1 activity that we don’t usually see in vivo?

*** response to NO

Hi Noelle,

Yeah, the BBN stimulation begins at 4000ms. I attached another figure
showing CSD activity prior to onset of BBN, there's a fairly strong
rhythm present which seems to be generated through corticothalamic
interactions. Yeah, about zoomed in. The the 100ms BBN inputs are
presented at ~3Hz. 

[[/home/samn/A1/gif/24jan5_optunaERP_23dec23__gen_204_CSD__CSD_overlay_a2.png]]

Thanks for clarifying about the L1/L2 CSD, and the figure from Peter's paper.

About the L1-2 sink/source - in the model is the source OK and just the sink
in L1 needs to be removed? 

Note that in the NHP BBN ERP data you provided, the supra-granular response
does have a large amplitude spike (see attached - the red, green, blue lines are
the average supra-, gran-, and infra-granular NHP ERP responses
to BBN). Am I misinterpreting the supragranular sink?

[[/home/samn/a1dat/gif/23nov7_ERP_avg_a0.png]]

I'm thinking of adding explicit constraints for the supra-granular
CSD channels to improve their similarity to the NHP data, or possibly
all CSD channels at the same time. But before I do that, let me know if the
attached ERP plots looks typical to you.

Thanks,
Sam
 
** ERP opt: constraint for other channels?
* 24jan9
** other email from NO

Hi Sam,

Sorry about the delay in getting back to you...yes, the ERPs look very
accurate to me and representative of activity in the different layers
to a BBN stimulus. I was just making the comment that we don't usually
see activity in layer 1 or 2 that is larger in amplitude than the
other layers. Often the layer3 sink can have a larger amplitude than
the granular layer (L4) sink.

* 24jan10
** ERP opt: constraint for other channels?

could use all the channels to make sure response in all layers accurate

or at least use 3 channels - sink in supra, gran, infragran ... NO mentioned L1
sink has way too high amplitude, so need to get rid of that as well ... 

python
from pylab import *
ion()
import pickle
import numpy as np

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))
ttavgERPNHP = d['ttavg']
avgCSDNHP = d['avgCSD'] # s2, g, i1 channels for primary CSD sinks are at indices 10, 14, 19

avgCSDNHP.shape # (21, 3000)

imshow(avgCSDNHP,extent=[0,150,0,21],interpolation=None,colormap=)

constraint in supra, gran, and infragran layer might be enough to implicitly
constrain the other layers ... so can start there ... 

ok, can use this as fitness
        fitness = -np.sum([pearsonr(avgCSDNHP[chNHP,:],avgERP[chMOD])[0] for chNHP, chMOD in zip(lnhpchan, lchan)])/len(lchan)

and start with parameters from best fitness from last optimization run (optunaERP_23dec23_), which were in generation 204 with EEGain,EIGain
from generation 203 ...


hmm, were the EEPopGain, EIPopGain gains saved properly during optimization?
have this code:
        pickle.dump(dgain['EEGain'],open('opt/EEgain.pkl','wb'))
        pickle.dump(dgain['EIGain'],open('opt/EIgain.pkl','wb'))

but that is not used in cfg.py, opt/EEPopGain.pkl and opt/EIPopGain.pkl are used ... 

so that could be a mistake. can check the gain values in each generation ... 

lde,ldi = [],[]
for gen in range(205):
  dg  = pickle.load(open('data/optunaERP_23dec23_/gen_'+str(gen)+'/dgain.pkl','rb'))
  de,di = dg['EEGain'],dg['EIGain']
  lde.append(de); ldi.append(di)

ldeIT2 = [lde[i]['IT2'] for i in range(len(lde))]
plot(ldeIT2)

min(ldeIT2) # 1.3125
max(ldeIT2) # 1.3625

IT2 gain just fluctuates between these two values ... 

ldeIT3 = [lde[i]['IT3'] for i in range(len(lde))]
plot(ldeIT3)

min(ldeIT3) # 1.55
max(ldeIT3) # 1.6

same with this one ... so the gain modulation code was buggy ... but still
managed to at least minimally prevent too much activation ... 

will fix in next round ... 

make sure right values saved at start of optimization ... 


EEPopGain = {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.05, 'CT5A': 1.1500000000000001, 'IT5B': 0.425, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.05} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization
EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.3499999999999999, 'NGF6': 0.65} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization

pickle.dump(EEPopGain,open('opt/EEPopGain.pkl','wb'))
pickle.dump(EIPopGain,open('opt/EIPopGain.pkl','wb'))

python batch.py

* 24jan29
** check status of optunaERP_24jan10_ , test run of best output (gen 236)

got up to gen 387, then looks like ran out of disk space (97% full)

what was the best output?

conda activate py376

python

import pickle
import numpy as np

ldout = [pickle.load(open('data/optunaERP_24jan10_/gen_'+str(gen)+'/dout.pkl','rb')) for gen in range(387)]
lfit = [dout['fitness'] for dout in ldout]

plot(lfit)
xlabel('Iteration'); ylabel('Fitness')
savefig('gif/24jan29_optunaERP_24jan10_lfit_a0.png') # [[./gif/24jan29_optunaERP_24jan10_lfit_a0.png]]

np.argmin(lfit) # 236

so iteration 236 best ... what are the parameters ? 

lfit[236] # -0.36573099292566713

ldout[236].keys() # dict_keys(['fitness', 'ttERP', 'avgERP'])

ldout[236]['ttERP'] 
ldout[236]['avgERP'].shape

for chan,clr in zip([4,10,15],['r','g','b']): plot(ldout[236]['ttERP'],ldout[236]['avgERP'][chan,:],clr)

savefig('gif/24jan29_optunaERP_24jan10_gen236_avgERP_a1.png')
[[./gif/24jan29_optunaERP_24jan10_gen236_avgERP_a1.png]]

supra, gran-, infra-gran in red, green, blue

and where are the parameter values? only in data/optunaERP_24jan10_/gen_236/trial_236_cfg.json ? 

and need to take dgain from previous generation (235) to get same output

dgain = pickle.load(open('data/optunaERP_24jan10_/gen_235/dgain.pkl','rb'))
{'EEGain': {'IT2': 3.0, 'IT3': 3.0, 'ITP4': 0.95, 'ITS4': 0.95, 'IT5A': 3.0, 'CT5A': 3.0, 'IT5B': 3.0, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 3.0, 'CT6': 3.0}, 'EIGain': {'NGF1': 2.3, 'SOM2': 0.3, 'PV2': 0.3, 'VIP2': 1.3500000000000003, 'NGF2': 0.95, 'SOM3': 3.0, 'PV3': 1.05, 'VIP3': 1.05, 'NGF3': 0.95, 'SOM4': 0.95, 'PV4': 3.0, 'VIP4': 1.05, 'NGF4': 0.95, 'SOM5A': 0.95, 'PV5A': 3.0, 'VIP5A': 3.0, 'NGF5A': 1.5500000000000007, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 3.0, 'NGF5B': 3.0, 'SOM6': 3.0, 'PV6': 0.25, 'VIP6': 0.25, 'NGF6': 0.25}}

so move those into cfg.py and turn off during opt setting

and these are the param values from trial_236_cfg.json : 

        "ICThalweightECore": 1.0218574230414905,
        "ICThalweightICore": 0.20065170901643178,
        "ICThalprobECore": 0.17524000437877066,
        "ICThalprobICore": 0.0978864963550709,
        "ICThalMatrixCoreFactor": 0.0988423213016316,
        "thalL4E": 2.8510831744854714,
        "thalL4PV": 0.3201033836037148,
        "thalL4SOM": 0.3200462291706402,

ok, put that into cfg.py ... 

cfg.simLabel = '24jan29_A0'

try that sim out ... 

./myrun 48

  Done; saving time = 159.96 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 1228785 (17.04 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2499.67 s
   NGF1 : 17.286 Hz
   IT2 : 0.186 Hz
   SOM2 : 5.745 Hz
   PV2 : 4.350 Hz
   VIP2 : 0.330 Hz
   NGF2 : 477.564 Hz
   IT3 : 2.568 Hz
   SOM3 : 2.150 Hz
   PV3 : 0.292 Hz
   VIP3 : 9.263 Hz
   NGF3 : 151.817 Hz
   ITP4 : 20.637 Hz
   ITS4 : 20.049 Hz
   SOM4 : 133.747 Hz
   PV4 : 0.178 Hz
   VIP4 : 0.336 Hz
   NGF4 : 277.831 Hz
   IT5A : 44.731 Hz
   CT5A : 29.135 Hz
   SOM5A : 216.723 Hz
   PV5A : 0.174 Hz
   VIP5A : 0.424 Hz
   NGF5A : 78.523 Hz
   IT5B : 75.771 Hz
   CT5B : 3.956 Hz
   PT5B : 25.675 Hz
   SOM5B : 13.628 Hz
   PV5B : 0.182 Hz
   VIP5B : 0.352 Hz
   NGF5B : 9.424 Hz
   IT6 : 6.792 Hz
   CT6 : 15.921 Hz
   SOM6 : 0.748 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.198 Hz
   NGF6 : 347.187 Hz
   TC : 44.500 Hz
   TCM : 47.099 Hz
   HTC : 44.285 Hz
   IRE : 6.969 Hz
   IREM : 19.273 Hz
   TI : 0.284 Hz
   TIM : 0.138 Hz
   IC : 2.115 Hz

python -i simdat.py 24jan29_A0

NGF1 18.56 Hz
IT2 0.0 Hz
SOM2 0.0 Hz
PV2 0.0 Hz
VIP2 0.0 Hz
NGF2 429.45 Hz
IT3 1.7 Hz
SOM3 0.0 Hz
PV3 0.0 Hz
VIP3 19.48 Hz
NGF3 140.41 Hz
ITP4 18.64 Hz
ITS4 17.7 Hz
SOM4 122.75 Hz
PV4 0.0 Hz
VIP4 0.0 Hz
NGF4 268.5 Hz
IT5A 53.85 Hz
CT5A 24.33 Hz
SOM5A 219.51 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 16.88 Hz
IT5B 80.27 Hz
CT5B 0.19 Hz
PT5B 26.97 Hz
SOM5B 4.2 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 7.2 Hz
CT6 15.33 Hz
SOM6 0.0 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 368.18 Hz
TC 42.97 Hz
TCM 46.54 Hz
HTC 39.71 Hz
IRE 5.77 Hz
IREM 21.13 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 5.67 Hz

these rates are way too high ... 

# simConfig, dstartidx, dendidx, dnumc, dspkID, dspkT = loadsimdat(name,lpop=[], fullpath='data/optunaERP_23dec23_/gen_204/trial_204_data.pkl')

xlim((4500,5500))

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]
lnhpchan = [11-1, 15-1, 20-1]
bbnT = np.arange(4000, 5000, 300)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from scipy.stats import pearsonr
from erp import getAvgERP

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))
ttavgERPNHP = d['ttavg']
avgCSDNHP = d['avgCSD'] # s2, g, i1 channels for primary CSD sinks are at indices 10, 14, 19

fitness = -np.sum([pearsonr(avgCSDNHP[chNHP,:],avgERP[chMOD])[0] for chNHP, chMOD in zip(lnhpchan, lchan)])/len(lchan)
-0.06672791403299316

need to apply rate gain ... otherwise some of these firing rates are way too high ... 

python

from netpyne import sim

fn = 'data/24jan29_A0/24jan29_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24jan30_24jan29_A0_CSD__CSD_overlay_a2.png]]

that CSD looks really bad ... 

* 24jan30
** continue from last entry

try using dgain after adjustment ...

import pickle
dgain = pickle.load(open('data/optunaERP_24jan10_/gen_236/dgain.pkl','rb'))
{'EEGain': {'IT2': 3.0, 'IT3': 3.0, 'ITP4': 0.95, 'ITS4': 0.95, 'IT5A': 3.0, 'CT5A': 3.0, 'IT5B': 3.0, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 3.0, 'CT6': 3.0}, 'EIGain': {'NGF1': 2.3, 'SOM2': 0.3, 'PV2': 0.3, 'VIP2': 1.3500000000000003, 'NGF2': 0.95, 'SOM3': 3.0, 'PV3': 1.05, 'VIP3': 1.05, 'NGF3': 0.95, 'SOM4': 0.95, 'PV4': 3.0, 'VIP4': 1.05, 'NGF4': 0.95, 'SOM5A': 0.95, 'PV5A': 3.0, 'VIP5A': 3.0, 'NGF5A': 1.5500000000000007, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 3.0, 'NGF5B': 3.0, 'SOM6': 3.0, 'PV6': 0.25, 'VIP6': 0.25, 'NGF6': 0.25}}

ok, try rerunning again ... 

24jan30_A0

./myrun 48

Saving output as data/24jan30_A0/24jan30_A0_data.pkl ... 
Finished saving!
  Done; saving time = 157.83 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 1228785 (17.04 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2506.62 s
   NGF1 : 17.286 Hz
   IT2 : 0.186 Hz
   SOM2 : 5.745 Hz
   PV2 : 4.350 Hz
   VIP2 : 0.330 Hz
   NGF2 : 477.564 Hz
   IT3 : 2.568 Hz
   SOM3 : 2.150 Hz
   PV3 : 0.292 Hz
   VIP3 : 9.263 Hz
   NGF3 : 151.817 Hz
   ITP4 : 20.637 Hz
   ITS4 : 20.049 Hz
   SOM4 : 133.747 Hz
   PV4 : 0.178 Hz
   VIP4 : 0.336 Hz
   NGF4 : 277.831 Hz
   IT5A : 44.731 Hz
   CT5A : 29.135 Hz
   SOM5A : 216.723 Hz
   PV5A : 0.174 Hz
   VIP5A : 0.424 Hz
   NGF5A : 78.523 Hz
   IT5B : 75.771 Hz
   CT5B : 3.956 Hz
   PT5B : 25.675 Hz
   SOM5B : 13.628 Hz
   PV5B : 0.182 Hz
   VIP5B : 0.352 Hz
   NGF5B : 9.424 Hz
   IT6 : 6.792 Hz
   CT6 : 15.921 Hz
   SOM6 : 0.748 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.198 Hz
   NGF6 : 347.187 Hz
   TC : 44.500 Hz
   TCM : 47.099 Hz
   HTC : 44.285 Hz
   IRE : 6.969 Hz
   IREM : 19.273 Hz
   TI : 0.284 Hz
   TIM : 0.138 Hz
   IC : 2.115 Hz

no, these firing rates are way too high

* 24feb7
** continue

first, check params, then restore best ones found previously that
did not show hyperactivity
then, try adjusting the location of supragranular synapses to see
if can get better source/sink pattern in supragranular layers

* 24feb12
** restore previous param values from before multi-channel CSD optimization and test (24feb12_A0)

./myrun 48

  Done; run time = 2410.36 s; real-time ratio: 0.00.

  Done; saving time = 157.56 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 287231 (3.98 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2410.36 s
   NGF1 : 0.273 Hz
   IT2 : 4.766 Hz
   SOM2 : 53.055 Hz
   PV2 : 46.769 Hz
   VIP2 : 0.920 Hz
   NGF2 : 16.873 Hz
   IT3 : 0.505 Hz
   SOM3 : 19.072 Hz
   PV3 : 36.389 Hz
   VIP3 : 24.949 Hz
   NGF3 : 8.899 Hz
   ITP4 : 3.027 Hz
   ITS4 : 2.459 Hz
   SOM4 : 33.700 Hz
   PV4 : 2.791 Hz
   VIP4 : 5.538 Hz
   NGF4 : 12.364 Hz
   IT5A : 2.092 Hz
   CT5A : 0.456 Hz
   SOM5A : 29.390 Hz
   PV5A : 0.864 Hz
   VIP5A : 3.172 Hz
   NGF5A : 0.864 Hz
   IT5B : 1.976 Hz
   CT5B : 0.285 Hz
   PT5B : 0.170 Hz
   SOM5B : 47.333 Hz
   PV5B : 0.453 Hz
   VIP5B : 0.602 Hz
   NGF5B : 1.386 Hz
   IT6 : 2.697 Hz
   CT6 : 3.973 Hz
   SOM6 : 80.507 Hz
   PV6 : 0.153 Hz
   VIP6 : 1.851 Hz
   NGF6 : 108.402 Hz
   TC : 6.729 Hz
   TCM : 3.976 Hz
   HTC : 6.049 Hz
   IRE : 4.184 Hz
   IREM : 2.020 Hz
   TI : 3.000 Hz
   TIM : 3.367 Hz
   IC : 2.115 Hz

most of the firing rates are decent ...

python -i simdat.py 24feb12_A0

NGF1 0.51 Hz
IT2 2.14 Hz
SOM2 38.6 Hz
PV2 81.15 Hz
VIP2 0.69 Hz
NGF2 17.0 Hz
IT3 0.03 Hz
SOM3 2.34 Hz
PV3 35.44 Hz
VIP3 46.89 Hz
NGF3 8.44 Hz
ITP4 3.18 Hz
ITS4 2.62 Hz
SOM4 33.25 Hz
PV4 2.27 Hz
VIP4 0.15 Hz
NGF4 11.93 Hz
IT5A 2.48 Hz
CT5A 1.11 Hz
SOM5A 21.65 Hz
PV5A 0.42 Hz
VIP5A 3.1 Hz
NGF5A 0.75 Hz
IT5B 5.48 Hz
CT5B 0.57 Hz
PT5B 0.44 Hz
SOM5B 47.37 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 0.96 Hz
IT6 2.04 Hz
CT6 4.55 Hz
SOM6 91.52 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 138.76 Hz
TC 8.73 Hz
TCM 5.32 Hz
HTC 6.95 Hz
IRE 4.98 Hz
IREM 2.8 Hz
TI 2.41 Hz
TIM 2.86 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24feb12_24feb12_A0_rast.png]]

xlim((3e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb12_24feb12_A0_rastB.png]]

python

from netpyne import sim

fn = 'data/24feb12_A0/24feb12_A0_data.pkl'

sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb12_A0__CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb12_A0__CSD__CSD_overlay_a3.png]]

OK, granular CSD is for ERP is not terrible, but supragranular layers at least need the adjustment to have sink below source ... 
note that the first ERP has large sink in L1, but the 2nd,3rd,4th ERPs do not have a prominent sink there

** adjust synapse locations (24feb12_B0_)

look in netParams.py in cfg.addSubConn part of the code

test moving TCM -> E from apical to proximal

    #  TCM -> E: apical
    netParams.subConnParams['TCM->E'] = {
        'preConds': {'cellType': ['TCM']}, 
        'postConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']},
        # 'sec': 'apic',
        'sec': 'proximal',      
        'groupSynMechs': ESynMech, 
        'density': 'uniform'}

not accurate anatomically, but will see if it changes the large L1 supragranular sink

./myrun 48

  Done; run time = 2408.93 s; real-time ratio: 0.00.

Finished saving!
  Done; saving time = 163.86 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 287231 (3.98 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2408.93 s
   NGF1 : 0.273 Hz
   IT2 : 4.766 Hz
   SOM2 : 53.055 Hz
   PV2 : 46.769 Hz
   VIP2 : 0.920 Hz
   NGF2 : 16.873 Hz
   IT3 : 0.505 Hz
   SOM3 : 19.072 Hz
   PV3 : 36.389 Hz
   VIP3 : 24.949 Hz
   NGF3 : 8.899 Hz
   ITP4 : 3.027 Hz
   ITS4 : 2.459 Hz
   SOM4 : 33.700 Hz
   PV4 : 2.791 Hz
   VIP4 : 5.538 Hz
   NGF4 : 12.364 Hz
   IT5A : 2.092 Hz
   CT5A : 0.456 Hz
   SOM5A : 29.390 Hz
   PV5A : 0.864 Hz
   VIP5A : 3.172 Hz
   NGF5A : 0.864 Hz
   IT5B : 1.976 Hz
   CT5B : 0.285 Hz
   PT5B : 0.170 Hz
   SOM5B : 47.333 Hz
   PV5B : 0.453 Hz
   VIP5B : 0.602 Hz
   NGF5B : 1.386 Hz
   IT6 : 2.697 Hz
   CT6 : 3.973 Hz
   SOM6 : 80.507 Hz
   PV6 : 0.153 Hz
   VIP6 : 1.851 Hz
   NGF6 : 108.402 Hz
   TC : 6.729 Hz
   TCM : 3.976 Hz
   HTC : 6.049 Hz
   IRE : 4.184 Hz
   IREM : 2.020 Hz
   TI : 3.000 Hz
   TIM : 3.367 Hz
   IC : 2.115 Hz

python -i simdat.py 24feb12_B0

NGF1 0.51 Hz
IT2 2.14 Hz
SOM2 38.6 Hz
PV2 81.15 Hz
VIP2 0.69 Hz
NGF2 17.0 Hz
IT3 0.03 Hz
SOM3 2.34 Hz
PV3 35.44 Hz
VIP3 46.89 Hz
NGF3 8.44 Hz
ITP4 3.18 Hz
ITS4 2.62 Hz
SOM4 33.25 Hz
PV4 2.27 Hz
VIP4 0.15 Hz
NGF4 11.93 Hz
IT5A 2.48 Hz
CT5A 1.11 Hz
SOM5A 21.65 Hz
PV5A 0.42 Hz
VIP5A 3.1 Hz
NGF5A 0.75 Hz
IT5B 5.48 Hz
CT5B 0.57 Hz
PT5B 0.44 Hz
SOM5B 47.37 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 0.96 Hz
IT6 2.04 Hz
CT6 4.55 Hz
SOM6 91.52 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 138.76 Hz
TC 8.73 Hz
TCM 5.32 Hz
HTC 6.95 Hz
IRE 4.98 Hz
IREM 2.8 Hz
TI 2.41 Hz
TIM 2.86 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24feb12_24feb12_B0_rast.png]]

xlim((3e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb12_24feb12_B0_rastB.png]]

from netpyne import sim

fn = 'data/24feb12_B0/24feb12_B0_data.pkl'

sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb12_24feb12_B0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb12_24feb12_B0_CSD__CSD_overlay_a3.png]]

hmm, so far that did not change the location/presence of the large sink in L1

* 24feb23
** CM sims for L1 sink adjustment

https://github.com/ChristophMetzner/A1model/blob/main/L1sink.org

new parameterizations are here:
 https://github.com/ChristophMetzner/A1model/blob/main/netParams_addFB_alterSyn.py

and relevant cfg.py : 
https://github.com/ChristophMetzner/A1model/blob/main/cfg.py

** adjust samn A1 branch to include new CM parameterizations

ok, added the parameterizations; most of them specify location of synapses, with focus on populations
near L1 that presumably contribute to the large sink

here are some of the new cfg options:
## E->I by target cell type
cfg.EICellTypeGain = {'PV': 1.0, 'SOM': 1.0, 'VIP': 1.0, 'NGF': 0.1} # {'PV': 1.0, 'SOM': 1.0, 'VIP': 1.0, 'NGF': 1.0}

## I->E by target cell type
cfg.IECellTypeGain = {'PV': 1.0, 'SOM': 1.0, 'VIP': 1.0, 'NGF': 1.0}

# Thalamic
cfg.addIntraThalamicConn = 1.0
cfg.addCorticoThalamicConn = 1.0
cfg.addThalamoCorticalConn = 1.0

cfg.thalamoCorticalGain = 1.0
cfg.intraThalamicGain = 1.0
cfg.corticoThalamicGain = 1.0

# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.8350476447841453 # 1.0218574230414905 # 1.1366391725804097  # 0.8350476447841453 # 1.0
cfg.ICThalweightICore = 0.2114492149101151 # 0.20065170901643178 # 0.21503725192597786 # 0.2114492149101151 # 0.25
cfg.ICThalprobECore = 0.163484173596043 # 0.17524000437877066 # 0.21638972066571394   # 0.163484173596043 # 0.19
cfg.ICThalprobICore = 0.0936669688856933 # 0.0978864963550709 # 0.11831534696879886   # 0.0936669688856933 # 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.1 # 0.0988423213016316 # 0.11412487872986073 # 0.1 # this is used to scale weights to thalamic matrix neurons in netParams.py
cfg.ICThalprobEMatrix = cfg.ICThalprobECore 
cfg.ICThalprobIMatrix = cfg.ICThalprobICore 

# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.21367245896786016 # 0.3201033836037148 # 0.261333644625591   # 0.21367245896786016 # 0.25 
cfg.thalL4SOM = 0.24260966747847523 # 0.3200462291706402 # 0.2612645277258505 # 0.24260966747847523 # 0.25 
cfg.thalL4E = 1.9540886147587417 # 2.8510831744854714 # 2.3199103007567827   # 1.9540886147587417 # 2.0

cfg.thalL4VIP = 1.0
cfg.thalL4NGF = 1.0

cfg.thalL1NGF = 1.0
cfg.ENGF1 = 1.0

cfg.L4L3E    = 2.0 # 1.0
cfg.L4L3PV   = 0.1
cfg.L4L3SOM  = 1.0

cfg.L4L3VIP = 0.1
cfg.L4L3NGF = 1.0

cfg.addSubConn = 1

cfg.alterSyn = 0
cfg.alterSyn2 = 0
cfg.alterSyn3 = 0

alterSyn:
   if cfg.alterSyn:
        #------------------------------------------------------------------------------
        #  TCM -> E: apical
        netParams.subConnParams['TCM->E'] = {
            'preConds': {'cellType': ['TCM']}, 
            'postConds': {'cellType': ['IT2','IT3','IT6', 'ITS4', 'CT']},
            'sec': 'apic',
            'groupSynMechs': ESynMech, 
            'density': 'uniform'}
        #------------------------------------------------------------------------------
        #  TCM -> 5: apical
        netParams.subConnParams['TCM->5'] = {
            'preConds': {'cellType': ['TCM']}, 
            'postConds': {'cellType': ['IT5A','IT5B','PT5B']},
            'sec': 'apic_trunk',
            'groupSynMechs': ESynMech, 
            'density': 'uniform'}    
    else:
        #------------------------------------------------------------------------------
        #  TCM -> E: apical
        netParams.subConnParams['TCM->E'] = {
            'preConds': {'cellType': ['TCM']}, 
            'postConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']},
            'sec': 'apic',#'apic',
            'groupSynMechs': ESynMech, 
            'density': 'uniform'}


    #------------------------------------------------------------------------------
    if cfg.alterSyn2:
        # NGF1 -> E: apic_tuft
        netParams.subConnParams['NGF1->E'] = {
            'preConds': {'pops': ['NGF1']}, 
            'postConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']},
            'sec': 'apic_uppertrunk',
            'groupSynMechs': NGFSynMech, 
            'density': 'uniform'}    
    else:
        # NGF1 -> E: apic_tuft
        netParams.subConnParams['NGF1->E'] = {
            'preConds': {'pops': ['NGF1']}, 
            'postConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']},
            'sec': 'apic_tuft',
            'groupSynMechs': NGFSynMech, 
            'density': 'uniform'} 


    #------------------------------------------------------------------------------
    # E -> E5,6: soma,dendrites (all)
    if cfg.alterSyn3:
        netParams.subConnParams['E->E5,6'] = {
            'preConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']}, 
            'postConds': {'pops': ['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6']},
            'sec': 'proximal',
            'groupSynMechs': ESynMech, 
            'density': 'uniform'}
    else:
        netParams.subConnParams['E->E5,6'] = {
            'preConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']}, 
            'postConds': {'pops': ['IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6']},
            'sec': 'all',
            'groupSynMechs': ESynMech, 
            'density': 'uniform'}

also has split up E -> E2 as targetting Bdend synapses, vs E -> E3,E4 as targeting proximal (soma, dendrites)

and this to more specifically target populations from thal -> ctx:
#------------------------------------------------------------------------------
## Thalamocortical - this was added from Christoph Metzner's branch
if cfg.addConn and cfg.addThalamoCorticalConn:
    for pre in TEpops+TIpops:
        for post in Epops+Ipops:
            scaleFactor = 1.0
            if post in pmat[pre]:
                # for syns use ESynMech, SOMESynMech and SOMISynMech 
                if pre in TEpops:     # E->E/I
                    if post=='PV4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4PV#25
                    elif post=='SOM4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4SOM
                    elif post=='ITS4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4E#25
                    elif post=='ITP4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4E#25
                    elif post=='NGF4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4NGF#25
                    elif post=='VIP4':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL4VIP#25
                    elif post=='NGF1':
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                        scaleFactor = cfg.thalL1NGF#25
                    else:
                        syn = ESynMech
                        synWeightFactor = cfg.synWeightFractionEE
                elif post in Epops:  # I->E
                    syn = SOMESynMech
                    synWeightFactor = cfg.synWeightFractionIE
                else:                  # I->I
                    syn = SOMISynMech
                    synWeightFactor = [1.0]
                netParams.connParams['ThCx_'+pre+'_'+post] = { 
                    'preConds': {'pop': pre}, 
                    'postConds': {'pop': post},
                    'synMech': syn,
                    'probability': '%f * exp(-dist_2D/%f)' % (pmat[pre][post], lmat[pre][post]),
                    'weight': wmat[pre][post] * cfg.thalamoCorticalGain*scaleFactor, 
                    'synMechWeightFactor': synWeightFactor,
                    'delay': 'defaultDelay+dist_3D/propVelocity',
                    'synsPerConn': 1,
                    'sec': 'soma'}                  

some of those params above also alter connectivity from L4 -> L3

** next sims. first make sure runs with new params - 24feb23_A0 (hyperactive), 24feb23_B0 (not hyperactive, with large L1 sink)

note that EEpopgain for NGF1 was set to 0.1

./myrun 48

  Done; run time = 2488.46 s; real-time ratio: 0.00.

Saving output as data/24feb23_A0/24feb23_A0_data.pkl ... 
Finished saving!
  Done; saving time = 160.00 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 816182 (11.32 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2488.46 s  <-- ~41.5 minutes
   NGF1 : 3.708 Hz
   IT2 : 1.032 Hz
   SOM2 : 55.636 Hz     
   PV2 : 1.007 Hz
   VIP2 : 0.364 Hz
   NGF2 : 1.073 Hz
   IT3 : 1.790 Hz
   SOM3 : 14.825 Hz
   PV3 : 90.119 Hz
   VIP3 : 12.391 Hz
   NGF3 : 2.604 Hz
   ITP4 : 1.846 Hz
   ITS4 : 1.890 Hz
   SOM4 : 11.684 Hz
   PV4 : 21.377 Hz
   VIP4 : 77.217 Hz
   NGF4 : 3.221 Hz
   IT5A : 3.912 Hz
   CT5A : 9.014 Hz           <<-- too fast?
   SOM5A : 26.853 Hz
   PV5A : 1.167 Hz
   VIP5A : 82.384 Hz
   NGF5A : 443.068 Hz        <<-- way too fast!!
   IT5B : 42.819 Hz
   CT5B : 28.350 Hz
   PT5B : 9.212 Hz
   SOM5B : 10.575 Hz
   PV5B : 0.488 Hz
   VIP5B : 54.875 Hz
   NGF5B : 465.833 Hz        <<-- way too fast!!
   IT6 : 7.145 Hz
   CT6 : 13.455 Hz
   SOM6 : 5.452 Hz
   PV6 : 0.131 Hz
   VIP6 : 0.198 Hz
   NGF6 : 461.574 Hz         <<-- way too fast!!
   TC : 43.358 Hz
   TCM : 34.569 Hz
   HTC : 36.732 Hz
   IRE : 11.449 Hz
   IREM : 8.111 Hz
   TI : 0.556 Hz
   TIM : 0.367 Hz
   IC : 2.115 Hz

python -i simdat.py 24feb23_A0

NGF1 4.3 Hz
IT2 0.0 Hz
SOM2 77.4 Hz
PV2 0.0 Hz
VIP2 0.0 Hz
NGF2 1.36 Hz
IT3 0.0 Hz
SOM3 0.0 Hz
PV3 92.1 Hz
VIP3 13.35 Hz
NGF3 3.01 Hz
ITP4 0.75 Hz
ITS4 0.91 Hz
SOM4 0.17 Hz
PV4 18.67 Hz
VIP4 88.46 Hz
NGF4 3.36 Hz
IT5A 3.62 Hz
CT5A 6.82 Hz
SOM5A 0.0 Hz
PV5A 0.0 Hz
VIP5A 102.1 Hz
NGF5A 472.25 Hz
IT5B 43.48 Hz
CT5B 26.81 Hz
PT5B 8.43 Hz
SOM5B 1.24 Hz
PV5B 0.0 Hz
VIP5B 73.12 Hz
NGF5B 499.83 Hz
IT6 2.54 Hz
CT6 10.37 Hz
SOM6 0.0 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 559.82 Hz
TC 37.24 Hz
TCM 35.3 Hz
HTC 38.26 Hz
IRE 10.24 Hz
IREM 8.53 Hz
TI 0.2 Hz
TIM 0.25 Hz
IC 5.67 Hz

this model is hyperactive currently ... 

savefig(gifpath()+'_rast.png') # [[./gif/24feb23_24feb23_A0_rast.png]]

xlim((3e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb23_24feb23_A0_rastB.png]]

from netpyne import sim

fn = 'data/24feb23_A0/24feb23_A0_data.pkl'

sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb23_24feb23_A0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb23_24feb23_A0_CSD__CSD_overlay_a3.png]]

dynamics way off ... possibly due to lower gain to NGF1 ... (cfg.EICellTypeGain) ?? no, that is actually
overwritten with cfgLoad from trial_2142_cfg.json so not using the NGF 0.1 value

noticed that accidentally included CM's EEPopGain and EIPopGain ... will try with the previous ones

try with the adjustments as ... 24feb23_B0

./myrun 48

  Spikes: 287231 (3.98 Hz)
  Simulated time: 5.5 s; 48 workers
  Run time: 2479.97 s
   NGF1 : 0.273 Hz
   IT2 : 4.766 Hz
   SOM2 : 53.055 Hz
   PV2 : 46.769 Hz
   VIP2 : 0.920 Hz
   NGF2 : 16.873 Hz
   IT3 : 0.505 Hz
   SOM3 : 19.072 Hz
   PV3 : 36.389 Hz
   VIP3 : 24.949 Hz
   NGF3 : 8.899 Hz
   ITP4 : 3.027 Hz
   ITS4 : 2.459 Hz
   SOM4 : 33.700 Hz
   PV4 : 2.791 Hz
   VIP4 : 5.538 Hz
   NGF4 : 12.364 Hz
   IT5A : 2.092 Hz
   CT5A : 0.456 Hz
   SOM5A : 29.390 Hz
   PV5A : 0.864 Hz
   VIP5A : 3.172 Hz
   NGF5A : 0.864 Hz
   IT5B : 1.976 Hz
   CT5B : 0.285 Hz
   PT5B : 0.170 Hz
   SOM5B : 47.333 Hz
   PV5B : 0.453 Hz
   VIP5B : 0.602 Hz
   NGF5B : 1.386 Hz
   IT6 : 2.697 Hz
   CT6 : 3.973 Hz
   SOM6 : 80.507 Hz
   PV6 : 0.153 Hz
   VIP6 : 1.851 Hz
   NGF6 : 108.402 Hz
   TC : 6.729 Hz
   TCM : 3.976 Hz
   HTC : 6.049 Hz
   IRE : 4.184 Hz
   IREM : 2.020 Hz
   TI : 3.000 Hz
   TIM : 3.367 Hz
   IC : 2.115 Hz

ok, that's better . . . 

python -i simdat.py 24feb23_B0

NGF1 0.51 Hz
IT2 2.14 Hz
SOM2 38.6 Hz
PV2 81.15 Hz
VIP2 0.69 Hz
NGF2 17.0 Hz
IT3 0.03 Hz
SOM3 2.34 Hz
PV3 35.44 Hz
VIP3 46.89 Hz
NGF3 8.44 Hz
ITP4 3.18 Hz
ITS4 2.62 Hz
SOM4 33.25 Hz
PV4 2.27 Hz
VIP4 0.15 Hz
NGF4 11.93 Hz
IT5A 2.48 Hz
CT5A 1.11 Hz
SOM5A 21.65 Hz
PV5A 0.42 Hz
VIP5A 3.1 Hz
NGF5A 0.75 Hz
IT5B 5.48 Hz
CT5B 0.57 Hz
PT5B 0.44 Hz
SOM5B 47.37 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 0.96 Hz
IT6 2.04 Hz
CT6 4.55 Hz
SOM6 91.52 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 138.76 Hz
TC 8.73 Hz
TCM 5.32 Hz
HTC 6.95 Hz
IRE 4.98 Hz
IREM 2.8 Hz
TI 2.41 Hz
TIM 2.86 Hz
IC 5.67 Hz

firing rates better than previous sim ... 

savefig(gifpath()+'_rast.png') # [[./gif/24feb23_24feb23_B0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb23_24feb23_B0_rastB.png]]

from netpyne import sim

fn = 'data/24feb23_B0/24feb23_B0_data.pkl'

sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb23_24feb23_B0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb23_24feb23_B0_CSD__CSD_overlay_a3.png]]

ok, that's how it looked before with pretty strong sink in L1, will use that as starting point ...

* 24feb26
** update from CM

CM mentioned most of his adjustments did not reduce the L1 sink

*** from slack

So, a quick update:
Haven't yet been able to discern which of the incoming recurrent exc. connections to the IT2 cells is mainly responsible for the L1 sink
Moving all rec exc. synapses to IT2 cells to Bdend  did not result in a change to the L1/L2 sink/source pair
I have now modified the cell file for the IT2 cells and increased the number of segments on Bdend to nseg=5
Trying to specify a location in the setup of the subcellular connectivity, like this
# E -> E2: lower basal dendrite
    netParams.subConnParams['E->E2'] = {
        'preConds': {'cellType': ['IT', 'ITS4', 'PT', 'CT']}, 
        'postConds': {'pops': ['IT2']},
        'sec': 'Bdend',
        'loc': cfg.L2RecExcLoc,
        'groupSynMechs': ESynMech, 
        'density': 'uniform'} 
where cfg.L2RecExcLoc = 0.2  for example, did not work. It resulted in an error when setting up the connections
traceback (most recent call last):
  File "init_artFB_alterSyn.py", line 31, in <module>
    sim.net.connectCells()                              # create connections between cells based on params
    ^^^^^^^^^^^^^^^^^^^^^^
  File "/mnt/antares_raid/home/cmetzner/miniconda3/envs/a1model/lib/python3.11/site-packages/netpyne/network/conn.py", line 137, in connectCells
    self.subcellularConn(allCellTags, allPopTags)
  File "/mnt/antares_raid/home/cmetzner/miniconda3/envs/a1model/lib/python3.11/site-packages/netpyne/network/subconn.py", line 366, in subcellularConn
    postCell.secs[newSec]['weightNorm'][int(round(newLoc * newNseg)) - 1]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
IndexError: list index out of range
It looks like I am not fully understanding the location parameter yet. (

I thought that loc specifies where, in relative terms, along the dendritic compartment a synapse will be placed and that nseg  basically defines the resolution one has here. (edited) 

However, I don't understand why I am getting the error here.

The error seems to come from the weight normalization

sn>

that's interesting. so none of the adjustments seemed to produce the desired result. as a quick check, what about
changing excitatory synaspses instead of moving to a closer Bdend, directly to soma?
not as a long-term solution, just as a test

is the error due to altered nseg or location? could try separating out ... will take a look at some of those changes soon as i can

** test diff location of supragranular E synapses (24feb26_A0) -->> still wrong sink/source pattern in L1,L2

test E->E2 synaptic locations to soma; make cfg.alterSyn move the synapses of TCM -> E to soma; put TC -> E targetting soma

./myrun 48

   NGF1 : 1.201 Hz
   IT2 : 1.289 Hz
   SOM2 : 23.273 Hz
   PV2 : 8.294 Hz
   VIP2 : 7.750 Hz
   NGF2 : 41.764 Hz
   IT3 : 1.858 Hz
   SOM3 : 26.609 Hz
   PV3 : 21.842 Hz
   VIP3 : 25.248 Hz
   NGF3 : 22.900 Hz
   ITP4 : 2.303 Hz
   ITS4 : 2.160 Hz
   SOM4 : 14.806 Hz
   PV4 : 9.966 Hz
   VIP4 : 25.958 Hz
   NGF4 : 30.455 Hz
   IT5A : 2.420 Hz
   CT5A : 4.689 Hz
   SOM5A : 23.576 Hz
   PV5A : 4.899 Hz
   VIP5A : 21.495 Hz
   NGF5A : 43.273 Hz
   IT5B : 3.594 Hz
   CT5B : 2.250 Hz
   PT5B : 2.660 Hz
   SOM5B : 29.014 Hz
   PV5B : 2.494 Hz
   VIP5B : 17.443 Hz
   NGF5B : 57.871 Hz
   IT6 : 5.599 Hz
   CT6 : 4.455 Hz
   SOM6 : 30.584 Hz
   PV6 : 43.019 Hz
   VIP6 : 40.430 Hz
   NGF6 : 86.373 Hz
   TC : 11.347 Hz
   TCM : 6.958 Hz
   HTC : 9.150 Hz
   IRE : 5.251 Hz
   IREM : 2.481 Hz
   TI : 2.553 Hz
   TIM : 2.993 Hz
   IC : 2.115 Hz

python -i simdat.py 24feb26_A0

NGF1 1.54 Hz
IT2 0.02 Hz
SOM2 1.8 Hz
PV2 1.77 Hz
VIP2 27.69 Hz
NGF2 5.27 Hz
IT3 0.03 Hz
SOM3 0.0 Hz
PV3 2.33 Hz
VIP3 9.88 Hz
NGF3 4.71 Hz
ITP4 0.24 Hz
ITS4 0.32 Hz
SOM4 0.12 Hz
PV4 0.05 Hz
VIP4 3.85 Hz
NGF4 4.86 Hz
IT5A 0.29 Hz
CT5A 0.01 Hz
SOM5A 1.14 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 3.62 Hz
IT5B 2.79 Hz
CT5B 0.01 Hz
PT5B 0.06 Hz
SOM5B 16.87 Hz
PV5B 0.0 Hz
VIP5B 0.18 Hz
NGF5B 2.29 Hz
IT6 0.01 Hz
CT6 0.19 Hz
SOM6 0.54 Hz
PV6 144.05 Hz
VIP6 105.25 Hz
NGF6 8.61 Hz
TC 6.24 Hz
TCM 3.92 Hz
HTC 5.42 Hz
IRE 3.37 Hz
IREM 3.21 Hz
TI 1.27 Hz
TIM 2.84 Hz
IC 5.67 Hz

most rates are ok

savefig(gifpath()+'_rast.png') # [[./gif/24feb26_24feb26_A0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb26_24feb26_A0_rastB.png]]

from netpyne import sim

fn = 'data/24feb26_A0/24feb26_A0_data.pkl'

sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb26_24feb26_A0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb26_24feb26_A0_CSD__CSD_overlay_a3.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a4.png') # [[./gif/24feb26_24feb26_A0_CSD__CSD_overlay_a4.png]]

still see a large sink in L1 and large source in L2, which should be transposed vertically

** next sim (24feb26_B0) - target Bdend -->> hyperexcit

fig 1 from 
https://www.cell.com/cell-reports/pdf/S2211-1247(23)01390-6.pdf
shows basal dends pointing somewhat downward, so try putting synapses there instead of soma

especially for IT2, this could make a diff in sink location ...

according to CM that did not work and that's why he's increasing nseg to allow deeper positioning of synaptic inpts
however ... thought that 0,1 (endpoints) already accessible ... 

for next test will try alterSyn2 (=1) to place NGF1->E at Bdend
and E->E2,E->E3,4 at Bdend
TCM,TC -> E at Bdend (alterSyn=1)

./myrun 48

   NGF1 : 8.867 Hz
   IT2 : 0.187 Hz
   SOM2 : 0.655 Hz
   PV2 : 0.182 Hz
   VIP2 : 23.807 Hz
   NGF2 : 341.945 Hz
   IT3 : 1.354 Hz
   SOM3 : 18.242 Hz
   PV3 : 0.183 Hz
   VIP3 : 70.315 Hz
   NGF3 : 94.751 Hz
   ITP4 : 13.780 Hz
   ITS4 : 13.597 Hz
   SOM4 : 56.119 Hz
   PV4 : 1.029 Hz
   VIP4 : 43.441 Hz
   NGF4 : 241.130 Hz
   IT5A : 26.617 Hz
   CT5A : 16.654 Hz
   SOM5A : 48.810 Hz
   PV5A : 0.187 Hz
   VIP5A : 3.899 Hz
   NGF5A : 466.909 Hz
   IT5B : 61.793 Hz
   CT5B : 12.969 Hz
   PT5B : 21.575 Hz
   SOM5B : 16.289 Hz
   PV5B : 0.196 Hz
   VIP5B : 0.409 Hz
   NGF5B : 458.379 Hz
   IT6 : 13.022 Hz
   CT6 : 16.291 Hz
   SOM6 : 6.098 Hz
   PV6 : 1.220 Hz
   VIP6 : 0.975 Hz
   NGF6 : 406.100 Hz
   TC : 43.484 Hz
   TCM : 42.819 Hz
   HTC : 39.789 Hz
   IRE : 8.593 Hz
   IREM : 15.181 Hz
   TI : 0.284 Hz
   TIM : 0.215 Hz
   IC : 2.115 Hz

rates got way too high ...

python -i simdat.py 24feb26_B0

NGF1 10.63 Hz
IT2 0.0 Hz
SOM2 0.0 Hz
PV2 0.0 Hz
VIP2 64.44 Hz
NGF2 262.0 Hz
IT3 0.12 Hz
SOM3 0.0 Hz
PV3 0.0 Hz
VIP3 119.63 Hz
NGF3 67.67 Hz
ITP4 9.34 Hz
ITS4 8.97 Hz
SOM4 12.42 Hz
PV4 0.0 Hz
VIP4 131.54 Hz
NGF4 208.07 Hz
IT5A 19.37 Hz
CT5A 12.72 Hz
SOM5A 3.93 Hz
PV5A 0.0 Hz
VIP5A 17.4 Hz
NGF5A 500.62 Hz
IT5B 62.87 Hz
CT5B 13.41 Hz
PT5B 21.07 Hz
SOM5B 8.88 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 578.54 Hz
IT6 4.53 Hz
CT6 10.94 Hz
SOM6 0.0 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 523.71 Hz
TC 38.11 Hz
TCM 40.83 Hz
HTC 41.47 Hz
IRE 5.95 Hz
IREM 16.48 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24feb26_24feb26_B0_rast.png]]

model totally hyperactive ...

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb26_24feb26_B0_rastB.png]]

from netpyne import sim
fn = 'data/24feb26_B0/24feb26_B0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb26_24feb26_B0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb26_24feb26_B0_CSD__CSD_overlay_a3.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a4.png') # [[./gif/24feb26_24feb26_B0_CSD__CSD_overlay_a4.png]]

those changes might help shift the sink location but overall the changes are just resulting in hyperactivity
so it could be masking the effect

** next sim (24feb26_C0) - target Bdend, but not for TC->E (targets prox), move NGF->E to apic_tuft loc=1

also, alterSyn2 changes location of inhibitory synapses from NGF1 -> E; those should probably remain
at top of L1, and not move lower ... so do not need that adjustment (original synaptic location is apic_tuft)
but can move their loc == 1.0 to move it to very top of L1

for NGF2,3,4->E2,3,4 move that to apic_tuft at loc == 1.0

for TCM -> E place the synapse at Bdend (alterSyn=1) with loc == 1.0, to make it lowest depth possible

./myrun 48

   NGF1 : 0.273 Hz
   IT2 : 4.766 Hz
   SOM2 : 53.055 Hz
   PV2 : 46.769 Hz
   VIP2 : 0.920 Hz
   NGF2 : 16.873 Hz
   IT3 : 0.505 Hz
   SOM3 : 19.072 Hz
   PV3 : 36.389 Hz
   VIP3 : 24.949 Hz
   NGF3 : 8.899 Hz
   ITP4 : 3.027 Hz
   ITS4 : 2.459 Hz
   SOM4 : 33.700 Hz
   PV4 : 2.791 Hz
   VIP4 : 5.538 Hz
   NGF4 : 12.364 Hz
   IT5A : 2.092 Hz
   CT5A : 0.456 Hz
   SOM5A : 29.390 Hz
   PV5A : 0.864 Hz
   VIP5A : 3.172 Hz
   NGF5A : 0.864 Hz
   IT5B : 1.976 Hz
   CT5B : 0.285 Hz
   PT5B : 0.170 Hz
   SOM5B : 47.333 Hz
   PV5B : 0.453 Hz
   VIP5B : 0.602 Hz
   NGF5B : 1.386 Hz
   IT6 : 2.697 Hz
   CT6 : 3.973 Hz
   SOM6 : 80.507 Hz
   PV6 : 0.153 Hz
   VIP6 : 1.851 Hz
   NGF6 : 108.402 Hz
   TC : 6.729 Hz
   TCM : 3.976 Hz
   HTC : 6.049 Hz
   IRE : 4.184 Hz
   IREM : 2.020 Hz
   TI : 3.000 Hz
   TIM : 3.367 Hz
   IC : 2.115 Hz

these rates are better than last simulation ... 

python -i simdat.py 24feb26_C0

NGF1 0.51 Hz
IT2 2.14 Hz
SOM2 38.6 Hz
PV2 81.15 Hz
VIP2 0.69 Hz
NGF2 17.0 Hz
IT3 0.03 Hz
SOM3 2.34 Hz
PV3 35.44 Hz
VIP3 46.89 Hz
NGF3 8.44 Hz
ITP4 3.18 Hz
ITS4 2.62 Hz
SOM4 33.25 Hz
PV4 2.27 Hz
VIP4 0.15 Hz
NGF4 11.93 Hz
IT5A 2.48 Hz
CT5A 1.11 Hz
SOM5A 21.65 Hz
PV5A 0.42 Hz
VIP5A 3.1 Hz
NGF5A 0.75 Hz
IT5B 5.48 Hz
CT5B 0.57 Hz
PT5B 0.44 Hz
SOM5B 47.37 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 0.96 Hz
IT6 2.04 Hz
CT6 4.55 Hz
SOM6 91.52 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 138.76 Hz
TC 8.73 Hz
TCM 5.32 Hz
HTC 6.95 Hz
IRE 4.98 Hz
IREM 2.8 Hz
TI 2.41 Hz
TIM 2.86 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24feb26_24feb26_C0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb26_24feb26_C0_rastB.png]]

from netpyne import sim
fn = 'data/24feb26_C0/24feb26_C0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb26_24feb26_C0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb26_24feb26_C0_CSD__CSD_overlay_a3.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a4.png') # [[./gif/24feb26_24feb26_C0_CSD__CSD_overlay_a4.png]]

L1 sink/source pattern still not improved ... have to look further why ... 

** next sim (24feb26_D0) - also move TC->E to loc=1 of Bdend of only IT2, IT3

that led to hyperexcit, but could split it based on IT2,IT3 and deeper layers ... 

    #------------------------------------------------------------------------------
    #  TC -> E2,3: bdend or proximal
    netParams.subConnParams['TC->E2,3'] = {
        'preConds': {'cellType': ['TC', 'HTC']}, 
        'postConds': {'cellType': ['IT2', 'IT3']},
        'sec': 'Bdend', # 'proximal'
        'groupSynMechs': ESynMech, 
        'density': 'uniform', 'loc': 1.0}

    #------------------------------------------------------------------------------
    #  TC -> E: proximal
    netParams.subConnParams['TC->E'] = {
        'preConds': {'cellType': ['TC', 'HTC']}, 
        'postConds': {'cellType': ['ITP4', 'ITS4', 'IT5A', 'IT5B', 'IT6', 'PT', 'CT']},
        'sec': 'proximal',
        'groupSynMechs': ESynMech, 
        'density': 'uniform'} 

ok, try with that addition ...

./myrun 48

  Run time: 2302.33 s
   NGF1 : 1.457 Hz
   IT2 : 1.272 Hz
   SOM2 : 19.564 Hz
   PV2 : 14.070 Hz
   VIP2 : 2.455 Hz
   NGF2 : 77.600 Hz
   IT3 : 3.628 Hz
   SOM3 : 46.140 Hz
   PV3 : 33.749 Hz
   VIP3 : 49.070 Hz
   NGF3 : 38.989 Hz
   ITP4 : 3.126 Hz
   ITS4 : 2.834 Hz
   SOM4 : 22.150 Hz
   PV4 : 23.734 Hz
   VIP4 : 45.636 Hz
   NGF4 : 43.792 Hz
   IT5A : 3.184 Hz
   CT5A : 6.773 Hz
   SOM5A : 50.740 Hz
   PV5A : 6.699 Hz
   VIP5A : 52.141 Hz
   NGF5A : 82.659 Hz
   IT5B : 3.014 Hz
   CT5B : 9.139 Hz
   PT5B : 2.887 Hz
   SOM5B : 43.301 Hz
   PV5B : 2.569 Hz
   VIP5B : 35.352 Hz
   NGF5B : 109.614 Hz
   IT6 : 6.698 Hz
   CT6 : 8.540 Hz
   SOM6 : 24.450 Hz
   PV6 : 6.083 Hz
   VIP6 : 12.331 Hz
   NGF6 : 190.349 Hz
   TC : 19.374 Hz
   TCM : 6.258 Hz
   HTC : 15.410 Hz
   IRE : 7.757 Hz
   IREM : 1.193 Hz
   TI : 3.924 Hz
   TIM : 3.360 Hz
   IC : 2.115 Hz

python -i simdat.py 24feb26_D0

NGF1 0.1 Hz
IT2 0.01 Hz
SOM2 1.6 Hz
PV2 0.08 Hz
VIP2 0.0 Hz
NGF2 101.55 Hz
IT3 7.8 Hz
SOM3 106.7 Hz
PV3 12.7 Hz
VIP3 0.75 Hz
NGF3 59.19 Hz
ITP4 0.04 Hz
ITS4 0.03 Hz
SOM4 27.08 Hz
PV4 29.5 Hz
VIP4 15.0 Hz
NGF4 19.5 Hz
IT5A 1.31 Hz
CT5A 1.72 Hz
SOM5A 110.44 Hz
PV5A 5.78 Hz
VIP5A 0.0 Hz
NGF5A 0.12 Hz
IT5B 0.14 Hz
CT5B 0.05 Hz
PT5B 0.0 Hz
SOM5B 119.66 Hz
PV5B 0.31 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 0.14 Hz
CT6 0.4 Hz
SOM6 27.97 Hz
PV6 31.92 Hz
VIP6 59.75 Hz
NGF6 36.0 Hz
TC 8.71 Hz
TCM 4.08 Hz
HTC 7.29 Hz
IRE 2.85 Hz
IREM 1.85 Hz
TI 2.9 Hz
TIM 3.63 Hz
IC 5.67 Hz

this one is too hyperexcitable...

savefig(gifpath()+'_rast.png') # [[./gif/24feb27_24feb26_D0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24feb27_24feb26_D0_rastB.png]]

from netpyne import sim
fn = 'data/24feb26_D0/24feb26_D0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/24feb27_24feb26_D0_CSD__CSD_overlay_a2.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.6e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/24feb27_24feb26_D0_CSD__CSD_overlay_a3.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) 
savefig(gifpath()+'_CSD__CSD_overlay_a4.png') # [[./gif/24feb27_24feb26_D0_CSD__CSD_overlay_a4.png]]

the red vs blue coloring seems inconsistent, in L1 positive values are drawn in red, but in L4, negative values are drawn in red

* 24feb27
** continuing from last entry - checking CSD -->> color (red vs blue) not consistent and offset improperly vertically - padding?

hmm, take a closer look at how the color values are calculated ...

CSDData, LFPData, sampr, spacing_um, dt = sim.analysis.prepareCSD(sim=sim,timeRange=[0e3,5.5e3])

timeRange=[0e3,5.5e3]

X = np.arange(timeRange[0], timeRange[1], dt)  # X == tt
Y = np.arange(CSDData.shape[0])

import scipy

# interpolation
CSD_spline = scipy.interpolate.RectBivariateSpline(Y, X, CSDData)
Y_plot = np.linspace(0, CSDData.shape[0], num=1000)
Z = CSD_spline(Y_plot, X)

Z.shape # (1000, 110000)

CSDData.shape # (20, 110000)

so there are 50 interpolated time series for each of the original CSD time series

for i in range(50): plot(Z[i,:])

savefig(gifpath()+'_indiv_first_50_CSD_interp_a6.png') # [[./gif/24feb27_24feb26_D0_indiv_first_50_CSD_interp_a6.png]]

Z.shape # (5, 110000)

CSDData.shape # (20, 110000)

so there are 50 interpolated time series for each of the original CSD time series

xmin = int(X[0])
xmax = int(X[-1]) + 1
ymin = 0
ymax = sim.cfg.recordLFP[-1][1] + spacing_um
extent_xy = [xmin, xmax, ymax, ymin]

figure()
imshow(Z, extent=extent_xy, interpolation='none', aspect='auto', origin='upper', cmap='jet_r')

padding top/bottom portion of CSD might help?

X = np.arange(timeRange[0], timeRange[1], dt)
Y = np.arange(CSDData.shape[0])
CSD_spline = scipy.interpolate.RectBivariateSpline(Y, X, CSDData)

npcsd = []
for i in range(25): npcsd.append(CSDData[0,:])
for i in range(CSDData.shape[0]): npcsd.append(CSDData[i,:])
for i in range(25): npcsd.append(CSDData[-1,:])
npcsd=np.array(npcsd)
npcsd.shape # (70, 110000)

X = np.arange(timeRange[0], timeRange[1], dt)
Y = np.arange(npcsd.shape[0])
CSD_spline = scipy.interpolate.RectBivariateSpline(Y, X, npcsd)

offset=0 # 5
Y_plot = np.linspace(-offset, npcsd.shape[0] + offset, num=1000)
Z = CSD_spline(Y_plot, X)
xmin = int(X[0])
xmax = int(X[-1]) + 1
ymin = 0
ymax = sim.cfg.recordLFP[-1][1] + spacing_um
# offset = Z.shape[0] / npcsd.shape[0]
#Y_plot = np.linspace(offset, npcsd.shape[0] + offset, num=100)
extent_xy = [xmin, xmax, ymax, ymin]
# Z = CSD_spline(Y_plot, X)
figure()
imshow(Z, extent=extent_xy, interpolation='none', aspect='auto', origin='upper', cmap='jet_r')

savefig(gifpath()+'_pad_top_bottom_CSD_interp_a7.png') # [[./gif/24feb27_24feb26_D0_pad_top_bottom_CSD_interp_a7.png]]

* 24feb28
** continue fixing CSD plot

def drawCSD (pad):
  npcsd = []
  for i in range(pad): npcsd.append(CSDData[0,:])
  for i in range(CSDData.shape[0]): npcsd.append(CSDData[i,:])
  for i in range(pad): npcsd.append(CSDData[-1,:])
  npcsd=np.array(npcsd)
  npcsd.shape # (22, 110000)
  X = np.arange(timeRange[0], timeRange[1], dt)
  Y = np.arange(npcsd.shape[0])
  CSD_spline = scipy.interpolate.RectBivariateSpline(Y, X, npcsd)
  offset = pad
  Y_plot = np.linspace(-offset, npcsd.shape[0] + offset, num=int(1000*npcsd.shape[0]/CSDData.shape[0]))
  Z = CSD_spline(Y_plot, X)[pad*50:pad*50+1000,:]
  xmin = int(X[0])
  xmax = int(X[-1]) + 1
  ymin = -offset
  ymax = sim.cfg.recordLFP[-1][1] + spacing_um + offset
  extent_xy = [xmin, xmax, ymax, ymin]
  figure()
  imshow(Z, extent=extent_xy, interpolation='none', aspect='auto', origin='upper', cmap='jet_r')
  return npcsd, Z

npcsd, Z = drawCSD(pad=1)

savefig(gifpath()+'_pad_1_top_bottom_CSD_interp_a8.png') # [[./gif/24feb28_24feb26_D0_pad_1_top_bottom_CSD_interp_a8.png]]

ok, try putting that into plotCSD.py plotCSD function ... 

python -i simdat.py 24feb26_D0

from netpyne import sim
fn = 'data/24feb26_D0/24feb26_D0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a9.png') # [[./gif/24feb28_24feb26_D0_CSD__CSD_overlay_pad1_a9.png]]

* 24mar1
** undo most of the synaptic location changes (24mar1_A0) -->> this one still hyperexcitable

before all the changes associated with L1 sink

ok, turned most of the synaptic locations back to where they were

and try that out  ... 

./myrun 48

   NGF1 : 1.457 Hz
   IT2 : 1.272 Hz
   SOM2 : 19.564 Hz
   PV2 : 14.070 Hz
   VIP2 : 2.455 Hz
   NGF2 : 77.600 Hz
   IT3 : 3.628 Hz
   SOM3 : 46.140 Hz
   PV3 : 33.749 Hz
   VIP3 : 49.070 Hz
   NGF3 : 38.989 Hz
   ITP4 : 3.126 Hz
   ITS4 : 2.834 Hz
   SOM4 : 22.150 Hz
   PV4 : 23.734 Hz
   VIP4 : 45.636 Hz
   NGF4 : 43.792 Hz
   IT5A : 3.184 Hz
   CT5A : 6.773 Hz
   SOM5A : 50.740 Hz
   PV5A : 6.699 Hz
   VIP5A : 52.141 Hz
   NGF5A : 82.659 Hz
   IT5B : 3.014 Hz
   CT5B : 9.139 Hz
   PT5B : 2.887 Hz
   SOM5B : 43.301 Hz
   PV5B : 2.569 Hz
   VIP5B : 35.352 Hz
   NGF5B : 109.614 Hz
   IT6 : 6.698 Hz
   CT6 : 8.540 Hz
   SOM6 : 24.450 Hz
   PV6 : 6.083 Hz
   VIP6 : 12.331 Hz
   NGF6 : 190.349 Hz
   TC : 19.374 Hz
   TCM : 6.258 Hz
   HTC : 15.410 Hz
   IRE : 7.757 Hz
   IREM : 1.193 Hz
   TI : 3.924 Hz
   TIM : 3.360 Hz
   IC : 2.115 Hz

hmm, some rates too high again ... 

python -i simdat.py 24mar1_A0

savefig(gifpath()+'_rast.png') # [[./gif/24mar4_24mar1_A0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24mar4_24mar1_A0_rastB.png]]

looks very hyperexcitable ...

from netpyne import sim
fn = 'data/24mar1_A0/24mar1_A0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a9.png') # [[./gif/24mar4_24mar1_A0_CSD__CSD_overlay_pad1_a9.png]]

* 24mar4
** continue adjustments -- reducing hyperexcitability (24mar4_A0)

restore couple of other minor adjustments, NGF2,3,4->E2,3,4 was at apic_trunk before the changes, (in last sim it
was in apic_tuft), so restore it and rerun; also had a few leftover loc == 1.0, so remove those changes too

./myrun 48

   NGF1 : 1.457 Hz
   IT2 : 1.272 Hz
   SOM2 : 19.564 Hz
   PV2 : 14.070 Hz
   VIP2 : 2.455 Hz
   NGF2 : 77.600 Hz
   IT3 : 3.628 Hz
   SOM3 : 46.140 Hz
   PV3 : 33.749 Hz
   VIP3 : 49.070 Hz
   NGF3 : 38.989 Hz
   ITP4 : 3.126 Hz
   ITS4 : 2.834 Hz
   SOM4 : 22.150 Hz
   PV4 : 23.734 Hz
   VIP4 : 45.636 Hz
   NGF4 : 43.792 Hz
   IT5A : 3.184 Hz
   CT5A : 6.773 Hz
   SOM5A : 50.740 Hz
   PV5A : 6.699 Hz
   VIP5A : 52.141 Hz
   NGF5A : 82.659 Hz
   IT5B : 3.014 Hz
   CT5B : 9.139 Hz
   PT5B : 2.887 Hz
   SOM5B : 43.301 Hz
   PV5B : 2.569 Hz
   VIP5B : 35.352 Hz
   NGF5B : 109.614 Hz
   IT6 : 6.698 Hz
   CT6 : 8.540 Hz
   SOM6 : 24.450 Hz
   PV6 : 6.083 Hz
   VIP6 : 12.331 Hz
   NGF6 : 190.349 Hz
   TC : 19.374 Hz
   TCM : 6.258 Hz
   HTC : 15.410 Hz
   IRE : 7.757 Hz
   IREM : 1.193 Hz
   TI : 3.924 Hz
   TIM : 3.360 Hz
   IC : 2.115 Hz

not surprisingly, those small adjustments did not make a difference in hyperexcitability in L5

which was the last sim that did not display hyperexcitability?

24feb12_A0 had decent firing rates ... check its params

https://github.com/NathanKlineInstitute/A1/commit/86c2318d1c99dd0e4af19b47f0a29aecee0daab7
https://github.com/NathanKlineInstitute/A1/blob/86c2318d1c99dd0e4af19b47f0a29aecee0daab7/cfg.py

had this EEPopGain:
cfg.EEPopGain = {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.05, 'CT5A': 1.1500000000000001, 'IT5B': 0.425, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.05} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization

this EIPopGain:
cfg.EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.3499999999999999, 'NGF6': 0.65} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization

these other param values:

cfg.ICThalweightECore = 0.8350476447841453 # 1.0218574230414905 # 1.1366391725804097  # 0.8350476447841453 # 1.0
cfg.ICThalweightICore = 0.2114492149101151 # 0.20065170901643178 # 0.21503725192597786 # 0.2114492149101151 # 0.25
cfg.ICThalprobECore = 0.163484173596043 # 0.17524000437877066 # 0.21638972066571394   # 0.163484173596043 # 0.19
cfg.ICThalprobICore = 0.0936669688856933 # 0.0978864963550709 # 0.11831534696879886   # 0.0936669688856933 # 0.12

cfg.ICThalMatrixCoreFactor = 0.1 # 0.0988423213016316 # 0.11412487872986073 # 0.1 # this is used to scale weights to thalamic matrix neurons in netParams.py
cfg.ICThalprobEMatrix = cfg.ICThalprobECore 
cfg.ICThalprobIMatrix = cfg.ICThalprobICore 

hmm, used all those values now ... anything else differ ... ? 

so all those are same, but now have these additional parameters:
cfg.thalL4VIP = 1.0
cfg.thalL4NGF = 1.0
cfg.thalL1NGF = 1.0

cfg.ENGF1 = 1.0 # modulates strength of synaptic connections from E -> NGF1 neurons

# modulates strength of connections from L4 -> L3 by different target subpopulations
cfg.L4L3E    = 1.0
cfg.L4L3PV   = 1.0
cfg.L4L3SOM  = 1.0
cfg.L4L3VIP = 1.0
cfg.L4L3NGF = 1.0

those should be all defaults, and same as original of 1.0 ... check netParams.py

synaptic locations all the same ...

** 24mar4_B0 : commenting out some of the CM parameterizations & restoring old subconn rules leads to reduced firing rates 

./myrun 48

   NGF1 : 1.456 Hz
   IT2 : 0.243 Hz
   SOM2 : 5.891 Hz
   PV2 : 2.084 Hz
   VIP2 : 12.011 Hz
   NGF2 : 7.291 Hz
   IT3 : 0.193 Hz
   SOM3 : 1.889 Hz
   PV3 : 4.375 Hz
   VIP3 : 6.109 Hz
   NGF3 : 4.738 Hz
   ITP4 : 0.127 Hz
   ITS4 : 0.135 Hz
   SOM4 : 0.364 Hz
   PV4 : 1.752 Hz
   VIP4 : 4.923 Hz
   NGF4 : 4.597 Hz
   IT5A : 1.025 Hz
   CT5A : 0.162 Hz
   SOM5A : 2.944 Hz
   PV5A : 0.412 Hz
   VIP5A : 1.253 Hz
   NGF5A : 1.886 Hz
   IT5B : 1.214 Hz
   CT5B : 0.039 Hz
   PT5B : 0.061 Hz
   SOM5B : 16.504 Hz
   PV5B : 0.357 Hz
   VIP5B : 1.455 Hz
   NGF5B : 1.356 Hz
   IT6 : 0.088 Hz
   CT6 : 0.160 Hz
   SOM6 : 3.180 Hz
   PV6 : 69.890 Hz
   VIP6 : 60.264 Hz
   NGF6 : 8.019 Hz
   TC : 4.808 Hz
   TCM : 3.827 Hz
   HTC : 4.565 Hz
   IRE : 2.776 Hz
   IREM : 2.720 Hz
   TI : 1.775 Hz
   TIM : 3.145 Hz
   IC : 2.115 Hz

python -i simdat.py 24mar4_B0

NGF1 1.59 Hz
IT2 0.01 Hz
SOM2 0.0 Hz
PV2 0.46 Hz
VIP2 11.56 Hz
NGF2 4.64 Hz
IT3 0.06 Hz
SOM3 0.0 Hz
PV3 0.89 Hz
VIP3 4.94 Hz
NGF3 4.45 Hz
ITP4 0.08 Hz
ITS4 0.06 Hz
SOM4 0.04 Hz
PV4 3.35 Hz
VIP4 0.46 Hz
NGF4 3.5 Hz
IT5A 0.45 Hz
CT5A 0.01 Hz
SOM5A 0.42 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 2.38 Hz
IT5B 1.16 Hz
CT5B 0.06 Hz
PT5B 0.04 Hz
SOM5B 14.1 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 1.38 Hz
IT6 0.22 Hz
CT6 0.04 Hz
SOM6 0.43 Hz
PV6 113.52 Hz
VIP6 96.17 Hz
NGF6 7.42 Hz
TC 5.81 Hz
TCM 3.7 Hz
HTC 4.95 Hz
IRE 3.35 Hz
IREM 2.83 Hz
TI 1.55 Hz
TIM 2.92 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24mar4_24mar4_B0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24mar4_24mar4_B0_rastB.png]]

from netpyne import sim
fn = 'data/24mar4_B0/24mar4_B0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a9.png') # [[./gif/24mar4_24mar4_B0_CSD__CSD_overlay_pad1_a9.png]]

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[3e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a10.png') # [[./gif/24mar4_24mar4_B0_CSD__CSD_overlay_pad1_a10.png]]

overall looks better with those subconn rules adjusted to original ... but not clear why the CM subconn rules was
causing hyperexcitability ... 

* 24mar5
** cleanup the alterSyn code

removed the alterSyn parameters because the subConn rules using them seemed to lead to hyperexcitability, still not clear why 

can keep the scaleFactor rules

test to make sure hyperexcitability still gone, with the scaleFactor rules

24mar5_A0

   NGF1 : 0.273 Hz
   IT2 : 4.766 Hz
   SOM2 : 53.055 Hz
   PV2 : 46.769 Hz
   VIP2 : 0.920 Hz
   NGF2 : 16.873 Hz
   IT3 : 0.505 Hz
   SOM3 : 19.072 Hz
   PV3 : 36.389 Hz
   VIP3 : 24.949 Hz
   NGF3 : 8.899 Hz
   ITP4 : 3.027 Hz
   ITS4 : 2.459 Hz
   SOM4 : 33.700 Hz
   PV4 : 2.791 Hz
   VIP4 : 5.538 Hz
   NGF4 : 12.364 Hz
   IT5A : 2.092 Hz
   CT5A : 0.456 Hz
   SOM5A : 29.390 Hz
   PV5A : 0.864 Hz
   VIP5A : 3.172 Hz
   NGF5A : 0.864 Hz
   IT5B : 1.976 Hz
   CT5B : 0.285 Hz
   PT5B : 0.170 Hz
   SOM5B : 47.333 Hz
   PV5B : 0.453 Hz
   VIP5B : 0.602 Hz
   NGF5B : 1.386 Hz
   IT6 : 2.697 Hz
   CT6 : 3.973 Hz
   SOM6 : 80.507 Hz
   PV6 : 0.153 Hz
   VIP6 : 1.851 Hz
   NGF6 : 108.402 Hz
   TC : 6.729 Hz
   TCM : 3.976 Hz
   HTC : 6.049 Hz
   IRE : 4.184 Hz
   IREM : 2.020 Hz
   TI : 3.000 Hz
   TIM : 3.367 Hz
   IC : 2.115 Hz

hmm, these rates are different from previous sim, even with the same parameters, and the only difference
being use of CM parameterized scaleFactor ... yes, different because some of the scaleFactor values are not == 1.0
for example:
 cfg.thalL4PV = 0.21367245896786016 # 0.3201033836037148 # 0.261333644625591   # 0.21367245896786016 # 0.25 
 cfg.thalL4SOM = 0.24260966747847523 # 0.3200462291706402 # 0.2612645277258505 # 0.24260966747847523 # 0.25 
 cfg.thalL4E = 1.9540886147587417 # 2.8510831744854714 # 2.3199103007567827   # 1.9540886147587417 # 2.0

python -i simdat.py 24mar5_A0

NGF1 0.51 Hz
IT2 2.14 Hz
SOM2 38.6 Hz
PV2 81.15 Hz
VIP2 0.69 Hz
NGF2 17.0 Hz
IT3 0.03 Hz
SOM3 2.34 Hz
PV3 35.44 Hz
VIP3 46.89 Hz
NGF3 8.44 Hz
ITP4 3.18 Hz
ITS4 2.62 Hz
SOM4 33.25 Hz
PV4 2.27 Hz
VIP4 0.15 Hz
NGF4 11.93 Hz
IT5A 2.48 Hz
CT5A 1.11 Hz
SOM5A 21.65 Hz
PV5A 0.42 Hz
VIP5A 3.1 Hz
NGF5A 0.75 Hz
IT5B 5.48 Hz
CT5B 0.57 Hz
PT5B 0.44 Hz
SOM5B 47.37 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 0.96 Hz
IT6 2.04 Hz
CT6 4.55 Hz
SOM6 91.52 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 138.76 Hz
TC 8.73 Hz
TCM 5.32 Hz
HTC 6.95 Hz
IRE 4.98 Hz
IREM 2.8 Hz
TI 2.41 Hz
TIM 2.86 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24mar5_24mar5_A0_rast.png]]

xlim((4e3,5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24mar5_24mar5_A0_rastB.png]]

from netpyne import sim
fn = 'data/24mar5_A0/24mar5_A0_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a9.png') # [[./gif/24mar5_24mar5_A0_CSD__CSD_overlay_pad1_a9.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.5e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a10.png') # [[./gif/24mar5_24mar5_A0_CSD__CSD_overlay_pad1_a10.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.9e3,4.2e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 
savefig(gifpath()+'_CSD__CSD_overlay_pad1_a11.png') # [[./gif/24mar5_24mar5_A0_CSD__CSD_overlay_pad1_a11.png]]

also note:
 with vaknin correction, channel 0 csd is a source, without vaknin correction, channel csd is a sink
 the vaknin correction is used by default in netpyne; this should probably be done for the simulations and
 optimization too as it's a standard approach ... 

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05, norm=False, vaknin=True)
CSD.shape # (20, 110000)

for i in range(CSD.shape[0]):
  subplot(CSD.shape[0],1,i+1)
  plot(tt,CSD[i,:]); xlim((3900,4300))

savefig(gifpath()+'_CSD_time_series_vaknin_a12.png') # [[./gif/24mar5_24mar5_A0_CSD_time_series_vaknin_a12.png]]

note that in earlier optimization did NOT use vaknin, and used channel 10 for granular CSD optimization

d = pickle.load(open('opt/2-rb023024011@os.mat_20kHz_avgERP.pkl','rb'))

ttnhpERP = np.linspace(0,150,len(d['avgCSD'][0]))

s2,g,i1 = 11-1, 15-1, 20-1
for clr,gdx,k in zip(['r','g','b'],[1,2,3],[s2,g,i1]):
  subplot(1,3,gdx)
  plot(ttnhpERP,d['avgCSD'][k]/abs(np.sum(d['avgCSD'][k])),clr,linewidth=4)

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
lnhpchan = [11-1, 15-1, 20-1]
bbnT = np.arange(4000, 5000, 300)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from scipy.stats import pearsonr
from erp import getAvgERP

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)


gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  gdx+=1


** back to CSD/ERP fixup (24mar5_A0)

can focus on supragranular CSD next. may want to optimize it independently, keeping L4 CSD-relevant parameters fixed.

but which model channel for supragran? in experiment, supragran sink is close to granular sink, not all the way up in L2 ... 

based on chase response below, channel index 8 for vaknin-corrected CSD could be a good location to optimize for the
supragranular CSD ERP. there is a small sink there, so could probably improve it through opt.

** email NO

Another question about localization of supragranular sinks during ERPs
from BBN ...

What is the typical cortical depth of supragranular sinks? 

It looked like in a lot of the NHP data, the supragranular sink was
only a few hundred microns above the primary granular sink, so was in
the middle to bottom of L3, rather than higher up in L2. is that
right?

Thanks,
Sam

chase> Like 300 microns above? Yeah I think that’s pretty
typical. It's not always the only supra sink though. In a decent
subset of sites there is also a second sink ~L1-2. I think that's a
little less common though.

** CSD/ERP supragran opt

so will optimize these parameters controlling L4 -> L3 connection strengths
      params['L4L3E'] = [0.9, 1.1]
      params['L4L3PV'] = [0.9, 1.1]
      params['L4L3SOM'] = [0.9, 1.1]
      params['L4L3VIP'] = [0.9, 1.1]
      params['L4L3NGF'] = [0.9, 1.1]

and from model using channel index 8 from vaknin corrected CSD (which is ~300 microns above model granular sink channel that was previously optimized)
from nhp using channel 10

can use the gain modulation as well...

python
import pickle

EEPopGain = {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.05, 'CT5A': 1.1500000000000001, 'IT5B': 0.425, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.05} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization
EIPopGain = {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.3499999999999999, 'NGF6': 0.65} # this is from after generation 203 of optunaERP_23dec23_ , values used in generation 204 of the same optimization

pickle.dump(EEPopGain,open('opt/EEPopGain.pkl','wb'))
pickle.dump(EIPopGain,open('opt/EIPopGain.pkl','wb'))
quit()

python batch.py

* 24mar7
** discuss with CHM

would be good to have a way to allow broader frequency tuning of thalamic matrix
compared to thalamic core
thalamic matrix responds ~equally to different frequencies whereas thalamic core
likely has tonotopic organization (similar upstream from IC would have that tuning)
and then projecting to core
so off-best frequency inputs would lead to subthreshold responses in A1 primarily
in supragranular layers

this is how the ICThalInput is setup in cfg.py :

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat',                   
                   'startTime': list(np.arange(4000, 5000, 300)), 
                   'weightECore': cfg.ICThalweightECore,
                   'weightICore': cfg.ICThalweightICore,
                   'probECore': cfg.ICThalprobECore, 
                   'probICore': cfg.ICThalprobICore,
                   'probEMatrix': cfg.ICThalprobEMatrix,
                   'probIMatrix': cfg.ICThalprobIMatrix,
                   'MatrixCoreFactor': cfg.ICThalMatrixCoreFactor,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

and then in netParams.py projections from IC -> Thal are provided as follows:

    # cochlea/IC -> thal
    if cfg.ICThalInput:
        # IC -> thalamic core
        netParams.connParams['IC->ThalECore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probECore'],
            'weight': cfg.ICThalInput['weightECore'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalICore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probICore'],
            'weight': cfg.ICThalInput['weightICore'],
            'delay': cfg.delayBkg}

        # IC -> thalamic matrix
        netParams.connParams['IC->ThalEMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TCM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probEMatrix'],
            'weight': cfg.ICThalInput['weightEMatrix'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalIMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['IREM', 'TIM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probIMatrix'],
            'weight': cfg.ICThalInput['weightIMatrix'],
            'delay': cfg.delayBkg}  

to separate the IC _> Core vs IC -> Matrix could make two separate IC
populations. One IC population with narrow frequency selectivity projecting
to core, and one IC population with broad frequency selectivity projecting to matrix

as an alternative to UR EAR could try this:
 https://github.com/mrkrd/cochlea

some of it is used in the code in input.py

that way could do everything in python. downside is it does not include an IC model
but could create simple IC populations in NetPyNE, and then get more control of
how frequency selectivity is distributed both to IC, then thalamus, and then A1

also need thorns

https://pypi.org/project/thorns/

pip install cochlea
pip install thorns

python

import cochlea
import thorns as th
import thorns.waves as wv

fs = 100e3
sound = wv.ramped_tone(fs=fs, freq=1000, duration=0.1, dbspl=50)

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/thorns/waves.py", line 171, in ramped_tone
    ramp_signal = np.linspace(0, 1, np.ceil(ramp * fs))
  File "<__array_function__ internals>", line 6, in linspace
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/numpy/core/function_base.py", line 120, in linspace
    num = operator.index(num)
TypeError: 'numpy.float64' object cannot be interpreted as an integer

hmm, have to adjust waves.py in thorns package since np.ceil returns a float:
         ramp_signal = np.linspace(0, 1, int(np.ceil(ramp * fs)))

ok, fixed ...

fs = 100e3
sound = wv.ramped_tone(fs=fs, freq=1000, duration=0.1, dbspl=50)

anf_trains = cochlea.run_zilany2014(
    sound,
    fs,
    anf_num=(200,0,0),
    cf=1000,
    seed=0,
    species='human'
)

... ... ... ... ... ... ... Traceback (most recent call last):
  File "<stdin>", line 7, in <module>
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/zilany2014/__init__.py", line 120, in run_zilany2014
    if isinstance(np.fft.fftpack._fft_cache, dict):
AttributeError: module 'numpy.fft' has no attribute 'fftpack'

ok, got rid of that fftpack reference from __init__.py ... if this works, may want to include modified version in subdirectory here

th.plot_raster(anf_trains)
th.show()

# savefig('gif/24mar7_test_cochlea_a0.png') # [[./24mar7_test_cochlea.png]]

from input import cochlearInputSpikes

spkt = cochlearInputSpikes() 

#from cochlea import run_zilany2014
#run_zilany2014()

# python -i /opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/examples/run_zilany2014.py

import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as dsp

import thorns as th
import cochlea

fs = 100e3

# Make sound
t = np.arange(0, 0.1, 1/fs)
s = dsp.chirp(t, 80, t[-1], 20000)
s = cochlea.set_dbspl(s, 50)
pad = np.zeros(int(10e-3 * fs))
sound = np.concatenate( (s, pad) )

# Run model
anf = cochlea.run_zilany2014(
  sound,
  fs,
  anf_num=(100,0,0),
  cf=(125, 20000, 100),
  seed=0,
  powerlaw='approximate',
  species='human',
)

# Accumulate spike trains
anf_acc = th.accumulate(anf, keep=['cf', 'duration'])
anf_acc.sort_values('cf', ascending=False, inplace=True)

# Plot auditory nerve response
fig, ax = plt.subplots(2,1)
th.plot_signal(
  signal=sound,
  fs=fs,
  ax=ax[0]
)
th.plot_neurogram(
  anf_acc,
  fs,
  ax=ax[1]
)
plt.show()

** prog of opt -- trial 59 best so far

dgain: {'EEGain': {'IT2': 1.4125, 'IT3': 3.0, 'ITP4': 1.0, 'ITS4': 1.05, 'IT5A': 1.1500000000000001, 'CT5A': 1.6000000000000005, 'IT5B': 0.6250000000000001, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 1.4000000000000004, 'CT6': 1.2000000000000002}, 'EIGain': {'NGF1': 1.2000000000000002, 'SOM2': 0.6499999999999997, 'PV2': 0.25, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 3.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.1, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.7500000000000002, 'VIP5A': 1.35, 'NGF5A': 0.9500000000000002, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 1.5, 'NGF5B': 1.4000000000000004, 'SOM6': 0.95, 'PV6': 3.0, 'VIP6': 3.0, 'NGF6': 0.25}}
saving iteration output.
--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2024-03-07 16:46:19,697] Trial 58 finished with value: -0.39441599803878713 and parameters: {'L4L3E': 0.9928447505705849, 'L4L3PV': 1.0083663773769713, 'L4L3SOM': 1.0021716864506585, 'L4L3VIP': 1.0787926618416672, 'L4L3NGF': 0.9002620510016708}. Best is trial 48 with value: -0.7786639692407915.
['L4L3E', 'L4L3PV', 'L4L3SOM', 'L4L3VIP', 'L4L3NGF'] [1.0188377611592279, 0.9829655631376849, 0.9647203483395813, 1.039136847713827, 0.9119964748686543]
set L4L3E=1.0188377611592279
set L4L3PV=0.9829655631376849
set L4L3SOM=0.9647203483395813
set L4L3VIP=1.039136847713827
set L4L3NGF=0.9119964748686543
Saving simConfig to data/optunaERP_24mar5_/gen_59/trial_59_cfg.json ... 
Submitting job  trial_59
#!/bin/bash
    echo '['L4L3E', 'L4L3PV', 'L4L3SOM', 'L4L3VIP', 'L4L3NGF']'
    echo '[1.0188377611592279, 0.9829655631376849, 0.9647203483395813, 1.039136847713827, 0.9119964748686543]'
    nrniv -python -c 'from neuron import h;soma = h.Section(name="soma");h.psection();quit()'
    echo $?
    mpiexec -n 48 nrniv -python -c 'from neuron import h;h.nrnmpi_init();pc=h.ParallelContext();print(pc.id());quit()'
    echo $?
    
    mpiexec -verbose -n 48 nrniv -python -mpi init.py simConfig=data/optunaERP_24mar5_/gen_59/trial_59_cfg.json netParams=data/optunaERP_24mar5_/optunaERP_24mar5__netParams.py     
    
--------------------------------------------------------------------------------
subprocess.run returned non-zero exit status. trying to continue.
Waiting for jobs from generation 59/600 ...
fitness func
fitness is -0.7829742081909798
saveFolder is: data/optunaERP_24mar5_/gen_59
checking firing rates
drate: {'NGF1': 0.41, 'IT2': 3.86, 'SOM2': 114.6, 'PV2': 86.73, 'VIP2': 3.28, 'NGF2': 12.82, 'IT3': 0.36, 'SOM3': 11.47, 'PV3': 21.87, 'VIP3': 17.91, 'NGF3': 7.35, 'ITP4': 1.96, 'ITS4': 1.72, 'SOM4': 14.65, 'PV4': 3.09, 'VIP4': 12.5, 'NGF4': 15.21, 'IT5A': 3.99, 'CT5A': 0.14, 'SOM5A': 24.28, 'PV5A': 0.27, 'VIP5A': 1.6, 'NGF5A': 0.62, 'IT5B': 1.79, 'CT5B': 0.04, 'PT5B': 0.15, 'SOM5B': 36.9, 'PV5B': 0.01, 'VIP5B': 2.15, 'NGF5B': 0.06, 'IT6': 0.35, 'CT6': 3.06, 'SOM6': 56.65, 'PV6': 0.0, 'VIP6': 2.96, 'NGF6': 65.97, 'TC': 4.07, 'TCM': 3.69, 'HTC': 4.14, 'IRE': 4.29, 'IREM': 2.02, 'TI': 2.76, 'TIM': 3.48, 'IC': 0.0}
adjustRateGain
TC not found in dgain[EEGain]
TCM not found in dgain[EEGain]
HTC not found in dgain[EEGain]
IRE not found in dgain[EIGain]
IREM not found in dgain[EIGain]
TI not found in dgain[EIGain]
TIM not found in dgain[EIGain]
IC not found in dgain[EEGain]
dgain: {'EEGain': {'IT2': 1.4125, 'IT3': 3.0, 'ITP4': 1.0, 'ITS4': 1.05, 'IT5A': 1.1500000000000001, 'CT5A': 1.6500000000000006, 'IT5B': 0.6250000000000001, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 1.4500000000000004, 'CT6': 1.2000000000000002}, 'EIGain': {'NGF1': 1.2500000000000002, 'SOM2': 0.5999999999999996, 'PV2': 0.25, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 3.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.1, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.8000000000000003, 'VIP5A': 1.35, 'NGF5A': 0.9500000000000002, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 1.5, 'NGF5B': 1.4500000000000004, 'SOM6': 0.95, 'PV6': 3.0, 'VIP6': 3.0, 'NGF6': 0.25}}
saving iteration output.
--------------------------------------------------------------------------------
  Completed a generation  
--------------------------------------------------------------------------------
[I 2024-03-07 17:38:50,403] Trial 59 finished with value: -0.7829742081909798 and parameters: {'L4L3E': 1.0188377611592279, 'L4L3PV': 0.9829655631376849, 'L4L3SOM': 0.9647203483395813, 'L4L3VIP': 1.039136847713827, 'L4L3NGF': 0.9119964748686543}. Best is trial 59 with value: -0.7829742081909798.

will let it run until tomorrow ... and test it then. since redoing IC -> Thal pathways (see entry above), may not need to run this particular
optimization much more.

** for updating connections of IC and cochlea

cochlea will allow specifying the number of cells / auditory nerve fibers
each will have a specific frequency tuning
those nerves will project to ICC (IC for Core) and ICM (IC for Matrix) populations
ICC will have neurons with narrow frequency tuning - spatially arranged in a line
ICM will have neurons with ~equal broad frequency tuning - spatially arrangement won't matter

ICC will project to MGB core ... MGB TC neurons can have spatial arrangement similar to ICC
to preserve tonotopic organization

ICM will project to MGB matrix with arbitrary connectivity

ICC and ICM will only get activated when there is an auditory stimulus

neurons in ICC, ICM can be VecStim or INTF ; later on may want a closed loop model
where the auditory stimulus can update based on A1 model output

for MGB core to A1, can have a spatially dependent connectivity, which would
implicitly setup a tonotopic gradient, will have to create functions for showing
which part of A1 is activated for a particular frequency input

* 24mar8
** check output from optunaERP_24mar5_ optimization on supragran CSD during BBN

best iteration was 59, so far ran 72 trials; since will adjust IC -> thal inputs, will stop the opt for now 
and examine the results

take synaptic gains from iteration 58

python

import pickle
dgain = pickle.load(open('data/optunaERP_24mar5_/gen_58/dgain.pkl','rb'))

{'EEGain': {'IT2': 1.4125, 'IT3': 3.0, 'ITP4': 1.0, 'ITS4': 1.05, 'IT5A': 1.1500000000000001, 'CT5A': 1.6000000000000005, 'IT5B': 0.6250000000000001, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 1.4000000000000004, 'CT6': 1.2000000000000002}, 
 'EIGain': {'NGF1': 1.2000000000000002, 'SOM2': 0.6499999999999997, 'PV2': 0.25, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 3.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.1, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.7500000000000002, 'VIP5A': 1.35, 'NGF5A': 0.9500000000000002, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 1.5, 'NGF5B': 1.4000000000000004, 'SOM6': 0.95, 'PV6': 3.0, 'VIP6': 3.0, 'NGF6': 0.25}
}

fitness for trial 59 was -0.7829742081909798
saveFolder was: data/optunaERP_24mar5_/gen_59

[I 2024-03-07 17:38:50,403] Trial 59 finished with value: -0.7829742081909798 
 and parameters: {'L4L3E': 1.0188377611592279, 'L4L3PV': 0.9829655631376849, 'L4L3SOM': 0.9647203483395813, 'L4L3VIP': 1.039136847713827, 'L4L3NGF': 0.9119964748686543}. Best is trial 59 with value: -0.7829742081909798.

will run 
24mar8_A0
with those params and see how it looks ... 

first, check the output from that iteration ...

python -i simdat.py 

from netpyne import sim
fn = 'data/optunaERP_24mar5_/gen_59/trial_59_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

simstr = 'optunaERP_24mar5_gen_59_'

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a0.png') # [[./gif/24mar8_optunaERP_24mar5_gen_59__CSD__CSD_overlay_pad1_a0.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.5e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24mar8_optunaERP_24mar5_gen_59__CSD__CSD_overlay_pad1_a1.png]]

so now there's a noticeable sink at bottom of L3 (3 channels == 300 microns up from sink in L4)

there's still that giant sink in L2, which is bigger than the sink in L4 and L3 ; it probably should not be there, since
only rarely shows up in experiments

name = 'trial_59_'
simConfig, dstartidx, dendidx, dnumc, dspkID, dspkT = loadsimdat(name,fullpath=fn)

pravgrates(dspkT,dspkID,dnumc,tlim=(totalDur-1e3,totalDur))

IT2 0.7 Hz
SOM2 24.4 Hz
PV2 25.23 Hz
VIP2 1.88 Hz
NGF2 16.09 Hz
IT3 0.02 Hz
SOM3 0.49 Hz
PV3 30.42 Hz
VIP3 51.36 Hz
NGF3 7.73 Hz
ITP4 2.0 Hz
ITS4 1.8 Hz
SOM4 9.0 Hz
PV4 5.8 Hz
VIP4 29.85 Hz
NGF4 15.14 Hz
IT5A 2.29 Hz
CT5A 4.85 Hz
SOM5A 16.81 Hz
PV5A 2.74 Hz
VIP5A 0.3 Hz
NGF5A 3.25 Hz
IT5B 5.38 Hz
CT5B 2.11 Hz
PT5B 0.49 Hz
SOM5B 44.8 Hz
PV5B 0.35 Hz
VIP5B 0.76 Hz
NGF5B 2.38 Hz
IT6 0.69 Hz
CT6 3.96 Hz
SOM6 78.03 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 114.61 Hz
TC 10.31 Hz
TCM 6.41 Hz
HTC 9.71 Hz
IRE 5.07 Hz
IREM 1.75 Hz
TI 3.24 Hz
TIM 3.67 Hz
IC 5.67 Hz

some of the populations are firing too fast, others not firing at all ... 

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24mar8_optunaERP_24mar5_gen_59__rast.png]]

xlim((3.5e3,4.5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24mar8_optunaERP_24mar5_gen_59__rastB.png]]

what are the dgain values after this iteration?

dgain = pickle.load(open('data/optunaERP_24mar5_/gen_59/dgain.pkl','rb'))

{'EEGain': {'IT2': 1.4125, 'IT3': 3.0, 'ITP4': 1.0, 'ITS4': 1.05, 'IT5A': 1.1500000000000001, 'CT5A': 1.6500000000000006, 'IT5B': 0.6250000000000001, 'CT5B': 3.0, 'PT5B': 3.0, 'IT6': 1.4500000000000004, 'CT6': 1.2000000000000002}, 
 'EIGain': {'NGF1': 1.2500000000000002, 'SOM2': 0.5999999999999996, 'PV2': 0.25, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 3.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.1, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.8000000000000003, 'VIP5A': 1.35, 'NGF5A': 0.9500000000000002, 'SOM5B': 1.0, 'PV5B': 3.0, 'VIP5B': 1.5, 'NGF5B': 1.4500000000000004, 'SOM6': 0.95, 'PV6': 3.0, 'VIP6': 3.0, 'NGF6': 0.25}
}

put those gains into cfg.py and the iteration 59 params and see how it looks, may also need to adjust gains manually if rates too high/low ...

and put these param values into cfg.py :

{'L4L3E': 1.0188377611592279, 
 'L4L3PV': 0.9829655631376849, 
 'L4L3SOM': 0.9647203483395813, 
 'L4L3VIP': 1.039136847713827, 
 'L4L3NGF': 0.9119964748686543}. 

now run it (24mar8_A0) to see how looks ... 

./myrun 48

   NGF1 : 0.982 Hz
   IT2 : 3.124 Hz
   SOM2 : 20.873 Hz
   PV2 : 9.972 Hz
   VIP2 : 0.295 Hz
   NGF2 : 119.636 Hz
   IT3 : 6.575 Hz            <<-- too fast
   SOM3 : 71.083 Hz
   PV3 : 41.716 Hz
   VIP3 : 10.964 Hz
   NGF3 : 81.123 Hz
   ITP4 : 2.649 Hz
   ITS4 : 2.596 Hz
   SOM4 : 18.791 Hz
   PV4 : 34.647 Hz
   VIP4 : 35.622 Hz
   NGF4 : 68.234 Hz
   IT5A : 1.759 Hz
   CT5A : 6.199 Hz           <<-- too fast
   SOM5A : 94.329 Hz
   PV5A : 8.053 Hz
   VIP5A : 0.323 Hz
   NGF5A : 55.114 Hz
   IT5B : 7.048 Hz           <<-- too fast
   CT5B : 13.884 Hz          <<-- way too fast
   PT5B : 2.056 Hz
   SOM5B : 81.937 Hz
   PV5B : 14.284 Hz
   VIP5B : 0.364 Hz
   NGF5B : 60.220 Hz
   IT6 : 26.476 Hz
   CT6 : 9.575 Hz           <<-- too fast
   SOM6 : 4.665 Hz
   PV6 : 5.286 Hz
   VIP6 : 0.248 Hz
   NGF6 : 295.943 Hz
   TC : 24.146 Hz
   TCM : 8.573 Hz
   HTC : 18.452 Hz
   IRE : 8.197 Hz
   IREM : 1.263 Hz
   TI : 4.473 Hz
   TIM : 3.535 Hz
   IC : 2.115 Hz

** start setup of adjusted IC and cochlear inputs (24mar8_B0)
* 24mar11
** adjusting IC/cochlear inputs (24mar11_A0)
* 24mar21
** test cochlea again

python 

import numpy as np
from pylab import *
ion()
import thorns as th
import cochlea
import scipy.signal as dsp

fs = 100e3

# Make sound
t = np.arange(0, 0.1, 1/fs)
s = dsp.chirp(t, 80, t[-1], 20000)
s = cochlea.set_dbspl(s, 50)
pad = np.zeros(int(10e-3 * fs))
sound = np.concatenate( (s, pad) )

# Run model
anf = cochlea.run_zilany2014(
  sound,
  fs,
  anf_num=(100,0,0),
  cf=(125, 20000, 100), # from 125 to 20000 Hz
  seed=0,
  powerlaw='approximate',
  species='human',
)

# Accumulate spike trains
anf_acc = th.accumulate(anf, keep=['cf', 'duration'])
anf_acc.sort_values('cf', ascending=False, inplace=True)

# Plot auditory nerve response
fig, ax = plt.subplots(2,1)
th.plot_signal(
  signal=sound,
  fs=fs,
  ax=ax[0]
)
th.plot_neurogram(
  anf_acc,
  fs,
  ax=ax[1]
)

savefig('gif/24mar21_test_cochlea_a0.png') # [[./gif/24mar21_test_cochlea_a0.png]]

type(anf) # <class 'pandas.core.frame.DataFrame'>
anf.columns # Index(['spikes', 'duration', 'cf', 'type'], dtype='object')
anf.shape # (10000, 4)

plot(anf['cf'])
ylabel('Center Frequency (Hz)'); xlabel('index')
savefig('gif/24mar21_test_cochlea_cf_a1.png') # [[./gif/24mar21_test_cochlea_cf_a1.png]]

anf.head()
                                              spikes  duration     cf type
0  [0.00437999999999999, 0.012939999999999672, 0....      0.11  125.0  hsr
1  [2e-05, 0.022469999999999254, 0.02804999999999...      0.11  125.0  hsr
2  [0.0015600000000000034, 0.0034700000000000065,...      0.11  125.0  hsr
3  [0.011759999999999689, 0.018289999999999456, 0...      0.11  125.0  hsr
4  [0.008119999999999837, 0.022669999999999278, 0...      0.11  125.0  hsr

anf.tail()
                                                 spikes  duration       cf type
9995  [0.005279999999999953, 0.008909999999999836, 0...      0.11  20000.0  hsr
9996  [0.01098999999999972, 0.022909999999999268, 0....      0.11  20000.0  hsr
9997  [0.0010700000000000022, 0.007489999999999861, ...      0.11  20000.0  hsr
9998  [0.004080000000000002, 0.02629999999999913, 0....      0.11  20000.0  hsr
9999  [0.0013500000000000029, 0.008349999999999826, ...      0.11  20000.0  hsr

so there are multiple channels (auditory nerve fibers) with the same cf (center frequency)

a lot of the setup is also done in input.py ... 

python -i input.py

dcinput = cochlearInputSpikes() # can provide a wav sound input file
dcinput.keys() # dict_keys(['spkT', 'cf'])
dcinput['spkT'] # spike times of auditory nerve fibers
dcinput['cf'] # center frequencies for each of the auditory nerve fibers

for idx, spkt in enumerate(dcinput['spkT']):
  plot(spkt, [dcinput['cf'][idx] for i in range(len(spkt))],'ko',markersize=1)

ylabel('ANF CF (Hz)'); xlabel('Time (ms)')
xlim((0,25))

savefig('gif/24mar21_test_cochlea_spike_raster_a2.png') # [[./gif/24mar21_test_cochlea_spike_raster_a2.png]]

** adjusting IC/cochlear inputs (24mar21_A0)

so use ANF code above to create a VecStim, one for each ANF
then provide all the ANFs as input into thalamic matrix
but only a subset around a center frequency into thalamic core

in that case would need to make sure they're scaled appropriately ... 

also ideally would have a tonotopic gradient for inputs into thalamic core TC neurons,
which preserve the topography entering into A1

http://doc.netpyne.org/modeling-specification-v1.0.html

netParams.popParams['artif3'] = {'cellModel': 'VecStim', 'numCells': 100, 'spkTimes': spkTimes, 'pulses': pulses}  # VecStim with spike times

could spkTimes be a list of lists? that would make specification easier ... 

hmm, some of this already available in netParams.py :

    if cfg.cochlearThalInput:
        from input import cochlearInputSpikes
        numCochlearCells = cfg.cochlearThalInput['numCells']
        cochlearSpkTimes = cochlearInputSpikes(numCells = numCochlearCells,
                                               duration = cfg.duration,
                                               freqRange = cfg.cochlearThalInput['freqRange'],
                                               toneFreq=cfg.cochlearThalInput['toneFreq'],
                                               loudnessDBs=cfg.cochlearThalInput['loudnessDBs'])
                                              
        netParams.popParams['cochlea'] = {'cellModel': 'VecStim', 'numCells': numCochlearCells, 'spkTimes': cochlearSpkTimes, 'ynormRange': layer['cochlear']}

and see a connection from that cochlea to thalamus :

    # cochlea -> thal
    if cfg.cochlearThalInput:
        netParams.connParams['cochlea->ThalE'] = { 
            'preConds': {'pop': 'cochlea'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalE'], 
            'weight': cfg.weightInput['ThalE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['cochlea->ThalI'] = { 
            'preConds': {'pop': 'cochlea'}, 
            'postConds': {'cellType': ['RE']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalI'], 
            'weight': cfg.weightInput['ThalI'],
            'synMechWeightFactor': cfg.synWeightFractionEI,
            'delay': cfg.delayBkg}  

* 24mar25
** continue IC/cochlear inputs (24mar25_A0)

could have multiple cochlearThalInput - then set different frequency ranges for the part that goes to core vs to matrix

or ICC, ICM populations ... ICC gets inputs with bias to central frequency, ICM gets equal inputs from all frequencies

or IC neurons as INTFs, each one has a single frequency based on ANF activation. and the projection is what
separates core from matrix ... so IC projects over a narrow range to core, and a wide range to matrix

that would be ~same as just using the VecStim from the cochlear ANF spike trains

would like to be able to setup a tonotopic gradient in A1 ... 

for A1 have:
 cfg.sizeY = 2000.0 #1350.0 in M1_detailed # should this be set to 2000 since that is the full height of the column? 
 cfg.sizeX = 200.0 # 400 - This may change depending on electrode radius 
 cfg.sizeZ = 200.0

ANF VecStims -> Core -> A1
ANF VecStims -> Matrix -> A1

* 24apr3
** pick up IC/cochlear inputs

for core just select a subset of center frequencies, at intermediate weight/probability
for matrix select ALL center frequencies, but at lower weight/probability

for later on, a tonotopic gradient would need some specification of location of cochlear VecStim neurons
so that could distribute them in space

* 24apr5
** continue setup of revised cochlear inputs and their projections

need to allow enough frequency spread within A1 to allow interactions between different frequency inputs
so that can model MMN as well as decoding of different frequency sound stimuli

can make the vecstims have a spatial arrangement on a line that projects into thalamus more diffusely for
projections into matrix and narrow for projections into core 

but also want to preserve the spatial dependence of wiring from thal into A1 so that tonotopic gradient
within A1 is preserved 

may be easier to setup if all sim code in one file - sim.py (cfg.py, netParams.py, init.py)
since need to initialize sim and gather the cell tags, then use that info to create connectivity

* 24apr8
** continue

python -i simdat.py 24apr4_A0

dnumc['cochlea'] # 10000 
dnumc['TC'] # 116
dnumc['HTC'] # 38
dnumc['TCM'] # 155

116 + 38 = 154, so there are slightly fewer thalamic core E neurons projecting to A1
than thalamic matrix E neurons

can 10K -> ~150 neurons project accurately with spatially dependent wiring?

first need to make sure the cochlea neurons have correct positions

simConfig['net']['pops']['cochlea'].keys()
odict_keys(['cellModel', 'numCells', 'spkTimes', 'ynormRange', 'gridSpacing', 'pop', 'params', 'cellGids'])

simConfig['net']['pops']['cochlea']['numCells'] # 10000
simConfig['net']['pops']['cochlea']['gridSpacing'] # 1
simConfig['net']['pops']['cochlea']['pop'] # 'cochlea'
simConfig['net']['pops']['cochlea']['ynormRange'] # [1.6, 1.601]

len(simConfig['net']['cells']) # 22908
dstartidx['cochlea'] # 12908
dendidx['cochlea'] # 22907

simConfig['net']['cells'][dstartidx['cochlea']]
{gid: 12908, tags: {cellModel: 'VecStim', pop: 'cochlea', xnorm: 0.19331219420913365, ynorm: 1.600726982340746, znorm: 0.8080890791021118, x: 38.66243884182673, y: 3201.453964681492, z: 161.61781582042235}, conns: [], stims: [], params: {sizeX: 10001, sizeY: 1, sizeZ: 1, spkTimes: [4.409999999999989, 13.609999999999644, 24.099999999999252, 37.640000000000946, 45.95000000000326, 59.11000000000706, 62.71000000000779, 64.85000000000726, 79.56000000000184, 85.02000000000001, 95.87999999999609, 105.84999999999252, 108.79999999999167, 141.34000000000202, 171.82000000003174, 216.80000000007598, 221.50000000007995, 227.2100000000849, 231.22000000008816, 232.98000000008918, 238.30000000009375, 250.8300000001055, 256.5000000001104, 283.870000000137, 292.3000000001447, 317.6800000001693, 320.24000000017105, 331.2700000001813, 345.07000000019434, 363.9400000002124, 369.73000000021744, 382.40000000022934, 392.36000000023853, 438.0600000002834, 446.95000000029154, 455.9600000002998, 464.8700000003079, 467.4500000003097, 475.02000000031654, 490.4700000003312, 503.65000000032336, 510.91000000029373, 545.1100000001416, 552.9900000001091, 560.790000000077, 582.1399999999834, 608.6199999998663, 625.5399999997927, 640.8499999997265, 650.7699999996847, 663.8999999996284, 665.3699999996252, 694.2499999994972, 715.6699999994032, 739.8199999992967, 747.9699999992631, 767.3099999991784, 779.7099999991254, 799.4399999990392, 823.739999998932, 851.8099999988077, 859.8999999987743, 885.6599999986605, 907.7299999985635, 922.889999998498, 927.809999998479, 957.1899999983488, 961.7899999983313, 991.2799999982005, 993.0999999981957, 1005.4499999982033, 1007.2599999982103], seed: 1}}

simConfig['net']['cells'][dstartidx['cochlea']]['tags']['y'] # 3201.453964681492
simConfig['net']['cells'][dstartidx['cochlea']+1]['tags']['y'] # 3201.8738267710723

simConfig['net']['cells'][dstartidx['cochlea']]['tags']['x'] # 38.66243884182673
simConfig['net']['cells'][dstartidx['cochlea']+1]['tags']['x'] # 161.03206133791554

so the gridSpacing parameter had no impact on placement of the cochlea cells

lypos = [simConfig['net']['cells'][i]['tags']['y'] for i in range(dstartidx['cochlea'],dendidx['cochlea']+1,1)]
min(lypos),max(lypos),mean(lypos) # (3200.0003494098787, 3201.9998954129405, 3201.0001212552024)

lxpos = [simConfig['net']['cells'][i]['tags']['x'] for i in range(dstartidx['cochlea'],dendidx['cochlea']+1,1)]
min(lxpos),max(lxpos),mean(lxpos) # (0.294938358228114, 199.7773234017354, 99.42182711431076)

** N1 ISI

from BBN stim, provide interstimulus interval at varying intervals
ERP amplitude tends to increase, initially rapidly, but then plateaus as the interval
gets longer - up to 5.8-6 s interval

can run with existing model

can use these intervals: 0.5 s, 1.5 s, 3 s, 6 s 

for 6 s interval will need a really long simulation ... 

*** ok, 24apr9_BBN_ISI500_ -->> hyperactive

will run for 5.5 s with 500 ms interval to see how it looks ... this is using the old ICThalInput

python -i simdat.py 24apr9_BBN_ISI500_

NGF1 1.29 Hz
IT2 0.14 Hz
SOM2 0.0 Hz
PV2 191.62 Hz
VIP2 0.0 Hz
NGF2 476.55 Hz
IT3 11.8 Hz
SOM3 0.0 Hz
PV3 0.0 Hz
VIP3 185.39 Hz
NGF3 175.28 Hz
ITP4 0.42 Hz
ITS4 0.38 Hz
SOM4 1.62 Hz
PV4 127.22 Hz
VIP4 0.0 Hz
NGF4 85.36 Hz
IT5A 0.18 Hz
CT5A 4.85 Hz
SOM5A 156.91 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 68.12 Hz
IT5B 4.25 Hz
CT5B 31.35 Hz
PT5B 0.37 Hz
SOM5B 28.35 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 198.75 Hz
IT6 24.27 Hz
CT6 8.12 Hz
SOM6 0.0 Hz
PV6 11.55 Hz
VIP6 0.0 Hz
NGF6 314.21 Hz
TC 28.01 Hz
TCM 4.05 Hz
HTC 20.87 Hz
IRE 10.93 Hz
IREM 0.41 Hz
TI 4.61 Hz
TIM 3.25 Hz
IC 2.83 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24apr9_24apr9_BBN_ISI500__rast.png]]

this looks hyperactive

xlim((3.5e3,4.5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr9_24apr9_BBN_ISI500__rastB.png]]

from netpyne import sim
fn = 'data/24apr9_BBN_ISI500_/24apr9_BBN_ISI500__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a0.png') # [[./gif/24apr9_24apr9_BBN_ISI500__CSD__CSD_overlay_pad1_a0.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.5e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr9_24apr9_BBN_ISI500__CSD__CSD_overlay_pad1_a1.png]]

yeah, this version of model is not good ... seems overly active

sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 
savefig(gifpath()+'_CSD__CSD_overlay_pad1_a2.png') # [[./gif/24apr9_24apr9_BBN_ISI500__CSD__CSD_overlay_pad1_a2.png]]

*** 24apr9_BBN_ISI500B_: restore params from previous opt before the L2/3 sink opt portion began  -->> gran ERP look ok?

    "EEPopGain": {'IT2': 1.3125, 'IT3': 1.55, 'ITP4': 1.0, 'ITS4': 1.0, 'IT5A': 1.05, 'CT5A': 1.1500000000000001, 'IT5B': 0.425, 'CT5B': 1.1500000000000001, 'PT5B': 1.05, 'IT6': 1.05, 'CT6': 1.05},
    "EIPopGain": {'NGF1': 1.0, 'SOM2': 1.0, 'PV2': 1.0, 'VIP2': 1.0, 'NGF2': 1.0, 'SOM3': 1.0, 'PV3': 1.0, 'VIP3': 1.0, 'NGF3': 1.0, 'SOM4': 1.0, 'PV4': 1.0, 'VIP4': 1.0, 'NGF4': 1.0, 'SOM5A': 1.0, 'PV5A': 1.4, 'VIP5A': 1.25, 'NGF5A': 0.8, 'SOM5B': 1.0, 'PV5B': 1.45, 'VIP5B': 1.4, 'NGF5B': 0.9500000000000001, 'SOM6': 1.0, 'PV6': 1.4, 'VIP6': 1.3499999999999999, 'NGF6': 0.65}

    "thalL4PV": 0.21367245896786016,
    "thalL4SOM": 0.24260966747847523,
    "thalL4E": 1.9540886147587417,
    "thalL4VIP": 1.0,
    "thalL4NGF": 1.0,
    "thalL1NGF": 1.0,
    "ENGF1": 1.0,
    "L4L3E": 1.0,
    "L4L3PV": 1.0,
    "L4L3SOM": 1.0,
    "L4L3VIP": 1.0,
    "L4L3NGF": 1.0,

./myrun 48

python -i simdat.py 24apr9_BBN_ISI500B_

NGF1 1.31 Hz
IT2 0.67 Hz
SOM2 3.6 Hz
PV2 25.46 Hz
VIP2 17.25 Hz
NGF2 15.18 Hz
IT3 0.04 Hz
SOM3 0.0 Hz
PV3 25.93 Hz
VIP3 55.07 Hz
NGF3 7.81 Hz
ITP4 1.66 Hz
ITS4 1.54 Hz
SOM4 4.0 Hz
PV4 6.22 Hz
VIP4 36.62 Hz
NGF4 14.57 Hz
IT5A 1.89 Hz
CT5A 5.0 Hz    <<-- fast
SOM5A 13.81 Hz
PV5A 1.89 Hz
VIP5A 12.7 Hz
NGF5A 5.38 Hz
IT5B 6.11 Hz   <<-- fast
CT5B 0.85 Hz
PT5B 0.25 Hz
SOM5B 35.17 Hz
PV5B 0.83 Hz
VIP5B 3.94 Hz
NGF5B 5.29 Hz
IT6 1.61 Hz
CT6 2.7 Hz
SOM6 80.97 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 106.0 Hz
TC 7.35 Hz
TCM 6.34 Hz
HTC 6.39 Hz
IRE 4.13 Hz
IREM 2.61 Hz
TI 2.8 Hz
TIM 3.31 Hz
IC 2.83 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24apr9_24apr9_BBN_ISI500B__rast.png]]

xlim((3.5e3,4.5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr9_24apr9_BBN_ISI500B__rastB.png]]

from netpyne import sim
fn = 'data/24apr9_BBN_ISI500B_/24apr9_BBN_ISI500B__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a0.png') # [[./gif/24apr9_24apr9_BBN_ISI500B__CSD__CSD_overlay_pad1_a0.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[3.5e3,5.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr9_24apr9_BBN_ISI500B__CSD__CSD_overlay_pad1_a1.png]]

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
bbnT = np.arange(2000, 5000, 500)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from erp import getAvgERP

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05, norm=False, vaknin=True)

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)


gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  gdx+=1


xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24apr9_24apr9_BBN_ISI500B__model_BBN_avg_ERP_CSD_a5.png]]

only granular might be OK ... rest of layers do not look correct

np.amin(avgERP[lchan[1],:]) # -23.303040563922266

np.amin(avgERP[lchan[1],:]) / abs(np.sum(avgERP[lchan[1],:])) # -0.0013775013843590686

pickle.dump({'avgERP':avgERP,'ttERP':ttERP},open('data/24apr9_BBN_ISI500B_/24apr9_BBN_ISI500B__model_BBN_avg_ERP_CSD.pkl','wb'))

*** 24apr9_BBN_ISI1000B_ -->> lower amp in gran ERP

now inc ISI to 1000 ms

make sure have 6 ERPs ... so need a longer simulation

ok, use this in the json to specify:
  "ICThalInput": {"onset": 2000, "offset":8000, "interval": 1000, 'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat'}

and a duration of 7500 ... 

./myrun 48 

python -i simdat.py 24apr9_BBN_ISI1000B_

NGF1 0.68 Hz
IT2 1.25 Hz
SOM2 28.0 Hz
PV2 60.62 Hz
VIP2 0.38 Hz
NGF2 21.64 Hz
IT3 0.02 Hz
SOM3 0.03 Hz
PV3 36.23 Hz
VIP3 63.42 Hz
NGF3 8.57 Hz
ITP4 2.78 Hz
ITS4 2.31 Hz
SOM4 28.33 Hz
PV4 1.71 Hz
VIP4 3.23 Hz
NGF4 11.29 Hz
IT5A 3.03 Hz
CT5A 2.95 Hz
SOM5A 23.56 Hz
PV5A 1.08 Hz
VIP5A 2.8 Hz
NGF5A 2.12 Hz
IT5B 6.71 Hz
CT5B 0.95 Hz
PT5B 0.31 Hz
SOM5B 42.18 Hz
PV5B 0.45 Hz
VIP5B 0.0 Hz
NGF5B 3.58 Hz
IT6 2.29 Hz
CT6 3.88 Hz
SOM6 97.51 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 141.08 Hz
TC 7.72 Hz
TCM 6.04 Hz
HTC 7.55 Hz
IRE 4.41 Hz
IREM 2.43 Hz
TI 2.78 Hz
TIM 3.1 Hz
IC 2.83 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24apr9_24apr9_BBN_ISI1000B__rast.png]]

xlim((3.5e3,4.5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr9_24apr9_BBN_ISI1000B__rastB.png]]

from netpyne import sim
fn = 'data/24apr9_BBN_ISI1000B_/24apr9_BBN_ISI1000B__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,7.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a0.png') # [[./gif/24apr9_24apr9_BBN_ISI1000B__CSD__CSD_overlay_pad1_a0.png]]

sim.plotting.plotCSD(overlay='CSD',timeRange=[2.0e3,4.0e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr9_24apr9_BBN_ISI1000B__CSD__CSD_overlay_pad1_a1.png]]

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
bbnT = np.arange(2000, 7000, 1000)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from erp import getAvgERP

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05, norm=False, vaknin=True)

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)


gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  xlim((0,150)); xlabel('Time (ms)');
  gdx+=1

savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24apr9_24apr9_BBN_ISI1000B__model_BBN_avg_ERP_CSD_a5.png]]

np.amin(avgERP[lchan[1],:]) # # -10.166352621799906 <<-- this amplitude is smaller than previous sim, so inconsistent with the exptl data,
where amplitude increases, but not as quickly, as the interval gets larger -- otoh the sim duration differed from previous, so may
not be a fair comparison

np.amin(avgERP[lchan[1],:]) / abs(np.sum(avgERP[lchan[1],:])) # -0.002366342421251142

pickle.dump({'avgERP':avgERP,'ttERP':ttERP},open('data/24apr9_BBN_ISI1000B_/24apr9_BBN_ISI1000B__model_BBN_avg_ERP_CSD.pkl','wb'))

will run one more with 1.5 s ISI ... 

*** 24apr9_BBN_ISI1500B_ -->> 

now inc ISI to 1500 ms

make sure have 6 ERPs ... so need an even longer simulation

duration = 11500

  "ICThalInput": {"onset": 2000, "offset":11000, "interval": 1500, "file": "data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat"}

./myrun 48

python -i simdat.py 24apr9_BBN_ISI1500B_

NGF1 0.7 Hz
IT2 2.21 Hz
SOM2 29.96 Hz
PV2 59.08 Hz
VIP2 1.81 Hz
NGF2 17.92 Hz
IT3 0.07 Hz
SOM3 4.9 Hz
PV3 32.64 Hz
VIP3 51.06 Hz
NGF3 7.99 Hz
ITP4 2.7 Hz
ITS4 2.23 Hz
SOM4 26.45 Hz
PV4 2.38 Hz
VIP4 3.77 Hz
NGF4 11.96 Hz
IT5A 2.64 Hz
CT5A 2.29 Hz
SOM5A 23.45 Hz
PV5A 1.16 Hz
VIP5A 4.25 Hz
NGF5A 2.34 Hz
IT5B 5.05 Hz
CT5B 0.63 Hz
PT5B 0.23 Hz
SOM5B 40.89 Hz
PV5B 0.35 Hz
VIP5B 0.17 Hz
NGF5B 2.54 Hz
IT6 1.8 Hz
CT6 3.67 Hz
SOM6 87.13 Hz
PV6 0.0 Hz
VIP6 0.97 Hz
NGF6 121.61 Hz
TC 6.76 Hz
TCM 5.55 Hz
HTC 6.33 Hz
IRE 4.09 Hz
IREM 2.27 Hz
TI 3.04 Hz
TIM 3.41 Hz
IC 1.51 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr10_24apr9_BBN_ISI1500B__rast.png]]

xlim((1.5e3,2.5e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr10_24apr9_BBN_ISI1500B__rastB.png]]

from netpyne import sim
fn = 'data/24apr9_BBN_ISI1500B_/24apr9_BBN_ISI1500B__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,11.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a0.png') # [[./gif/24apr10_24apr9_BBN_ISI1500B__CSD__CSD_overlay_pad1_a0.png]]
sim.plotting.plotCSD(overlay='CSD',timeRange=[1.5e3,3.5e3],stim_start_time=2e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr10_24apr9_BBN_ISI1500B__CSD__CSD_overlay_pad1_a1.png]]

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
bbnT = np.arange(2000, 11000, 1500)
dt = 0.05
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from erp import getAvgERP

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05, norm=False, vaknin=True)

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  xlim((0,150)); xlabel('Time (ms)');
  gdx+=1

savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24apr10_24apr9_BBN_ISI1500B__model_BBN_avg_ERP_CSD_a5.png]]

np.amin(avgERP[lchan[1],:]) # # -15.86626109674084

np.amin(avgERP[lchan[1],:]) / abs(np.sum(avgERP[lchan[1],:])) # -0.04738344766895032

pickle.dump({'avgERP':avgERP,'ttERP':ttERP},open('data/24apr9_BBN_ISI1500B_/24apr9_BBN_ISI1500B__model_BBN_avg_ERP_CSD.pkl','wb'))

* 24apr10
** compare L4 ERP responses for the different ISIs -->> diff pattern from exp?

500, 1000, 1500

python

from pylab import *
ion()
import numpy as np
import pickle
from collections import OrderedDict

lisi = [500, 1000, 1500]

davgERP = OrderedDict({isi:pickle.load(open('data/24apr9_BBN_ISI'+str(isi)+'B_/24apr9_BBN_ISI'+str(isi)+'B__model_BBN_avg_ERP_CSD.pkl','rb')) for isi in lisi})

davgERP[500].keys() # dict_keys(['avgERP', 'ttERP'])

lchan = [10 + 1]

import matplotlib.patches as mpatches

ax=subplot(1,2,1)
chan = lchan[0]
for isi,clr in zip(lisi,['r','g','b']): 
  plot(davgERP[isi]['ttERP'],davgERP[isi]['avgERP'][chan,:],clr)
  xlim((0,150)); xlabel('Time (ms)');

title('granular CSD')

lpatch = [mpatches.Patch(color=c,label='BBN ISI='+str(s)+' ms') for c,s in zip(['r','g','b'],lisi)]
ax.legend(handles=lpatch,handlelength=1)

ax=subplot(1,2,2)
lpk = [abs(np.amin(davgERP[isi]['avgERP'][chan,:])-davgERP[isi]['avgERP'][chan,0]) for isi in lisi]
plot(lisi,lpk,'k',linewidth=4)
plot(lisi,lpk,'ko',markersize=12)
xlabel('BBN ISI (ms)'); title('Average granular ERP amplitude')

savefig('gif/24apr10_compare_gran_CSD_ERP_amp_BBN_ISI_a0.png') # [[./gif/24apr10_compare_gran_CSD_ERP_amp_BBN_ISI_a0.png]]

ok, so far not seeing the same pattern as in the data ...

** continue coch setup (24apr10_A0_)

during testing/setup try with scaleDensity==0.25

python -i simdat.py 24apr10_A0_

lypos = [simConfig['net']['cells'][i]['tags']['y'] for i in range(dstartidx['cochlea'],dendidx['cochlea']+1,1)]
min(lypos),max(lypos),mean(lypos) # (3200.0003494098787, 3201.9998954129405, 3201.0001212552024)

lxpos = [simConfig['net']['cells'][i]['tags']['x'] for i in range(dstartidx['cochlea'],dendidx['cochlea']+1,1)]
min(lxpos),max(lxpos),mean(lxpos) # (0.0, 199.98, 99.99)

lzpos = [simConfig['net']['cells'][i]['tags']['z'] for i in range(dstartidx['cochlea'],dendidx['cochlea']+1,1)]
min(lzpos),max(lzpos),mean(lzpos) # (0.16066002963468495, 199.4169311273124, 100.29288953917242)

plot(lxpos,'ko')

lxpos = [simConfig['net']['cells'][i]['tags']['x'] for i in range(dstartidx['TC'],dendidx['TC']+1,1)]
min(lxpos),max(lxpos),mean(lxpos) # (12.45968743548106, 195.3140953708004, 90.15232967191682)

could make each cochlear cell project to N specific TC, HTC cells based on their positions
while preserving overall number of connections to maintain pmat

* 24apr11
** check last test output run with adjusted cochlea -> Thal connectivity -->> can see cochlear -> thalamic core activation

python -i simdat.py 24apr10_B0_

NGF1 0.06 Hz
IT2 9.31 Hz
SOM2 147.8 Hz
PV2 10.23 Hz
VIP2 0.0 Hz
NGF2 4.36 Hz
IT3 0.2 Hz
SOM3 35.5 Hz
PV3 21.19 Hz
VIP3 1.79 Hz
NGF3 4.89 Hz
ITP4 2.94 Hz
ITS4 2.26 Hz
SOM4 39.17 Hz
PV4 1.38 Hz
VIP4 0.69 Hz
NGF4 9.71 Hz
IT5A 0.63 Hz
CT5A 0.01 Hz
SOM5A 34.79 Hz
PV5A 0.01 Hz
VIP5A 0.1 Hz
NGF5A 0.0 Hz
IT5B 2.69 Hz
CT5B 0.01 Hz
PT5B 0.08 Hz
SOM5B 51.31 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 0.52 Hz
CT6 3.73 Hz
SOM6 66.21 Hz
PV6 0.0 Hz
VIP6 1.42 Hz
NGF6 74.79 Hz
TC 6.0 Hz
TCM 4.99 Hz
HTC 5.82 Hz
IRE 3.41 Hz
IREM 1.73 Hz
TI 3.16 Hz
TIM 3.76 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr11_24apr10_B0__rast.png]]

xlim((0,2e3))
savefig(gifpath()+'_rastB.png') # [[,/gif/24apr11_24apr10_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]


for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr11_24apr10_B0__spikehistA.png]]

ok, good, so cochlear activation leads to strong activation of TC,HTC, and only minor activation of TCM

** 24apr11_A0_ : continue coch setup, and revising thal, ctxthal, thalctx wiring rules

next, need to make the thalamic core population project to A1 in topographic manner
can use inverse x_dist wiring, since cochlea arranged on x-axis, and projects into
thalamic core using same wiring rule

added some functions to encapsulate wiring rules

made the intrathalamic connectivity for core use inverse x_dist wiring probability
for matrix, use the old probabalistic connections

for cortex to thalamus also use the inverse x_dist rule for core, and probabablistic otherwise (matrix)

for thalamus to cortex old rule used inverse dist_2d for probability. not sure what that was based on.
that was the case despite that cortex to thalamus used only probabalistic connectivity (shouldn't they
be symmetric if based on anatomy?) ; should check what the lambda (length constant for probability)
and whether comparable to the initial 5 microns used for the thalamic core value

python -i simdat.py 24apr11_A0_

NGF1 1.35 Hz
IT2 0.22 Hz
SOM2 30.0 Hz
PV2 16.54 Hz
VIP2 13.75 Hz
NGF2 8.0 Hz
IT3 0.19 Hz
SOM3 0.04 Hz
PV3 1.29 Hz
VIP3 11.63 Hz
NGF3 5.17 Hz
ITP4 0.68 Hz
ITS4 0.64 Hz
SOM4 1.46 Hz
PV4 0.01 Hz
VIP4 5.77 Hz
NGF4 6.79 Hz
IT5A 0.65 Hz
CT5A 0.0 Hz
SOM5A 5.58 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 2.38 Hz
IT5B 0.04 Hz
CT5B 0.0 Hz
PT5B 0.02 Hz
SOM5B 11.54 Hz
PV5B 0.0 Hz
VIP5B 0.06 Hz
NGF5B 1.17 Hz
IT6 0.0 Hz
CT6 0.26 Hz
SOM6 0.14 Hz
PV6 78.31 Hz
VIP6 104.17 Hz
NGF6 5.45 Hz
TC 25.7 Hz
TCM 1.77 Hz
HTC 24.82 Hz
IRE 0.39 Hz
IREM 2.48 Hz
TI 6.8 Hz
TIM 3.55 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr11_24apr11_A0__rast.png]]

xlim((0,2e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr11_24apr11_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]


for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr11_24apr11_A0__spikehistA.png]]

now TC,HTC have more sustained firing, even when the cochlear inputs have been turned off (after ~1 s)

is that because of the adjusted connectivity for thalamic core?

* 24apr12
** check conn/conn.pkl and conn/conn.py -- has length constants for thal

SD mentioned some of those lmat params set there and used to control spatial dependence
of wiring and differences for core vs matrix

cd ~/A1/conn
cp conn.pkl conn_backup.pkl
python -i conn.py

Updating conn probability of pop VIP2 using as reference BBP conn probability ratio of VIP2:PV2 ...
 Prob IT2->VIP2: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.07
 Prob IT3->VIP2: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.07
 Prob VIP2->ITP4: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.07 fix_Allen: 0.03
 Prob VIP2->ITS4: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.07 fix_Allen: 0.10
 Prob VIP2->IT5A: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.09 fix_Allen: 0.09
 Prob VIP2->CT5A: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP2->IT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.09 fix_Allen: 0.09
 Prob VIP2->PT5B: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP2->CT5B: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP2->IT6: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP2->CT6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP2->PV2: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.04
 Prob VIP2->PV3: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.04
 Prob VIP2->PV4: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.09
 Prob VIP2->SOM4: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.06 fix_Allen: 0.06
 Prob VIP2->PV5A: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.16
 Prob VIP2->SOM5A: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP2->PV5B: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.16
 Prob VIP2->SOM5B: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00

Updating conn probability of pop VIP3 using as reference BBP conn probability ratio of VIP3:PV3 ...
 Prob IT2->VIP3: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.07
 Prob IT3->VIP3: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.07
 Prob VIP3->ITP4: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.07 fix_Allen: 0.03
 Prob VIP3->ITS4: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.07 fix_Allen: 0.10
 Prob VIP3->IT5A: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.09 fix_Allen: 0.09
 Prob VIP3->CT5A: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP3->IT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.09 fix_Allen: 0.09
 Prob VIP3->PT5B: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP3->CT5B: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.09 fix_Allen: 0.04
 Prob VIP3->IT6: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP3->CT6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP3->PV2: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.04
 Prob VIP3->PV3: ref_BBP: 0.08 fix_BBP: 0.01 ref_Allen: 0.54 fix_Allen: 0.04
 Prob VIP3->PV4: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.09
 Prob VIP3->SOM4: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.06 fix_Allen: 0.06
 Prob VIP3->PV5A: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.16
 Prob VIP3->SOM5A: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP3->PV5B: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.09 fix_Allen: 0.16
 Prob VIP3->SOM5B: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00

Updating conn probability of pop VIP4 using as reference BBP conn probability ratio of VIP4:PV4 ...
 Prob ITP4->VIP4: ref_BBP: 0.07 fix_BBP: 0.01 ref_Allen: 0.59 fix_Allen: 0.08
 Prob ITS4->VIP4: ref_BBP: 0.07 fix_BBP: 0.01 ref_Allen: 0.59 fix_Allen: 0.08
 Prob VIP4->IT2: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.34 fix_Allen: 0.51
 Prob VIP4->IT3: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.34 fix_Allen: 0.51
 Prob VIP4->ITP4: ref_BBP: 0.10 fix_BBP: 0.08 ref_Allen: 0.59 fix_Allen: 0.49
 Prob VIP4->ITS4: ref_BBP: 0.13 fix_BBP: 0.09 ref_Allen: 0.59 fix_Allen: 0.39
 Prob VIP4->IT5A: ref_BBP: 0.09 fix_BBP: 0.03 ref_Allen: 0.12 fix_Allen: 0.04
 Prob VIP4->CT5A: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.12 fix_Allen: 0.04
 Prob VIP4->IT5B: ref_BBP: 0.09 fix_BBP: 0.03 ref_Allen: 0.12 fix_Allen: 0.04
 Prob VIP4->PT5B: ref_BBP: 0.09 fix_BBP: 0.06 ref_Allen: 0.12 fix_Allen: 0.08
 Prob VIP4->CT5B: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.12 fix_Allen: 0.04
 Prob VIP4->IT6: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP4->CT6: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP4->PV2: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.09
 Prob VIP4->SOM2: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.10
 Prob VIP4->PV3: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.09
 Prob VIP4->SOM3: ref_BBP: 0.02 fix_BBP: 0.03 ref_Allen: 0.06 fix_Allen: 0.10
 Prob VIP4->PV4: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.54 fix_Allen: 0.20
 Prob VIP4->SOM4: ref_BBP: 0.12 fix_BBP: 0.06 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP4->PV5A: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.11 fix_Allen: 0.12
 Prob VIP4->PV5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.11 fix_Allen: 0.12
 Prob VIP4->PV6: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00

Updating conn probability of pop VIP5A using as reference BBP conn probability ratio of VIP5A:PV5A ...
 Prob IT2->VIP5A: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.11 fix_Allen: 0.03
 Prob IT3->VIP5A: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.11 fix_Allen: 0.03
 Prob ITP4->VIP5A: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.05
 Prob ITS4->VIP5A: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.05
 Prob IT5A->VIP5A: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob CT5A->VIP5A: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob IT5B->VIP5A: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob PT5B->VIP5A: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob CT5B->VIP5A: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob VIP5A->IT2: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->IT3: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->ITP4: ref_BBP: 0.04 fix_BBP: 0.02 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->ITS4: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->IT5A: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.61 fix_Allen: 0.51
 Prob VIP5A->CT5A: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.61 fix_Allen: 0.19
 Prob VIP5A->IT5B: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.61 fix_Allen: 0.51
 Prob VIP5A->PT5B: ref_BBP: 0.12 fix_BBP: 0.09 ref_Allen: 0.61 fix_Allen: 0.45
 Prob VIP5A->CT5B: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.61 fix_Allen: 0.19
 Prob VIP5A->IT6: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP5A->CT6: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.01
 Prob VIP5A->PV2: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.12 fix_Allen: 0.07
 Prob VIP5A->SOM2: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->PV3: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.12 fix_Allen: 0.07
 Prob VIP5A->SOM3: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5A->PV4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP5A->SOM4: ref_BBP: 0.04 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.00
 Prob VIP5A->PV5A: ref_BBP: 0.07 fix_BBP: 0.05 ref_Allen: 0.44 fix_Allen: 0.30
 Prob VIP5A->SOM5A: ref_BBP: 0.09 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.03
 Prob VIP5A->PV5B: ref_BBP: 0.07 fix_BBP: 0.05 ref_Allen: 0.44 fix_Allen: 0.30
 Prob VIP5A->SOM5B: ref_BBP: 0.09 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.03

Updating conn probability of pop VIP5B using as reference BBP conn probability ratio of VIP5B:PV5A ...
 Prob IT2->VIP5B: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.11 fix_Allen: 0.03
 Prob IT3->VIP5B: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.11 fix_Allen: 0.03
 Prob ITP4->VIP5B: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.05
 Prob ITS4->VIP5B: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.05
 Prob IT5A->VIP5B: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob CT5A->VIP5B: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob IT5B->VIP5B: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob PT5B->VIP5B: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob CT5B->VIP5B: ref_BBP: 0.10 fix_BBP: 0.04 ref_Allen: 0.11 fix_Allen: 0.05
 Prob VIP5B->IT2: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->IT3: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->ITP4: ref_BBP: 0.04 fix_BBP: 0.02 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->ITS4: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->IT5A: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.61 fix_Allen: 0.51
 Prob VIP5B->CT5A: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.61 fix_Allen: 0.19
 Prob VIP5B->IT5B: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.61 fix_Allen: 0.51
 Prob VIP5B->PT5B: ref_BBP: 0.12 fix_BBP: 0.09 ref_Allen: 0.61 fix_Allen: 0.45
 Prob VIP5B->CT5B: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.61 fix_Allen: 0.19
 Prob VIP5B->IT6: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP5B->CT6: ref_BBP: 0.04 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.01
 Prob VIP5B->PV2: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.12 fix_Allen: 0.07
 Prob VIP5B->SOM2: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->PV3: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.12 fix_Allen: 0.07
 Prob VIP5B->SOM3: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP5B->PV4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP5B->SOM4: ref_BBP: 0.04 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.00
 Prob VIP5B->PV5A: ref_BBP: 0.07 fix_BBP: 0.05 ref_Allen: 0.44 fix_Allen: 0.30
 Prob VIP5B->SOM5A: ref_BBP: 0.09 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.03
 Prob VIP5B->PV5B: ref_BBP: 0.07 fix_BBP: 0.05 ref_Allen: 0.44 fix_Allen: 0.30
 Prob VIP5B->SOM5B: ref_BBP: 0.09 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.03

Updating conn probability of pop VIP6 using as reference BBP conn probability ratio of VIP6:PV6 ...
 Prob ITP4->VIP6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob ITS4->VIP6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob IT5A->VIP6: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.01
 Prob CT5A->VIP6: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.01
 Prob IT5B->VIP6: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.01
 Prob PT5B->VIP6: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.01
 Prob CT5B->VIP6: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.04 fix_Allen: 0.01
 Prob VIP6->ITP4: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.13 fix_Allen: 0.23
 Prob VIP6->ITS4: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.13 fix_Allen: 0.26
 Prob VIP6->IT5A: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.13 fix_Allen: 0.22
 Prob VIP6->CT5A: ref_BBP: 0.12 fix_BBP: 0.11 ref_Allen: 0.13 fix_Allen: 0.12
 Prob VIP6->IT5B: ref_BBP: 0.03 fix_BBP: 0.04 ref_Allen: 0.13 fix_Allen: 0.22
 Prob VIP6->PT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.13 fix_Allen: 0.16
 Prob VIP6->CT5B: ref_BBP: 0.12 fix_BBP: 0.11 ref_Allen: 0.13 fix_Allen: 0.12
 Prob VIP6->IT6: ref_BBP: 0.12 fix_BBP: 0.12 ref_Allen: 0.13 fix_Allen: 0.14
 Prob VIP6->CT6: ref_BBP: 0.12 fix_BBP: 0.11 ref_Allen: 0.13 fix_Allen: 0.12
 Prob VIP6->PV4: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP6->SOM4: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob VIP6->PV5A: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP6->SOM5A: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.03
 Prob VIP6->PV5B: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.02
 Prob VIP6->SOM5B: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.03
 Prob VIP6->PV6: ref_BBP: 0.09 fix_BBP: 0.07 ref_Allen: 0.10 fix_Allen: 0.08
 Prob VIP6->SOM6: ref_BBP: 0.10 fix_BBP: 0.10 ref_Allen: 0.12 fix_Allen: 0.12

Updating conn probability of pop ITS4 using as reference BBP conn probability ratio of ITS4:ITP4 ...
 Prob IT2->ITS4: ref_BBP: 0.10 fix_BBP: 0.08 ref_Allen: 0.02 fix_Allen: 0.02
 Prob IT3->ITS4: ref_BBP: 0.10 fix_BBP: 0.08 ref_Allen: 0.02 fix_Allen: 0.02
 Prob ITP4->ITS4: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.30 fix_Allen: 0.26
 Prob ITS4->ITS4: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.30 fix_Allen: 0.26
 Prob IT5A->ITS4: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT5A->ITS4: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.01
 Prob IT5B->ITS4: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.01
 Prob PT5B->ITS4: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT5B->ITS4: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.01
 Prob IT6->ITS4: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob CT6->ITS4: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob ITS4->IT2: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.17 fix_Allen: 0.29
 Prob ITS4->IT3: ref_BBP: 0.01 fix_BBP: 0.02 ref_Allen: 0.17 fix_Allen: 0.29
 Prob ITS4->ITP4: ref_BBP: 0.12 fix_BBP: 0.10 ref_Allen: 0.30 fix_Allen: 0.24
 Prob ITS4->ITS4: ref_BBP: 0.10 fix_BBP: 0.08 ref_Allen: 0.30 fix_Allen: 0.23
 Prob ITS4->IT5A: ref_BBP: 0.17 fix_BBP: 0.12 ref_Allen: 0.13 fix_Allen: 0.09
 Prob ITS4->CT5A: ref_BBP: 0.07 fix_BBP: 0.04 ref_Allen: 0.13 fix_Allen: 0.07
 Prob ITS4->IT5B: ref_BBP: 0.17 fix_BBP: 0.12 ref_Allen: 0.13 fix_Allen: 0.09
 Prob ITS4->PT5B: ref_BBP: 0.17 fix_BBP: 0.13 ref_Allen: 0.13 fix_Allen: 0.10
 Prob ITS4->CT5B: ref_BBP: 0.07 fix_BBP: 0.04 ref_Allen: 0.13 fix_Allen: 0.07
 Prob ITS4->IT6: ref_BBP: 0.05 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.02
 Prob ITS4->CT6: ref_BBP: 0.07 fix_BBP: 0.04 ref_Allen: 0.04 fix_Allen: 0.02
 Prob ITS4->PV2: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.14 fix_Allen: 0.37
 Prob ITS4->SOM2: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.13 fix_Allen: 0.46
 Prob ITS4->PV3: ref_BBP: 0.01 fix_BBP: 0.01 ref_Allen: 0.14 fix_Allen: 0.37
 Prob ITS4->SOM3: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.13 fix_Allen: 0.46
 Prob ITS4->PV4: ref_BBP: 0.07 fix_BBP: 0.04 ref_Allen: 0.59 fix_Allen: 0.36
 Prob ITS4->SOM4: ref_BBP: 0.07 fix_BBP: 0.05 ref_Allen: 0.74 fix_Allen: 0.60
 Prob ITS4->PV5A: ref_BBP: 0.05 fix_BBP: 0.03 ref_Allen: 0.14 fix_Allen: 0.08
 Prob ITS4->SOM5A: ref_BBP: 0.05 fix_BBP: 0.03 ref_Allen: 0.16 fix_Allen: 0.09
 Prob ITS4->VIP5A: ref_BBP: 0.02 fix_BBP: 0.01 ref_Allen: 0.14 fix_Allen: 0.06
 Prob ITS4->PV5B: ref_BBP: 0.05 fix_BBP: 0.03 ref_Allen: 0.14 fix_Allen: 0.08
 Prob ITS4->SOM5B: ref_BBP: 0.05 fix_BBP: 0.03 ref_Allen: 0.16 fix_Allen: 0.09
 Prob ITS4->VIP5B: ref_BBP: 0.02 fix_BBP: 0.01 ref_Allen: 0.14 fix_Allen: 0.06
 Prob ITS4->PV6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob ITS4->SOM6: ref_BBP: 0.01 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00

Updating conn probability of pop CT5A using as reference BBP conn probability ratio of CT5A:IT5A ...
 Prob IT2->CT5A: ref_BBP: 0.10 fix_BBP: 0.03 ref_Allen: 0.10 fix_Allen: 0.03
 Prob IT3->CT5A: ref_BBP: 0.10 fix_BBP: 0.03 ref_Allen: 0.10 fix_Allen: 0.03
 Prob ITP4->CT5A: ref_BBP: 0.17 fix_BBP: 0.07 ref_Allen: 0.13 fix_Allen: 0.05
 Prob ITS4->CT5A: ref_BBP: 0.17 fix_BBP: 0.07 ref_Allen: 0.13 fix_Allen: 0.05
 Prob IT5A->CT5A: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob CT5A->CT5A: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob IT5B->CT5A: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob PT5B->CT5A: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob CT5B->CT5A: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob IT6->CT5A: ref_BBP: 0.03 fix_BBP: 0.11 ref_Allen: 0.01 fix_Allen: 0.06
 Prob CT6->CT5A: ref_BBP: 0.03 fix_BBP: 0.11 ref_Allen: 0.01 fix_Allen: 0.06
 Prob CT5A->ITP4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.01 fix_Allen: 0.00
 Prob CT5A->ITS4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.01 fix_Allen: 0.00
 Prob CT5A->IT5A: ref_BBP: 0.16 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5A->CT5A: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.14 fix_Allen: 0.16
 Prob CT5A->IT5B: ref_BBP: 0.16 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5A->PT5B: ref_BBP: 0.21 fix_BBP: 0.03 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5A->CT5B: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.14 fix_Allen: 0.16
 Prob CT5A->IT6: ref_BBP: 0.07 fix_BBP: 0.09 ref_Allen: 0.06 fix_Allen: 0.07
 Prob CT5A->CT6: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.06 fix_Allen: 0.06
 Prob CT5A->PV4: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.07 fix_Allen: 0.02
 Prob CT5A->SOM4: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.06 fix_Allen: 0.01

Updating conn probability of pop CT5B using as reference BBP conn probability ratio of CT5B:IT5B ...
 Prob IT2->CT5B: ref_BBP: 0.10 fix_BBP: 0.03 ref_Allen: 0.10 fix_Allen: 0.03
 Prob IT3->CT5B: ref_BBP: 0.10 fix_BBP: 0.03 ref_Allen: 0.10 fix_Allen: 0.03
 Prob ITP4->CT5B: ref_BBP: 0.17 fix_BBP: 0.07 ref_Allen: 0.13 fix_Allen: 0.05
 Prob ITS4->CT5B: ref_BBP: 0.17 fix_BBP: 0.07 ref_Allen: 0.13 fix_Allen: 0.05
 Prob IT5A->CT5B: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob CT5A->CT5B: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob IT5B->CT5B: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob PT5B->CT5B: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob CT5B->CT5B: ref_BBP: 0.16 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.07
 Prob IT6->CT5B: ref_BBP: 0.03 fix_BBP: 0.11 ref_Allen: 0.01 fix_Allen: 0.06
 Prob CT6->CT5B: ref_BBP: 0.03 fix_BBP: 0.11 ref_Allen: 0.01 fix_Allen: 0.06
 Prob CT5B->ITP4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.01 fix_Allen: 0.00
 Prob CT5B->ITS4: ref_BBP: 0.03 fix_BBP: 0.01 ref_Allen: 0.01 fix_Allen: 0.00
 Prob CT5B->IT5A: ref_BBP: 0.16 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5B->CT5A: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.14 fix_Allen: 0.16
 Prob CT5B->IT5B: ref_BBP: 0.16 fix_BBP: 0.02 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5B->PT5B: ref_BBP: 0.21 fix_BBP: 0.03 ref_Allen: 0.14 fix_Allen: 0.02
 Prob CT5B->CT5B: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.14 fix_Allen: 0.16
 Prob CT5B->IT6: ref_BBP: 0.07 fix_BBP: 0.09 ref_Allen: 0.06 fix_Allen: 0.07
 Prob CT5B->CT6: ref_BBP: 0.08 fix_BBP: 0.09 ref_Allen: 0.06 fix_Allen: 0.06
 Prob CT5B->PV4: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.07 fix_Allen: 0.02
 Prob CT5B->SOM4: ref_BBP: 0.02 fix_BBP: 0.00 ref_Allen: 0.06 fix_Allen: 0.01

Updating conn probability of pop PT5B using as reference BBP conn probability ratio of PT5B:IT5B ...
 Prob IT2->PT5B: ref_BBP: 0.10 fix_BBP: 0.13 ref_Allen: 0.10 fix_Allen: 0.13
 Prob IT3->PT5B: ref_BBP: 0.10 fix_BBP: 0.13 ref_Allen: 0.10 fix_Allen: 0.13
 Prob ITP4->PT5B: ref_BBP: 0.17 fix_BBP: 0.17 ref_Allen: 0.13 fix_Allen: 0.13
 Prob ITS4->PT5B: ref_BBP: 0.17 fix_BBP: 0.17 ref_Allen: 0.13 fix_Allen: 0.13
 Prob IT5A->PT5B: ref_BBP: 0.16 fix_BBP: 0.21 ref_Allen: 0.14 fix_Allen: 0.19
 Prob CT5A->PT5B: ref_BBP: 0.16 fix_BBP: 0.21 ref_Allen: 0.14 fix_Allen: 0.19
 Prob IT5B->PT5B: ref_BBP: 0.16 fix_BBP: 0.21 ref_Allen: 0.14 fix_Allen: 0.19
 Prob PT5B->PT5B: ref_BBP: 0.16 fix_BBP: 0.21 ref_Allen: 0.14 fix_Allen: 0.19
 Prob CT5B->PT5B: ref_BBP: 0.16 fix_BBP: 0.21 ref_Allen: 0.14 fix_Allen: 0.19
 Prob IT6->PT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.02
 Prob CT6->PT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.02
 Prob PT5B->IT2: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.03 fix_Allen: 0.02
 Prob PT5B->IT3: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.03 fix_Allen: 0.02
 Prob PT5B->ITP4: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.01 fix_Allen: 0.01
 Prob PT5B->ITS4: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.01 fix_Allen: 0.01
 Prob PT5B->IT5A: ref_BBP: 0.16 fix_BBP: 0.12 ref_Allen: 0.14 fix_Allen: 0.11
 Prob PT5B->CT5A: ref_BBP: 0.08 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.14
 Prob PT5B->IT5B: ref_BBP: 0.16 fix_BBP: 0.12 ref_Allen: 0.14 fix_Allen: 0.11
 Prob PT5B->PT5B: ref_BBP: 0.21 fix_BBP: 0.14 ref_Allen: 0.14 fix_Allen: 0.10
 Prob PT5B->CT5B: ref_BBP: 0.08 fix_BBP: 0.08 ref_Allen: 0.14 fix_Allen: 0.14
 Prob PT5B->IT6: ref_BBP: 0.07 fix_BBP: 0.07 ref_Allen: 0.06 fix_Allen: 0.06
 Prob PT5B->CT6: ref_BBP: 0.08 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.06
 Prob PT5B->PV2: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.07 fix_Allen: 0.03
 Prob PT5B->SOM2: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.06 fix_Allen: 0.02
 Prob PT5B->PV3: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.07 fix_Allen: 0.03
 Prob PT5B->SOM3: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.06 fix_Allen: 0.02
 Prob PT5B->PV4: ref_BBP: 0.02 fix_BBP: 0.01 ref_Allen: 0.07 fix_Allen: 0.05
 Prob PT5B->SOM4: ref_BBP: 0.02 fix_BBP: 0.01 ref_Allen: 0.06 fix_Allen: 0.05
 Prob PT5B->PV5A: ref_BBP: 0.10 fix_BBP: 0.07 ref_Allen: 0.11 fix_Allen: 0.08
 Prob PT5B->SOM5A: ref_BBP: 0.12 fix_BBP: 0.08 ref_Allen: 0.08 fix_Allen: 0.05
 Prob PT5B->VIP5A: ref_BBP: 0.04 fix_BBP: 0.03 ref_Allen: 0.11 fix_Allen: 0.10
 Prob PT5B->PV5B: ref_BBP: 0.10 fix_BBP: 0.07 ref_Allen: 0.11 fix_Allen: 0.08
 Prob PT5B->SOM5B: ref_BBP: 0.12 fix_BBP: 0.08 ref_Allen: 0.08 fix_Allen: 0.05
 Prob PT5B->VIP5B: ref_BBP: 0.04 fix_BBP: 0.03 ref_Allen: 0.11 fix_Allen: 0.10
 Prob PT5B->PV6: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.04
 Prob PT5B->SOM6: ref_BBP: 0.02 fix_BBP: 0.02 ref_Allen: 0.04 fix_Allen: 0.04
 Prob PT5B->VIP6: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.04 fix_Allen: 0.06

Updating conn probability of pop CT6 using as reference BBP conn probability ratio of CT6:IT6 ...
 Prob IT2->CT6: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.00 fix_Allen: 0.00
 Prob IT3->CT6: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.00 fix_Allen: 0.00
 Prob ITP4->CT6: ref_BBP: 0.05 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.06
 Prob ITS4->CT6: ref_BBP: 0.05 fix_BBP: 0.07 ref_Allen: 0.04 fix_Allen: 0.06
 Prob IT5A->CT6: ref_BBP: 0.07 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.07
 Prob CT5A->CT6: ref_BBP: 0.07 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.07
 Prob IT5B->CT6: ref_BBP: 0.07 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.07
 Prob PT5B->CT6: ref_BBP: 0.07 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.07
 Prob CT5B->CT6: ref_BBP: 0.07 fix_BBP: 0.08 ref_Allen: 0.06 fix_Allen: 0.07
 Prob IT6->CT6: ref_BBP: 0.11 fix_BBP: 0.11 ref_Allen: 0.03 fix_Allen: 0.03
 Prob CT6->CT6: ref_BBP: 0.11 fix_BBP: 0.11 ref_Allen: 0.03 fix_Allen: 0.03
 Prob CT6->ITP4: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob CT6->ITS4: ref_BBP: 0.00 fix_BBP: 0.01 ref_Allen: 0.00 fix_Allen: 0.00
 Prob CT6->IT5A: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT6->CT5A: ref_BBP: 0.11 fix_BBP: 0.09 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT6->IT5B: ref_BBP: 0.03 fix_BBP: 0.02 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT6->PT5B: ref_BBP: 0.03 fix_BBP: 0.03 ref_Allen: 0.01 fix_Allen: 0.02
 Prob CT6->CT5B: ref_BBP: 0.11 fix_BBP: 0.09 ref_Allen: 0.01 fix_Allen: 0.01
 Prob CT6->IT6: ref_BBP: 0.11 fix_BBP: 0.09 ref_Allen: 0.03 fix_Allen: 0.02
 Prob CT6->CT6: ref_BBP: 0.11 fix_BBP: 0.09 ref_Allen: 0.03 fix_Allen: 0.03
 Prob CT6->PV4: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00
 Prob CT6->SOM4: ref_BBP: 0.00 fix_BBP: 0.00 ref_Allen: 0.00 fix_Allen: 0.00

  -rw-rw-r--  1 samn samn 55689 Apr 12 06:03 conn.pkl
C -rw-rw-r--  1 samn samn 49465 Aug  8  2023 conn_backup.pkl

hmm, now has a different size from original

** jitterNoise.py - missing generate_noise function -->> got fix from CM

python -i jitterNoise.py

generates an output sound wave that has periodic bursts:
 output_sound.wav

figure of sound wave:
 [[./gif/24apr12_test_jitter_a1.png]]
and its FFT
 [[./gif/24apr12_test_jitter_a0.png]]

** 24apr12_A0_

try a sound wav file as input ... ?

first default chirp ... 

./myrun 48

python -i simdat.py 24apr12_A0_

NGF1 1.15 Hz
IT2 0.2 Hz
SOM2 47.6 Hz
PV2 29.31 Hz
VIP2 11.81 Hz
NGF2 7.45 Hz
IT3 0.11 Hz
SOM3 1.59 Hz
PV3 3.77 Hz
VIP3 7.19 Hz
NGF3 4.77 Hz
ITP4 0.53 Hz
ITS4 0.46 Hz
SOM4 2.0 Hz
PV4 0.16 Hz
VIP4 4.54 Hz
NGF4 6.0 Hz
IT5A 0.75 Hz
CT5A 0.01 Hz
SOM5A 6.95 Hz
PV5A 0.0 Hz
VIP5A 0.6 Hz
NGF5A 2.38 Hz
IT5B 0.01 Hz
CT5B 0.0 Hz
PT5B 0.05 Hz
SOM5B 12.07 Hz
PV5B 0.0 Hz
VIP5B 0.53 Hz
NGF5B 1.12 Hz
IT6 0.0 Hz
CT6 0.17 Hz
SOM6 0.86 Hz
PV6 84.13 Hz
VIP6 101.33 Hz
NGF6 5.18 Hz
TC 25.67 Hz
TCM 1.78 Hz
HTC 24.29 Hz
IRE 0.57 Hz
IREM 2.5 Hz
TI 6.41 Hz
TIM 3.45 Hz
cochlea 0.0 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24apr12_24apr12_A0__rast.png]]

ylim((0,12908))
xlim((0,2e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr12_24apr12_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]


for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr12_24apr12_A0__spikehistA.png]]

TC,HTC still firing very fast even outside stimulus. it's OK to have some baseline
activity w/o stim but then should probably be ~equal with TCM activity

how does it look without any cochlear input?

*** 24apr12_A1_ : w/o cochlear input

./myrun 48

python -i simdat.py 24apr12_A1_

NGF1 1.15 Hz
IT2 0.2 Hz
SOM2 47.6 Hz
PV2 29.31 Hz
VIP2 11.81 Hz
NGF2 7.45 Hz
IT3 0.11 Hz
SOM3 1.59 Hz
PV3 3.77 Hz
VIP3 7.19 Hz
NGF3 4.77 Hz
ITP4 0.53 Hz
ITS4 0.46 Hz
SOM4 2.0 Hz
PV4 0.16 Hz
VIP4 4.54 Hz
NGF4 6.0 Hz
IT5A 0.75 Hz
CT5A 0.01 Hz
SOM5A 6.95 Hz
PV5A 0.0 Hz
VIP5A 0.6 Hz
NGF5A 2.38 Hz
IT5B 0.01 Hz
CT5B 0.0 Hz
PT5B 0.05 Hz
SOM5B 12.07 Hz
PV5B 0.0 Hz
VIP5B 0.53 Hz
NGF5B 1.12 Hz
IT6 0.0 Hz
CT6 0.17 Hz
SOM6 0.86 Hz
PV6 84.13 Hz
VIP6 101.33 Hz
NGF6 5.18 Hz
TC 25.67 Hz
TCM 1.78 Hz
HTC 24.29 Hz
IRE 0.57 Hz
IREM 2.5 Hz
TI 6.41 Hz
TIM 3.45 Hz
cochlea 0.0 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24apr12_24apr12_A1__rast.png]]

ylim((0,12908)); xlim((0,2e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr12_24apr12_A1__rastB.png]]

ok, even w/o cochlear input, the TC,HTC neurons are firing too fast. might be due to lower
IRE firing (compare to IREM firing )

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr12_24apr12_A1__spikehistA.png]]

and the lower IRE firing may be due to smaller space constant in core ... which
could instead be set differently for E vs I neurons 

*** 24apr12_A2_ : w/o cochlear input, and only thalamic spatial wiring for thalamic core E <-> E neurons -->> restored IRE rate and TC,HTC back to normal

changed the wiring rule in wireThal:
              # use spatially dependent wiring between thalamic core excitatory neurons
              if (pre == 'TC' and (post == 'TC' or post == 'HTC')) or (pre == 'HTC' and (post == 'TC' or post == 'HTC')):
                prob = '%f * exp(-dist_x/%f)' % (pmat[pre][post], dconf['net']['ThalamicCoreLambda'])
              else:
                prob = pmat[pre][post]  

./myrun 48

python -i simdat.py 24apr12_A2_

NGF1 1.49 Hz
IT2 0.31 Hz
SOM2 63.6 Hz
PV2 2.92 Hz
VIP2 5.31 Hz
NGF2 7.0 Hz
IT3 0.3 Hz
SOM3 0.59 Hz
PV3 0.88 Hz
VIP3 2.32 Hz
NGF3 4.91 Hz
ITP4 0.03 Hz
ITS4 0.08 Hz
SOM4 0.08 Hz
PV4 0.0 Hz
VIP4 13.15 Hz
NGF4 4.93 Hz
IT5A 1.94 Hz
CT5A 0.01 Hz
SOM5A 4.84 Hz
PV5A 0.34 Hz
VIP5A 1.4 Hz
NGF5A 4.5 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 6.53 Hz
PV5B 0.58 Hz
VIP5B 1.06 Hz
NGF5B 3.25 Hz
IT6 0.0 Hz
CT6 0.04 Hz
SOM6 0.87 Hz
PV6 16.11 Hz
VIP6 47.25 Hz
NGF6 5.08 Hz
TC 3.86 Hz
TCM 3.85 Hz
HTC 3.61 Hz
IRE 2.23 Hz
IREM 2.52 Hz
TI 2.06 Hz
TIM 3.35 Hz
cochlea 0.0 Hz

ok, good, TC rates back to normal

ylim((0,12908)); xlim((0,2e3))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr12_24apr12_A2__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr12_24apr12_A2__spikehistA.png]]

looks ok

*** 24apr12_A3_ : same as last but with output_sound.wav (from jitterNoise.py) as cochlear input -->> need to debug soundwave input and rep. in cochlea spikes

./myrun 48

python -i simdat.py 24apr12_A3_

NGF1 1.49 Hz
IT2 0.31 Hz
SOM2 63.6 Hz
PV2 2.92 Hz
VIP2 5.31 Hz
NGF2 7.0 Hz
IT3 0.3 Hz
SOM3 0.59 Hz
PV3 0.88 Hz
VIP3 2.32 Hz
NGF3 4.91 Hz
ITP4 0.03 Hz
ITS4 0.08 Hz
SOM4 0.08 Hz
PV4 0.0 Hz
VIP4 13.15 Hz
NGF4 4.93 Hz
IT5A 1.94 Hz
CT5A 0.01 Hz
SOM5A 4.84 Hz
PV5A 0.34 Hz
VIP5A 1.4 Hz
NGF5A 4.5 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 6.53 Hz
PV5B 0.58 Hz
VIP5B 1.06 Hz
NGF5B 3.25 Hz
IT6 0.0 Hz
CT6 0.04 Hz
SOM6 0.87 Hz
PV6 16.11 Hz
VIP6 47.25 Hz
NGF6 5.08 Hz
TC 3.86 Hz
TCM 3.85 Hz
HTC 3.61 Hz
IRE 2.23 Hz
IREM 2.52 Hz
TI 2.06 Hz
TIM 3.35 Hz
cochlea 1.82 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr12_24apr12_A3__rast.png]]

xlim((0,2e3)); ylim((dstartidx['cochlea'],dendidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./24apr12_24apr12_A3__rastB.png]]

why are all cochlear neurons firing ... there should be frequency-specific response based
on the jittered input, which is usually at 0 amplitude ... strange

also thought soundwave was 10 s not 4 s ... 

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr12_24apr12_A3__spikehistA.png]]

* 24apr15
** 24apr15_A0_ : check cochlear wave file input duration

first check the wavfile 

python
from pylab import *
ion()
from input import readwav
dat,sampr = readwav('output_sound.wav')

dat.shape # (451644,)
sampr # 44100

dat.shape[0]/sampr # 10.241360544217686

so ~10.2 s ... 

so why does cochlear input end around 4.5 s into the simulation ?

from input import cochlearInputSpikes
out = cochlearInputSpikes(fnwave='output_sound.wav')

out.keys() # dict_keys(['spkT', 'cf'])

len(out['spkT']) # 10000 - for 10K cochlear neurons

out['spkT'][0]

# rst = [ [[t, idx] for t in spkT[idx] for spkT in enumerate(idx,out['spkT'])]]

t = np.arange(0,len(dat)/sampr,1/sampr)
plot(t, dat)

sound signal has periodically active portion up to ~9.5 s 

mxt = [np.amax(spkT) for spkT in out['spkT']]
np.amax(mxt) # 4526.4399999982

ia 4.5 s the max duration zilany algorithm can handle?

import cochlea
help(cochlea.run_zilany2014)

dat2 = dat[0:1*sampr]

from input import writewav
writewav(dat2, 'test.wav', sampr)

out2 = cochlearInputSpikes(fnwave='test.wav')

mxt = [np.amax(spkT) for spkT in out2['spkT']]
np.amax(mxt) # 450.9900000003003

no, there's some scaling issue apparently ... since even 1 s of input gets truncated to 450 ms ... 

fs = 100e3
s = cochlea.set_dbspl(dat2, 50)
pad = np.zeros(int(10e-3 * fs))
sound = np.concatenate( (s, pad) )      
len(sound) # 45100

anf=cochlea.run_zilany2014(sound,fs,anf_num=(10000/100, 0, 0), cf=(125,2000, 100),seed=0,powerlaw='approximate',species='human')
numCells = 10000
spkTimes = [list(anf.iloc[i]['spikes']*1000.) for i in range(numCells)]

mx = np.amax([np.amax(spkT) for spkT in spkTimes]) # 450.99000000029645

plot(np.linspace(0,1,len(s)),s)

even with their plotting, only getting 450 ms from the 1 s input ... :

import thorns as th

# Accumulate spike trains
anf_acc = th.accumulate(anf, keep=['cf', 'duration'])
anf_acc.sort_values('cf', ascending=False, inplace=True)

# Plot auditory nerve response
import matplotlib.pyplot as plt
fig, ax = plt.subplots(2,1)
th.plot_signal(signal=sound,fs=fs,ax=ax[0])
th.plot_neurogram(anf_acc,fs,ax=ax[1])

# savefig('gif/24apr15_test_cochlea_a0.png') #

hmm, must be a mixup in sampling rate of the sound input ... since fs sent to function is 100e3 and correct wav file sampling rate is 44100

but the zilany function requires at least 100 kHz sampling rate ... so then have to upsample

anf=cochlea.run_zilany2014(sound,sampr,anf_num=(10000/100, 0, 0), cf=(125,2000, 100),seed=0,powerlaw='approximate',species='human')

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/zilany2014/__init__.py", line 116, in run_zilany2014
    trains = itertools.chain(*nested)
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/zilany2014/__init__.py", line 149, in _run_channel
    cihc=float(cihc)
  File "cochlea/zilany2014/_zilany2014.pyx", line 119, in cochlea.zilany2014._zilany2014.run_ihc
AssertionError: Wrong Fs: 100e3 <= fs <= 500e3

from scipy.signal import resample_poly

x = resample_poly(dat2, 3, 1)

len(x) # 132300

plot(linspace(0,1, len(dat2)), dat2,'b')
plot( linspace(0,1, len(x)), x, 'r')

cannot tell them apart ... 

python
from pylab import *
ion()
from input import readwav
dat,sampr = readwav('output_sound.wav')
dat2 = dat[0:1*sampr]
import cochlea

from scipy.signal import resample_poly
x = resample_poly(dat2, 3, 1)

anf=cochlea.run_zilany2014(x,sampr*3)#,anf_num=(10000/100, 0, 0), cf=(125,2000, 100),seed=0,powerlaw='approximate',species='human')

hmm, but with this higher sampling rate, the cochlea code crashes ... may have to use exactly 100 kHz ??

from scipy.signal import resample
N = int(len(dat2) * 100e3 / sampr)
x = resample(dat2, N)
sampr = 100000

plot(linspace(0,1, len(dat2)), dat2,'b'); plot( linspace(0,1, len(x)), x, 'r'); # look VERY similar

anf=cochlea.run_zilany2014(x, sampr,anf_num=(10000/100, 0, 0), cf=(125,2000, 100),seed=0,powerlaw='approximate',species='human')

numCells = 10000
spkTimes = [list(anf.iloc[i]['spikes']*1000.) for i in range(numCells)]

mx = np.amax([np.amax(spkT) for spkT in spkTimes]) # 999.9999999981967

** 24apr15_A0_ : retest the input signal (test.wav 1 s duration)

just use 1 s of it from above: test.wav

run sim for 3 s

./myrun 48

* 24apr16
** check last output - 24apr15_A0_

python -i simdat.py 24apr15_A0_

NGF1 1.46 Hz
IT2 0.17 Hz
SOM2 44.8 Hz
PV2 3.85 Hz
VIP2 8.0 Hz
NGF2 8.82 Hz
IT3 0.25 Hz
SOM3 0.07 Hz
PV3 0.5 Hz
VIP3 3.86 Hz
NGF3 4.64 Hz
ITP4 0.02 Hz
ITS4 0.04 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 12.15 Hz
NGF4 6.36 Hz
IT5A 2.47 Hz
CT5A 0.01 Hz
SOM5A 5.12 Hz
PV5A 0.11 Hz
VIP5A 0.3 Hz
NGF5A 5.0 Hz
IT5B 0.03 Hz
CT5B 0.0 Hz
PT5B 0.12 Hz
SOM5B 5.62 Hz
PV5B 0.22 Hz
VIP5B 3.76 Hz
NGF5B 2.79 Hz
IT6 0.0 Hz
CT6 0.02 Hz
SOM6 1.38 Hz
PV6 21.14 Hz
VIP6 32.25 Hz
NGF6 6.71 Hz
TC 3.97 Hz
TCM 3.75 Hz
HTC 3.29 Hz
IRE 2.64 Hz
IREM 2.49 Hz
TI 2.39 Hz
TIM 3.65 Hz
cochlea 0.0 Hz

cochlear spikes look right for duration

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr16_24apr15_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr16_24apr15_A0__spikehistA.png]]

only see a slight increase in TC,HTC during cochlear activity, and does not translate into much more
spikes in A1 L4

so, need to increase strength of cochlea to thalamic core, and possibly matrix as well... 

** 24apr16_A0_ : increase strength, prob of cochlea -> Thal (primarily core, but also matrix) -->> still not much activity

adjust params as:
    "cochThalweightECore": 0.8,
    "cochThalweightICore": 0.2,
    "cochThalprobECore": 0.25,
    "cochThalprobICore": 0.125,
    "cochThalMatrixCoreFactor": 0.1,

./myrun 48

python -i simdat.py 24apr16_A0_

NGF1 1.46 Hz
IT2 0.17 Hz
SOM2 44.8 Hz
PV2 3.85 Hz
VIP2 8.0 Hz
NGF2 8.82 Hz
IT3 0.25 Hz
SOM3 0.07 Hz
PV3 0.5 Hz
VIP3 3.86 Hz
NGF3 4.64 Hz
ITP4 0.02 Hz
ITS4 0.04 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 12.15 Hz
NGF4 6.36 Hz
IT5A 2.47 Hz
CT5A 0.01 Hz
SOM5A 5.12 Hz
PV5A 0.11 Hz
VIP5A 0.3 Hz
NGF5A 5.0 Hz
IT5B 0.03 Hz
CT5B 0.0 Hz
PT5B 0.12 Hz
SOM5B 5.62 Hz
PV5B 0.22 Hz
VIP5B 3.76 Hz
NGF5B 2.79 Hz
IT6 0.0 Hz
CT6 0.02 Hz
SOM6 1.38 Hz
PV6 21.14 Hz
VIP6 32.25 Hz
NGF6 6.71 Hz
TC 3.97 Hz
TCM 3.75 Hz
HTC 3.29 Hz
IRE 2.64 Hz
IREM 2.49 Hz
TI 2.39 Hz
TIM 3.65 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr16_24apr16_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr16_24apr16_A0__spikehistA.png]]

still only seeing a slight increase ... 

** 24apr16_B0_ : even stronger coch -> Thal -->> still a weak response

    "ICThalMatrixCoreFactor": 0.1,
    "cochThalweightECore": 1.0,
    "cochThalweightICore": 0.25,
    "cochThalprobECore": 0.35,
    "cochThalprobICore": 0.125,
    "cochThalMatrixCoreFactor": 0.25,

./myrun 48

python -i simdat.py 24apr16_B0_

NGF1 1.46 Hz
IT2 0.17 Hz
SOM2 44.8 Hz
PV2 3.85 Hz
VIP2 8.0 Hz
NGF2 8.82 Hz
IT3 0.25 Hz
SOM3 0.07 Hz
PV3 0.5 Hz
VIP3 3.86 Hz
NGF3 4.64 Hz
ITP4 0.02 Hz
ITS4 0.04 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 12.15 Hz
NGF4 6.36 Hz
IT5A 2.47 Hz
CT5A 0.01 Hz
SOM5A 5.12 Hz
PV5A 0.11 Hz
VIP5A 0.3 Hz
NGF5A 5.0 Hz
IT5B 0.03 Hz
CT5B 0.0 Hz
PT5B 0.12 Hz
SOM5B 5.62 Hz
PV5B 0.22 Hz
VIP5B 3.76 Hz
NGF5B 2.79 Hz
IT6 0.0 Hz
CT6 0.02 Hz
SOM6 1.38 Hz
PV6 21.14 Hz
VIP6 32.25 Hz
NGF6 6.71 Hz
TC 3.97 Hz
TCM 3.75 Hz
HTC 3.29 Hz
IRE 2.64 Hz
IREM 2.49 Hz
TI 2.39 Hz
TIM 3.65 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [./gif/24apr16_24apr16_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr16_24apr16_B0__spikehistA.png]]

what are the cfs of the cochlear cells firing? Thal Core and A1 here tuned primarily
to 1 - 2 kHz range ... 

simConfig['simConfig']['cochlearCenterFreqs']

N = 0
lcf = simConfig['simConfig']['cochlearCenterFreqs']
for i in range(len(lcf)): 
  if lcf[i] >= 1e3 and lcf[i] <= 2e3: N+=1

N # 1400

so ~1400 cochlear cells (> 10% of total) project to thalamic core ... 

len(lcf) # 10000

can increase the lambda for cochlea -> core -> A1 ; 5 microns was chosen at
a small level initially to have sharp RFs ... can increase it a bit to see impact

** 24apr16_C0_ : increase ThalamicCoreLambda from 5 to 10 -->> more noticeable thalamic,A1 response during cochlear activation

./myrun 48

python -i simdat.py 24apr16_C0_

NGF1 1.35 Hz
IT2 0.21 Hz
SOM2 54.6 Hz
PV2 1.31 Hz
VIP2 4.31 Hz
NGF2 8.18 Hz
IT3 0.27 Hz
SOM3 0.24 Hz
PV3 0.69 Hz
VIP3 3.18 Hz
NGF3 4.67 Hz
ITP4 0.07 Hz
ITS4 0.08 Hz
SOM4 0.04 Hz
PV4 0.0 Hz
VIP4 11.23 Hz
NGF4 6.43 Hz
IT5A 2.31 Hz
CT5A 0.01 Hz
SOM5A 5.93 Hz
PV5A 0.08 Hz
VIP5A 1.1 Hz
NGF5A 5.0 Hz
IT5B 0.04 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 6.27 Hz
PV5B 0.16 Hz
VIP5B 4.35 Hz
NGF5B 2.46 Hz
IT6 0.0 Hz
CT6 0.03 Hz
SOM6 1.16 Hz
PV6 24.5 Hz
VIP6 43.17 Hz
NGF6 6.34 Hz
TC 3.83 Hz
TCM 3.58 Hz
HTC 3.03 Hz
IRE 2.25 Hz
IREM 2.2 Hz
TI 2.2 Hz
TIM 3.31 Hz
cochlea 0.0 Hz


drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr16_24apr16_C0__rast.png]]

xlim((0,2e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr16_24apr16_C0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr16_24apr16_C0__spikehistA.png]]

can see higher firing in TC,HTC,TCM during cochlear activation now which dies down afterwards, and a response in ITP4, ITS4 as well,
mostly as a single population spike ... 

how does CSD look?

from netpyne import sim
fn = 'data/24apr16_C0_/24apr16_C0__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,2e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr16_24apr16_C0__CSD__CSD_overlay_pad1_a1.png]]

can see a pretty big sink in L4 in middle of auditory activation; supragran has a sink too ... which
starts a little after the granular sink ... 

** 24apr16_D0_ : increase ThalamicCoreLambda from 10 to 20 -->> strong response in L4 but only single transient, thal slightly elevated during cochlea activation

./myrun 48

python -i simdat.py 24apr16_D0_

NGF1 1.36 Hz
IT2 0.28 Hz
SOM2 45.2 Hz
PV2 9.38 Hz
VIP2 7.5 Hz
NGF2 8.64 Hz
IT3 0.25 Hz
SOM3 0.1 Hz
PV3 1.09 Hz
VIP3 4.87 Hz
NGF3 4.83 Hz
ITP4 0.24 Hz
ITS4 0.28 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 9.46 Hz
NGF4 7.36 Hz
IT5A 1.71 Hz
CT5A 0.01 Hz
SOM5A 5.19 Hz
PV5A 0.16 Hz
VIP5A 0.4 Hz
NGF5A 4.12 Hz
IT5B 0.38 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 8.3 Hz
PV5B 0.23 Hz
VIP5B 2.47 Hz
NGF5B 2.08 Hz
IT6 0.0 Hz
CT6 0.07 Hz
SOM6 0.9 Hz
PV6 31.43 Hz
VIP6 59.5 Hz
NGF6 6.63 Hz
TC 4.24 Hz
TCM 4.16 Hz
HTC 4.05 Hz
IRE 2.14 Hz
IREM 2.3 Hz
TI 2.41 Hz
TIM 3.67 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr17_24apr16_D0__rast.png]]

xlim((0,2e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr17_24apr16_D0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr17_24apr16_D0__spikehistA.png]]

see a pretty strong response in TC and L4 but only briefly in L4, afterwards there 
is almost no activity there

and CSD ... ?

from netpyne import sim
fn = 'data/24apr16_D0_/24apr16_D0__data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,2e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr17_24apr16_D0__CSD__CSD_overlay_pad1_a1.png]]

not clear why there is only a single response in L4 and no further activation
also not clear why TC,HTC,TCM do not really appear elevated during cochlear activation, and carry
on almost barely lower after cochlear activation, 

need to tune further - possible that background input into thal is too strong, or cochlear input too weak ... ? 

also have to see why L4 only responds single time

* 24apr17
** check params in data/v34_batch25/trial_2142/trial_2142_cfg.json -- many are used in cfg.py
and over-write values initially set via sim.json

** adjusting dconf load for after cfgLoad (which loads trial_2142_cfg.json), but make values consistent to start

note that EEGain, EIGain were overwriting dconf values and were not all == 1.0, this was set during model initial tuning
some values such as EbkgThalamicGain are likely also to maintain low firing rates for disconnected/isolated populations
may need adjustment to make distinction between auditory stimuli ON vs OFF

** 24apr16_E0_ : test model with cfg,dconf changes -->> same output, so params loaded properly

to make sure get same output as before, afterwards, can see about adjusting params further

./myrun 48

python -i simdat.py 24apr16_E0_

NGF1 1.36 Hz
IT2 0.28 Hz
SOM2 45.2 Hz
PV2 9.38 Hz
VIP2 7.5 Hz
NGF2 8.64 Hz
IT3 0.25 Hz
SOM3 0.1 Hz
PV3 1.09 Hz
VIP3 4.87 Hz
NGF3 4.83 Hz
ITP4 0.24 Hz
ITS4 0.28 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 9.46 Hz
NGF4 7.36 Hz
IT5A 1.71 Hz
CT5A 0.01 Hz
SOM5A 5.19 Hz
PV5A 0.16 Hz
VIP5A 0.4 Hz
NGF5A 4.12 Hz
IT5B 0.38 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 8.3 Hz
PV5B 0.23 Hz
VIP5B 2.47 Hz
NGF5B 2.08 Hz
IT6 0.0 Hz
CT6 0.07 Hz
SOM6 0.9 Hz
PV6 31.43 Hz
VIP6 59.5 Hz
NGF6 6.63 Hz
TC 4.24 Hz
TCM 4.16 Hz
HTC 4.05 Hz
IRE 2.14 Hz
IREM 2.3 Hz
TI 2.41 Hz
TIM 3.67 Hz
cochlea 0.0 Hz

rates look same as last, so adjustments to sim.py loaded all params properly

** add onset param for CochlearThalInput -- so can start auditory stream when want, e.g. at steady state
** 24apr16_F0_ : cut background thalamic gains by ~50% to see if more distinction btwn cochlea on vs OFF periods

cut these in ~1/2 to:
  "EbkgThalamicGain": 1.96,
  "IbkgThalamicGain": 1.96

and also start the cochlear input after 1 s, to allow net to stabilize a bit more first

run for 4 s ...

./myrun 48

* 24apr18
** check 24apr16_F0_ -->> not much cochlear activation of TC, and lower thal firing due to lower background input 

python -i simdat.py 24apr16_F0_

NGF1 1.63 Hz
IT2 0.23 Hz
SOM2 53.4 Hz
PV2 0.77 Hz
VIP2 3.44 Hz
NGF2 5.55 Hz
IT3 0.25 Hz
SOM3 0.57 Hz
PV3 0.18 Hz
VIP3 1.8 Hz
NGF3 4.35 Hz
ITP4 0.0 Hz
ITS4 0.03 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 11.38 Hz
NGF4 4.71 Hz
IT5A 2.09 Hz
CT5A 0.0 Hz
SOM5A 4.44 Hz
PV5A 0.56 Hz
VIP5A 1.2 Hz
NGF5A 4.12 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.11 Hz
SOM5B 4.37 Hz
PV5B 0.63 Hz
VIP5B 3.94 Hz
NGF5B 3.29 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 1.41 Hz
PV6 7.01 Hz
VIP6 29.58 Hz
NGF6 6.58 Hz
TC 0.39 Hz
TCM 0.52 Hz
HTC 0.42 Hz
IRE 1.56 Hz
IREM 1.48 Hz
TI 0.1 Hz
TIM 1.63 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr18_24apr16_F0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr18_24apr16_F0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr18_24apr16_F0__spikehistA.png]]

not seeing much activity in thal during cochlear activation, and therefore not much propagating to L4 ; 
however, overall the thalamic neuron firing rates are significantly lower due to reduced background activation

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,2e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr18_24apr16_F0__CSD__CSD_overlay_pad1_a1.png]]

** 24apr18_A0_ : double thalamic core lambda from 20 to 40 micron -->> still weak thalamic response

./myrun 48

python -i simdat.py 24apr18_A0_

NGF1 1.64 Hz
IT2 0.28 Hz
SOM2 58.6 Hz
PV2 1.46 Hz
VIP2 3.06 Hz
NGF2 5.09 Hz
IT3 0.25 Hz
SOM3 0.77 Hz
PV3 0.19 Hz
VIP3 1.8 Hz
NGF3 4.29 Hz
ITP4 0.01 Hz
ITS4 0.05 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 13.31 Hz
NGF4 4.64 Hz
IT5A 2.12 Hz
CT5A 0.0 Hz
SOM5A 4.23 Hz
PV5A 0.52 Hz
VIP5A 2.0 Hz
NGF5A 4.38 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 4.58 Hz
PV5B 0.62 Hz
VIP5B 4.71 Hz
NGF5B 3.21 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 1.27 Hz
PV6 7.17 Hz
VIP6 29.67 Hz
NGF6 6.63 Hz
TC 0.27 Hz
TCM 0.5 Hz
HTC 0.24 Hz
IRE 1.42 Hz
IREM 1.65 Hz
TI 0.02 Hz
TIM 1.63 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr18_24apr18_A0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr18_24apr18_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr18_24apr18_A0__spikehistA.png]]

still not seeing much activation of thal during cochlear inputs

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,2e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr18_24apr18_A0__CSD__CSD_overlay_pad1_a1.png]]

should check how many of the cochlear neurons that project to core are activated, rather than total cochlear neurons,
some of which may not even reach core ... although, they should still reach matrix ... 

** 24apr18_B0_ : double thalamic core lambda from 40 to 80 -->> still not much activity in thal

./myrun 48

python -i simdat.py 24apr18_B0_

NGF1 1.63 Hz
IT2 0.17 Hz
SOM2 48.8 Hz
PV2 0.38 Hz
VIP2 7.06 Hz
NGF2 5.91 Hz
IT3 0.23 Hz
SOM3 0.31 Hz
PV3 0.15 Hz
VIP3 2.99 Hz
NGF3 4.43 Hz
ITP4 0.02 Hz
ITS4 0.06 Hz
SOM4 0.08 Hz
PV4 0.0 Hz
VIP4 12.31 Hz
NGF4 4.79 Hz
IT5A 2.86 Hz
CT5A 0.03 Hz
SOM5A 4.21 Hz
PV5A 0.42 Hz
VIP5A 1.8 Hz
NGF5A 4.75 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.09 Hz
SOM5B 5.12 Hz
PV5B 0.31 Hz
VIP5B 4.41 Hz
NGF5B 3.62 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 1.43 Hz
PV6 12.8 Hz
VIP6 32.58 Hz
NGF6 7.42 Hz
TC 0.39 Hz
TCM 0.4 Hz
HTC 0.61 Hz
IRE 1.54 Hz
IREM 1.75 Hz
TI 0.04 Hz
TIM 1.51 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr18_24apr18_B0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr18_24apr18_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr18_24apr18_B0__spikehistA.png]]

still not much activity in thal ... 

** 24apr18_C0_ : double thalamiccorelambda from 80 to 160 -->> slightly more TC,HTC during stim

./myrun 48

python -i simdat.py 24apr18_C0_

NGF1 1.51 Hz
IT2 0.31 Hz
SOM2 63.2 Hz
PV2 2.0 Hz
VIP2 5.19 Hz
NGF2 6.09 Hz
IT3 0.24 Hz
SOM3 0.54 Hz
PV3 0.22 Hz
VIP3 3.18 Hz
NGF3 4.46 Hz
ITP4 0.07 Hz
ITS4 0.22 Hz
SOM4 0.08 Hz
PV4 0.0 Hz
VIP4 14.85 Hz
NGF4 5.07 Hz
IT5A 2.69 Hz
CT5A 0.0 Hz
SOM5A 5.37 Hz
PV5A 0.33 Hz
VIP5A 0.6 Hz
NGF5A 3.38 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.06 Hz
SOM5B 6.89 Hz
PV5B 0.13 Hz
VIP5B 2.94 Hz
NGF5B 2.71 Hz
IT6 0.0 Hz
CT6 0.02 Hz
SOM6 1.25 Hz
PV6 16.02 Hz
VIP6 38.67 Hz
NGF6 7.08 Hz
TC 0.31 Hz
TCM 0.39 Hz
HTC 0.5 Hz
IRE 1.59 Hz
IREM 1.39 Hz
TI 0.02 Hz
TIM 1.51 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr18_24apr18_C0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr18_24apr18_C0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr18_24apr18_C0__spikehistA.png]]

maybe a little more activation in TC,HTC,TCM during stim, compared to after (before stim
there's a pop spike)... L4 activity also not ramping up until after cochlear stimulation

** 24apr18_D0_ : restore level of background noise to thal to 3.92 for E,I

./myrun 48

* 24apr19
** check output from 24apr18_D0_ -->> slightly improved discrimination?

python -i simdat.py 24apr18_D0_

NGF1 0.21 Hz
IT2 4.56 Hz
SOM2 108.0 Hz
PV2 20.77 Hz
VIP2 0.0 Hz
NGF2 14.36 Hz
IT3 0.77 Hz
SOM3 26.86 Hz
PV3 28.44 Hz
VIP3 5.54 Hz
NGF3 7.63 Hz
ITP4 1.58 Hz
ITS4 1.2 Hz
SOM4 20.42 Hz
PV4 0.93 Hz
VIP4 8.15 Hz
NGF4 9.29 Hz
IT5A 1.15 Hz
CT5A 0.02 Hz
SOM5A 29.98 Hz
PV5A 0.08 Hz
VIP5A 0.7 Hz
NGF5A 0.0 Hz
IT5B 0.46 Hz
CT5B 0.01 Hz
PT5B 0.01 Hz
SOM5B 39.29 Hz
PV5B 0.03 Hz
VIP5B 0.18 Hz
NGF5B 0.04 Hz
IT6 0.25 Hz
CT6 2.26 Hz
SOM6 44.59 Hz
PV6 0.0 Hz
VIP6 25.5 Hz
NGF6 45.61 Hz
TC 3.29 Hz
TCM 3.39 Hz
HTC 3.03 Hz
IRE 3.72 Hz
IREM 2.33 Hz
TI 2.65 Hz
TIM 3.31 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr19_24apr18_D0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr19_24apr18_D0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr19_24apr18_D0__spikehistA.png]]

response is a little higher during stimulation in TC compared to after stimulation
ignoring the initial burst of activity during initialization

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,4e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr19_24apr18_D0__CSD__CSD_overlay_pad1_a1.png]]

simConfig['simConfig']['cochlearCenterFreqs'][0] # 125.0

lcf = simConfig['simConfig']['cochlearCenterFreqs']
lcf[3400] # 1043.3204349063694
lcf[4800] # 2041.466256495276
lcf[4799] # 1948.2906436203864

dstartidx['cochlea'],dendidx['cochlea'] # (12908, 22907)

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistB.png') # [[./gif/24apr19_24apr18_D0__spikehistB.png]]

ok, so much lower firing rate from the subset of cochlear neurons projecting to core
only between 9-24 Hz or so ... 

** 24apr19_A0_ : increase weight and prob. from coch to thal, and thal to L4 E (slight) -->> difficult to tell apart during vs after coch

    "cochThalweightECore": 3.0,
    "cochThalweightICore": 0.5,
    "cochThalprobECore": 0.5,
    "cochThalprobICore": 0.15,
    "cochThalMatrixCoreFactor": 0.125,

    "thalL4E": 2,

./myrun 48

python -i simdat.py 24apr19_A0_

NGF1 0.07 Hz
IT2 7.54 Hz   <<-- too fast
SOM2 143.2 Hz
PV2 1.08 Hz
VIP2 0.0 Hz
NGF2 12.82 Hz
IT3 1.23 Hz
SOM3 43.77 Hz
PV3 33.14 Hz
VIP3 5.24 Hz
NGF3 9.85 Hz
ITP4 2.18 Hz
ITS4 1.54 Hz
SOM4 27.79 Hz
PV4 1.61 Hz
VIP4 16.92 Hz
NGF4 11.71 Hz
IT5A 0.73 Hz
CT5A 0.08 Hz
SOM5A 42.33 Hz
PV5A 1.56 Hz
VIP5A 0.3 Hz
NGF5A 0.0 Hz
IT5B 0.5 Hz
CT5B 0.24 Hz
PT5B 0.01 Hz
SOM5B 51.94 Hz
PV5B 0.36 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 1.52 Hz
CT6 2.75 Hz
SOM6 57.79 Hz
PV6 0.0 Hz
VIP6 25.17 Hz
NGF6 67.74 Hz
TC 3.09 Hz
TCM 3.5 Hz
HTC 3.45 Hz
IRE 3.56 Hz
IREM 2.08 Hz
TI 3.06 Hz
TIM 3.55 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr19_24apr19_A0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr19_24apr19_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr19_24apr19_A0__spikehistA.png]]

very difficult to see diff in hist rates

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,4e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr19_24apr19_A0__CSD__CSD_overlay_pad1_a1.png]]

** 24apr19_B0_ : increase cochThalWeightECord from 3 to 9

./myrun 48

* 24apr22
** check output from 24apr19_B0_ -->> still pretty weak response in thalamic core

python -i simdat.py 24apr19_B0_

NGF1 0.07 Hz
IT2 7.54 Hz
SOM2 143.2 Hz
PV2 1.08 Hz
VIP2 0.0 Hz
NGF2 12.82 Hz
IT3 1.23 Hz
SOM3 43.77 Hz
PV3 33.14 Hz
VIP3 5.24 Hz
NGF3 9.85 Hz
ITP4 2.18 Hz
ITS4 1.54 Hz
SOM4 27.79 Hz
PV4 1.61 Hz
VIP4 16.92 Hz
NGF4 11.71 Hz
IT5A 0.73 Hz
CT5A 0.08 Hz
SOM5A 42.33 Hz
PV5A 1.56 Hz
VIP5A 0.3 Hz
NGF5A 0.0 Hz
IT5B 0.5 Hz
CT5B 0.24 Hz
PT5B 0.01 Hz
SOM5B 51.94 Hz
PV5B 0.36 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 1.52 Hz
CT6 2.75 Hz
SOM6 57.79 Hz
PV6 0.0 Hz
VIP6 25.17 Hz
NGF6 67.74 Hz
TC 3.09 Hz
TCM 3.5 Hz
HTC 3.45 Hz
IRE 3.56 Hz
IREM 2.08 Hz
TI 3.06 Hz
TIM 3.55 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr22_24apr19_B0__rast.png]]

xlim((1e3,3e3)); ylim(0,(dstartidx['cochlea']))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr22_24apr19_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr22_24apr19_B0__spikehistA.png]]

still cannot see a substantial difference ... is the cochlea -> thal connectivity code buggy?

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,4e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr22_24apr19_B0__CSD__CSD_overlay_pad1_a1.png]]

** check cochlear connectivity rules/code

10000 cochlear cells
want a fraction of those cells to project to the column frequency range min to max values along the x-axis

if cell has frequency within range:
 x_coord = ((x_id - offset)/cellsinRange) * sizeX

offset = starting ID of first cell in range

something like this:

def setCochCellLocations (pop, sz, scale, checkcf=True):
  # set the cell positions on a line
  if pop not in sim.net.pops: return
  offset = sim.simData['dminID'][pop]
  ncellinrange = 0 # number of cochlear cells with center frequency in frequency range represented by this model
  sidx = -1
  for idx,cf in enumerate(cochlearCenterFreqs):
    if cf >= cfg.cochThalFreqRange[0] and cf <= cfg.cochThalFreqRange[1]:
      if sidx == -1: sidx = idx # start index
      ncellinrange += 1
  offset += sidx
  print('setCochCellLocations: sidx, offset = ', sidx, offset)
  for c in sim.net.cells:
    if c.gid in sim.net.pops[pop].cellGids:
      if checkcf:
        cf = cochlearCenterFreqs[c.gid-offset]
        if cf >= cfg.cochThalFreqRange[0] and cf <= cfg.cochThalFreqRange[1]:
          c.tags['x'] = cellx = ((c.gid-offset)/ncellinrange) * scale
          c.tags['xnorm'] = cellx / netParams.sizeX # make sure these values consistent
        else:
          c.tags['x'] = cellx = 100000  # put it outside range for core
          c.tags['xnorm'] = cellx / netParams.sizeX # make sure these values consistent
      else:
        c.tags['x'] = cellx = ((c.gid-offset)/sz) * scale
        c.tags['xnorm'] = cellx / netParams.sizeX # make sure these values consistent
      c.updateShape()

** 24apr22_A0_: re-try with that fixup for scaling of cochlear cell positions -->> still weak TC response

python -i simdat.py 24apr22_A0_

NGF1 0.07 Hz
IT2 7.54 Hz
SOM2 143.2 Hz
PV2 1.08 Hz
VIP2 0.0 Hz
NGF2 12.82 Hz
IT3 1.23 Hz
SOM3 43.77 Hz
PV3 33.14 Hz
VIP3 5.24 Hz
NGF3 9.85 Hz
ITP4 2.18 Hz
ITS4 1.54 Hz
SOM4 27.79 Hz
PV4 1.61 Hz
VIP4 16.92 Hz
NGF4 11.71 Hz
IT5A 0.73 Hz
CT5A 0.08 Hz
SOM5A 42.33 Hz
PV5A 1.56 Hz
VIP5A 0.3 Hz
NGF5A 0.0 Hz
IT5B 0.5 Hz
CT5B 0.24 Hz
PT5B 0.01 Hz
SOM5B 51.94 Hz
PV5B 0.36 Hz
VIP5B 0.0 Hz
NGF5B 0.0 Hz
IT6 1.52 Hz
CT6 2.75 Hz
SOM6 57.79 Hz
PV6 0.0 Hz
VIP6 25.17 Hz
NGF6 67.74 Hz
TC 3.09 Hz
TCM 3.5 Hz
HTC 3.45 Hz
IRE 3.56 Hz
IREM 2.08 Hz
TI 3.06 Hz
TIM 3.55 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr22_24apr22_A0__rast.png]]

xlim((1e3,3e3)); ylim((dstartidx['cochlea'],0))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr22_24apr22_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr22_24apr22_A0__spikehistA.png]]

still do not see inc in thal during cochlear activation ... count the spikes

len(sh['cochlea']) # 2
len(sh['cochlea'][1]) # 160, 160 x 25 = 4000
np.sum(sh['cochlea'][1][40:80]) # 2853.012
np.sum(sh['cochlea'][1][81:120]) # 0.0

np.sum(sh['TC'][1][0:40]) # 312.7586206896552  <<-- initial pop spike
np.sum(sh['TC'][1][40:80]) # 213.44827586206898 <<-- during cochlear activation
np.sum(sh['TC'][1][81:120]) # 189.65517241379317 <<-- after cochlear activation
np.sum(sh['TC'][1][121:160]) # 123.44827586206894 <<-- after cochlear activation

so, it's higher during cochlear activation than after, but not by much ...

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,4e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24apr22_24apr22_A0__CSD__CSD_overlay_pad1_a1.png]]

** 24apr22_B0_ : inc prob cochlear -> core and matrix, turn off background thal input -->> 0 thalamic spikes, why?

inc probability of cochlear input to core and matrix to 1.0 to make sure that drives their responses

turn off background activation to isolate cochlear inputs

./myrun 48

python -i simdat.py 24apr22_B0_

NGF1 1.57 Hz
IT2 0.2 Hz
SOM2 63.8 Hz
PV2 0.0 Hz
VIP2 4.94 Hz
NGF2 5.36 Hz
IT3 0.24 Hz
SOM3 0.36 Hz
PV3 0.12 Hz
VIP3 1.92 Hz
NGF3 4.35 Hz
ITP4 0.0 Hz
ITS4 0.01 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 14.54 Hz
NGF4 4.64 Hz
IT5A 2.8 Hz
CT5A 0.0 Hz
SOM5A 4.21 Hz
PV5A 0.55 Hz
VIP5A 3.3 Hz
NGF5A 4.38 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.1 Hz
SOM5B 4.94 Hz
PV5B 0.32 Hz
VIP5B 3.06 Hz
NGF5B 3.42 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 1.65 Hz
PV6 9.2 Hz
VIP6 35.75 Hz
NGF6 7.39 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24apr22_24apr22_B0__rast.png]]

0 thalamic spikes ... 

xlim((1e3,3e3)); ylim((dstartidx['cochlea'],0))
savefig(gifpath()+'_rastB.png') # [[./gif/24apr22_24apr22_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24apr22_24apr22_B0__spikehistA.png]]

np.sum(sh['TC'][1][0:40]) #  0
np.sum(sh['TC'][1][40:80]) #  0
np.sum(sh['TC'][1][81:120]) #  0
np.sum(sh['TC'][1][121:160]) #  0

are the cochlear neurons not synapsing on thalamic neurons?

subplot(1,2,1); drawcellVm(simConfig,ldrawpop=['TC','HTC', 'TCM']) # 
subplot(1,2,2); drawcellVm(simConfig,ldrawpop=['TI','IRE','IREM']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/24apr22_24apr22_B0__cell_Vm_a6.png]]

there is some activation of the thalamic neurons, but very far below threshold ... is it
intrinsic currents? or synaptic input? check by increasing weights from cochlea further ... 

** 24apr22_C0_ : large increase of weight from cochlea to thal to test connection -->> still no thal spikes

./myrun 48

  Run time: 825.09 s
   NGF1 : 1.342 Hz
   IT2 : 0.240 Hz
   SOM2 : 34.727 Hz
   PV2 : 2.797 Hz
   VIP2 : 7.585 Hz
   NGF2 : 6.864 Hz
   IT3 : 0.224 Hz
   SOM3 : 0.343 Hz
   PV3 : 0.153 Hz
   VIP3 : 2.892 Hz
   NGF3 : 4.224 Hz
   ITP4 : 0.002 Hz
   ITS4 : 0.008 Hz
   SOM4 : 0.040 Hz
   PV4 : 0.000 Hz
   VIP4 : 8.776 Hz
   NGF4 : 3.636 Hz
   IT5A : 2.150 Hz
   CT5A : 0.005 Hz
   SOM5A : 3.734 Hz
   PV5A : 0.360 Hz
   VIP5A : 2.273 Hz
   NGF5A : 2.670 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 0.110 Hz
   SOM5B : 4.291 Hz
   PV5B : 0.472 Hz
   VIP5B : 4.347 Hz
   NGF5B : 3.333 Hz
   IT6 : 0.000 Hz
   CT6 : 0.012 Hz
   SOM6 : 1.222 Hz
   PV6 : 10.537 Hz
   VIP6 : 34.504 Hz
   NGF6 : 5.096 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   TI : 0.000 Hz
   TIM : 0.000 Hz
   cochlea : 33.431 Hz

python -i simdat.py 24apr22_C0_

NGF1 1.45 Hz
IT2 0.28 Hz
SOM2 37.2 Hz
PV2 4.0 Hz
VIP2 10.88 Hz
NGF2 9.0 Hz
IT3 0.27 Hz
SOM3 0.17 Hz
PV3 0.29 Hz
VIP3 3.96 Hz
NGF3 5.75 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.04 Hz
PV4 0.0 Hz
VIP4 12.23 Hz
NGF4 4.86 Hz
IT5A 2.27 Hz
CT5A 0.0 Hz
SOM5A 4.28 Hz
PV5A 0.47 Hz
VIP5A 3.2 Hz
NGF5A 2.75 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.08 Hz
SOM5B 5.04 Hz
PV5B 0.69 Hz
VIP5B 3.76 Hz
NGF5B 3.79 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 1.44 Hz
PV6 10.15 Hz
VIP6 37.58 Hz
NGF6 6.24 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 56.79 Hz

subplot(1,2,1); drawcellVm(simConfig,ldrawpop=['TC','HTC', 'TCM']) # 
subplot(1,2,2); drawcellVm(simConfig,ldrawpop=['TI','IRE','IREM']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/24apr22_24apr22_C0__cell_Vm_a6.png]]

hmm, looks ~same, so the cochlea -> thal connection must not be setup properly

* 24apr24
** debug cochlear -> thal conn
* 24apr25
** 24apr25_A0_ : debug cochlear -> thal conn

debug using plain probabalistic connectivity from cochlea -> thal instead of spatially dependent

./myrun 48

connecting cochlea to thal
coch to thal prob: 1.0
coch to thal prob: 1.0
coch to thal prob: 0.15
coch to thal prob: 0.15

python -i simdat.py 24apr25_A0_

NGF1 1.55 Hz
IT2 0.22 Hz
SOM2 34.6 Hz
PV2 2.85 Hz
VIP2 11.88 Hz
NGF2 7.82 Hz
IT3 0.24 Hz
SOM3 0.16 Hz
PV3 0.27 Hz
VIP3 4.03 Hz
NGF3 5.26 Hz
ITP4 0.0 Hz
ITS4 0.01 Hz
SOM4 0.04 Hz
PV4 0.0 Hz
VIP4 11.31 Hz
NGF4 3.79 Hz
IT5A 2.42 Hz
CT5A 0.0 Hz
SOM5A 4.16 Hz
PV5A 0.63 Hz
VIP5A 3.8 Hz
NGF5A 2.88 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.08 Hz
SOM5B 4.62 Hz
PV5B 0.57 Hz
VIP5B 5.76 Hz
NGF5B 4.33 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 1.52 Hz
PV6 11.21 Hz
VIP6 38.92 Hz
NGF6 6.39 Hz
TC 0.0 Hz           <<-- still at 0 Hz
TCM 0.0 Hz          <<-- still at 0 Hz
HTC 0.0 Hz          <<-- still at 0 Hz
IRE 0.0 Hz          <<-- still at 0 Hz
IREM 0.0 Hz         <<-- still at 0 Hz
TI 0.0 Hz           <<-- still at 0 Hz
TIM 0.0 Hz          <<-- still at 0 Hz
cochlea 71.33 Hz    <<--  >> 0 Hz

so even with standard probabalistic connections, cochlea fires, thalamic neurons do not

next test ... 

record the weights from cochlea to TC to make sure they are setup

python -i simdat.py

name = '24apr25_A0_'
d = pickle.load(open('data/24apr25_A0_synWeights.pkl','rb'))
d.keys() # dict_keys([])

hmm dictionary with cochlea -> TC connection weights is empty

python -i simdat.py 24apr25_A0_

simConfig.keys()
simConfig['net'].keys()
simConfig['net']['pops'].keys()
simConfig['net']['pops']['cochlea'].keys()
simConfig['net']['pops']['cochlea']['cellGids']

dnumc['cochlea'] # 10000
len(simConfig['net']['pops']['cochlea']['cellGids']) # 9791

?? what accounts for the discrepancy between dnumc for cochlea and len cellGids for cochlea?

simConfig['net']['pops']['cochlea']['numCells'] # 10000

could it be these lines contributing to problem?
        netParams.popParams['cochlea']['sizeX'] = 100000 # numCochlearCells + 1
        netParams.popParams['cochlea']['sizeY'] = netParams.popParams['cochlea']['sizeZ'] = 1

will try w/o them ...

./myrun 48

python -i simdat.py 24apr25_A0_

d = pickle.load(open('data/24apr25_A0_synWeights.pkl','rb'))
d.keys() # dict_keys([])

simConfig['net']['pops']['cochlea']['numCells'] # 10000

len(simConfig['net']['pops']['cochlea']['cellGids']) # 9791

hmm, still the same ...

and still no connections from cochlea -> TC

sc = simConfig
simConfig['net']

sc['net']['cells'][dstartidx['cochlea']].keys() # dict_keys(['gid', 'tags', 'conns', 'stims', 'params'])
len(sc['net']['cells'][dstartidx['cochlea']]['conns']) # 0

ll = [len(sc['net']['cells'][idx]['conns']) for idx in simConfig['net']['pops']['cochlea']['cellGids']]

len(ll) # 9791

np.amax(ll) # 0

* 24apr26
** continue debug

suggestions from sd:
 check netParams.connParams dict once variables are replaced, could debug by setting breakpoints in netpyne probability conn function
 the 10k vs 9.7k discrepancy in number of cells seems weird, only think that comes to mind is maybe the list of spkTimes is < numCells?

first check numcells discrepancy ... :
 len(cochlearSpkTimes): 10000


https://github.com/NathanKlineInstitute/navnet/tree/samn

python -i simdat.py 24apr26_A0_

simConfig['net']['pops']['cochlea']['numCells'] # 10000
len(simConfig['net']['pops']['cochlea']['cellGids']) # 9791

* 24apr29
** continue debug

can make a simple model with 2 pops: cochlear cells projecting to another population

* 24apr30
** more debug
** meet with dj

N1 refractoriness could arise from GABAB or NO activation
GABABrs are also present in thalamus; so strong activation via stimulus activate GABAB
then have to wait 1-3 s for GABAB effect to wear off, so that's why at longer than that
delay would get a heightened N1 response
so may need to add GABAB to thalamus to get that effect

before MMN can model SSA, since some claim that MMN is ~SSA but need to be
able to differentiate the two in model

* 24may1
** check IC model again with higher GABAB weights and tau

thalamus already has some gabab synapses between I -> E
but only uses gabaa to gabab them as 0.9 to 0.1 of total weight
so gabab only plays a minor role

also the tau2 of gabab was set to 260.9:
 netParams.synMechParams['GABAB'] = {'mod':'MyExp2SynBB', 'tau1': 3.5, 'tau2': 260.9, 'e': -93} 

so that would not account for very long delays required to get strong response to auditory
stimulation

ok, adjusted the fraction of gabab to higher level within thal (I->E) and also SOME -> E both to 50/50, NGF already had 50/50
and increased tau2 of gabab to 1000 ... 

try with 500 ms IC input interval ... test

24may1_A0_

python -i simdat.py 24may1_A0_

NGF1 2.25 Hz
IT2 0.42 Hz
SOM2 8.0 Hz
PV2 2.0 Hz
VIP2 8.75 Hz
NGF2 2.0 Hz
IT3 0.6 Hz
SOM3 0.12 Hz
PV3 0.02 Hz
VIP3 3.46 Hz
NGF3 3.76 Hz
ITP4 0.0 Hz
ITS4 0.25 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 6.67 Hz
NGF4 3.33 Hz
IT5A 0.29 Hz
CT5A 0.0 Hz
SOM5A 1.2 Hz
PV5A 0.11 Hz
VIP5A 3.0 Hz
NGF5A 2.5 Hz
IT5B 0.15 Hz
CT5B 0.0 Hz
PT5B 0.37 Hz
SOM5B 1.36 Hz
PV5B 1.42 Hz
VIP5B 7.25 Hz
NGF5B 6.17 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 0.2 Hz
PV6 0.0 Hz
VIP6 14.67 Hz
NGF6 3.25 Hz
TC 0.38 Hz
TCM 0.39 Hz
HTC 0.11 Hz
IRE 1.53 Hz
IREM 1.45 Hz
TI 11.83 Hz
TIM 13.33 Hz
IC 5.67 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24may1_24may1_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistA.png') # [[./gif/24may1_24may1_A0__spikehistA.png]]

even IC barely activating thal ... but that could be because of change in gabab level/duration
and for short interval between inputs ... ? 

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,4e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24may1_24may1_A0__CSD__CSD_overlay_pad1_a1.png]]

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
bbnT = np.arange(2000, 4000, 500)
dt = 0.1
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from erp import getAvgERP

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05, norm=False, vaknin=True)

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:]/abs(np.sum(avgERP[chan,:])),clr)
  xlim((0,150)); xlabel('Time (ms)');
  gdx+=1

savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/24may1_24may1_A0__model_BBN_avg_ERP_CSD_a5.png]]

does not look like much ...

np.amin(avgERP[lchan[1],:]) # # -1.0317689779564745

and try longer run, then with longer interval ... see if differs ... 

hmm, scaleDensity was 0.25 ... 

retry ...

python -i simdat.py 24may1_A0_

NGF1 1.09 Hz
IT2 0.0 Hz
SOM2 0.0 Hz
PV2 0.0 Hz
VIP2 0.56 Hz
NGF2 2.55 Hz
IT3 0.09 Hz
SOM3 0.0 Hz
PV3 0.0 Hz
VIP3 1.18 Hz
NGF3 3.73 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 0.54 Hz
NGF4 4.0 Hz
IT5A 0.0 Hz
CT5A 0.0 Hz
SOM5A 0.0 Hz
PV5A 0.14 Hz
VIP5A 2.4 Hz
NGF5A 4.0 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.08 Hz
SOM5B 0.01 Hz
PV5B 0.4 Hz
VIP5B 5.18 Hz
NGF5B 3.17 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 0.02 Hz
PV6 0.0 Hz
VIP6 4.0 Hz
NGF6 4.66 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 1.41 Hz
IREM 1.22 Hz
TI 3.1 Hz
TIM 4.47 Hz
IC 5.67 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastB.png') # [[./gif/24may1_24may1_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistB.png') # [[./gif/24may1_24may1_A0__spikehistB.png]]

ok, barely any response in TC now ... 

what happens with gabab tau2 == original 260.9 ?

... or, first try longer delay

will try with original fractions and tau2 for comparison ... 

24may1_B0_

python -i simdat.py 24may1_B0_

NGF1 1.13 Hz
IT2 1.04 Hz
SOM2 6.8 Hz
PV2 2.38 Hz
VIP2 5.31 Hz
NGF2 12.73 Hz
IT3 0.91 Hz
SOM3 15.64 Hz
PV3 27.76 Hz
VIP3 4.46 Hz
NGF3 9.21 Hz
ITP4 0.39 Hz
ITS4 0.37 Hz
SOM4 1.92 Hz
PV4 1.27 Hz
VIP4 22.54 Hz
NGF4 9.29 Hz
IT5A 0.8 Hz
CT5A 0.0 Hz
SOM5A 16.72 Hz
PV5A 3.03 Hz
VIP5A 2.6 Hz
NGF5A 3.12 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.04 Hz
SOM5B 19.45 Hz
PV5B 1.87 Hz
VIP5B 3.06 Hz
NGF5B 2.42 Hz
IT6 0.08 Hz
CT6 0.37 Hz
SOM6 2.6 Hz
PV6 52.69 Hz
VIP6 68.83 Hz
NGF6 10.76 Hz
TC 1.27 Hz
TCM 0.29 Hz
HTC 1.29 Hz
IRE 1.43 Hz
IREM 1.46 Hz
TI 3.08 Hz
TIM 4.22 Hz
IC 5.67 Hz

savefig(gifpath()+'_rastB.png') # [[./gif/24may1_24may1_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistB.png') # [[./gif/24may1_24may1_B0__spikehistB.png]]

ok, with original gabab params, the signals get through to thal and then to L4 sometimes

can run this longer to see how many spikes get through at the current 500 ms interval and then at 1000 ms interval 

python -i simdat.py 24may1_B0_

NGF1 1.03 Hz
IT2 0.87 Hz
SOM2 8.12 Hz
PV2 2.03 Hz
VIP2 3.47 Hz
NGF2 20.36 Hz
IT3 1.4 Hz
SOM3 23.37 Hz
PV3 12.42 Hz
VIP3 8.81 Hz
NGF3 11.92 Hz
ITP4 0.63 Hz
ITS4 0.62 Hz
SOM4 5.9 Hz
PV4 5.11 Hz
VIP4 18.92 Hz
NGF4 11.26 Hz
IT5A 0.61 Hz
CT5A 0.13 Hz
SOM5A 23.25 Hz
PV5A 3.37 Hz
VIP5A 2.49 Hz
NGF5A 3.44 Hz
IT5B 0.02 Hz
CT5B 0.0 Hz
PT5B 0.04 Hz
SOM5B 26.75 Hz
PV5B 1.91 Hz
VIP5B 2.74 Hz
NGF5B 3.71 Hz
IT6 0.93 Hz
CT6 0.9 Hz
SOM6 23.2 Hz
PV6 15.38 Hz
VIP6 46.1 Hz
NGF6 31.96 Hz
TC 1.39 Hz
TCM 0.25 Hz
HTC 1.33 Hz
IRE 2.18 Hz
IREM 1.44 Hz
TI 2.88 Hz
TIM 4.04 Hz
IC 4.34 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may1_24may1_B0__rastC.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'],['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3,4]): 
  ax=subplot(4,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may1_24may1_B0__spikehistC.png]]

so ~1/2 of the inputs got through at 500 ms interval ... 

lchan = [4 + 1 , 10 + 1 , 15 + 1] # +1 due to vaknin
bbnT = np.arange(2000, 11000, 500)
dt = 0.1
sampr = 1e3/dt

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

from erp import getAvgERP

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, sampr, norm=False, vaknin=True)

ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

gdx=1
for chan,clr in zip(lchan,['r','g','b']): 
  subplot(1,3,gdx)
  plot(ttERP,avgERP[chan,:],clr)
  xlim((0,150)); xlabel('Time (ms)');
  gdx+=1

savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a6.png') # [[./gif/24may1_24may1_B0__model_BBN_avg_ERP_CSD_a6.png]]

CSD does not look great / realistic ... 

how about with 1000 ms interval ? 

* 24may2
** continue checks of N1, MUA during the IC BBN stimuli of varying intervals -->> 500, 1000, 1500 ms ISI leads to larger MUA (when have higher GABAB in thal)

python -i simdat.py 24may1_C0_

NGF1 1.07 Hz
IT2 0.87 Hz
SOM2 12.02 Hz
PV2 2.11 Hz
VIP2 3.48 Hz
NGF2 13.86 Hz
IT3 0.93 Hz
SOM3 18.34 Hz
PV3 11.13 Hz
VIP3 8.95 Hz
NGF3 8.82 Hz
ITP4 0.68 Hz
ITS4 0.68 Hz
SOM4 5.12 Hz
PV4 4.14 Hz
VIP4 19.76 Hz
NGF4 10.46 Hz
IT5A 0.69 Hz
CT5A 0.09 Hz
SOM5A 17.68 Hz
PV5A 2.76 Hz
VIP5A 2.45 Hz
NGF5A 3.9 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.05 Hz
SOM5B 20.33 Hz
PV5B 1.87 Hz
VIP5B 2.92 Hz
NGF5B 4.16 Hz
IT6 1.05 Hz
CT6 1.0 Hz
SOM6 25.69 Hz
PV6 12.25 Hz
VIP6 47.4 Hz
NGF6 34.7 Hz
TC 1.11 Hz
TCM 0.23 Hz
HTC 1.07 Hz
IRE 2.15 Hz
IREM 1.42 Hz
TI 2.98 Hz
TIM 4.07 Hz
IC 2.17 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may2_24may1_C0__rastC.png]]

with the longer ISI of 1 s, can that all of the stimuli propagate through into thal and L4

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ]
llclr = [ ['b','r'], ['r','g','b'],['r','g','b'], ['r','g']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3,4]): 
  ax=subplot(4,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may2_24may1_C0__spikehistC.png]]

could measure # of spikes in populations around stimulus times ... as stand-in for MUA

len(sh['TC'])

bbnT = np.arange(2000, 11000, 1000)
dt = 25
sampr = 40

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}

avgMUAAmp # {'TC': 3.5249042145593865, 'HTC': 3.157894736842105, 'TCM': 0.3010752688172043, 'IRE': 0.6666666666666666, 'IREM': 2.086021505376344, 'TI': 1.9389978213507628, 'ITP4': 1.2504978096375945, 'ITS4': 1.318199920350458}

ok, try that measure with the 500 ms ISI 

python -i simdat.py 24may1_B0_

bbnT = np.arange(2000, 11000, 500); dt = 25; sampr = 40

def ms2index (ms, sampr): return int(sampr*ms/1e3)

bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}

avgMUAAmp # {'TC': 2.4521072796934864, 'HTC': 2.39766081871345, 'TCM': 0.19713261648745517, 'IRE': 0.8172043010752688, 'IREM': 2.2867383512544803, 'TI': 1.6230936819172115, 'ITP4': 0.6876410460639852, 'ITS4': 0.6869772998805257}

most of the populations have lower firing rates during BBN with this shorter ISI of 500 ms (compared to 1000 ms)

doubt it would increase further at 1500 ms ISI, but worth a try ... 

24may2_D0_

set ISI to 1500 ms ...

  "ICThalInput": {"onset": 2000, "offset":11000, "interval": 1500, "file": "data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat"},

./myrun 48

actually, did not notice that have this GABAB at heightened level within Thal (2nd value is 0.5 for GABAB fraction of I->E synapses in Thal)):
       "Thal": {"I": {"E": [0.5, 0.5]}},

can test the whole sequence again with the baseline level which is 0.9, 0.1 (0.1 is fraction of GABAB)

python -i simdat.py 24may2_D0_

NGF1 1.2 Hz
IT2 0.75 Hz
SOM2 24.77 Hz
PV2 5.8 Hz
VIP2 4.53 Hz
NGF2 17.48 Hz
IT3 1.09 Hz
SOM3 16.45 Hz
PV3 7.35 Hz
VIP3 6.77 Hz
NGF3 10.0 Hz
ITP4 0.36 Hz
ITS4 0.38 Hz
SOM4 3.42 Hz
PV4 3.48 Hz
VIP4 16.49 Hz
NGF4 9.65 Hz
IT5A 1.08 Hz
CT5A 0.2 Hz
SOM5A 18.12 Hz
PV5A 2.57 Hz
VIP5A 1.98 Hz
NGF5A 3.53 Hz
IT5B 0.0 Hz
CT5B 0.03 Hz
PT5B 0.07 Hz
SOM5B 20.44 Hz
PV5B 1.14 Hz
VIP5B 2.38 Hz
NGF5B 3.5 Hz
IT6 0.94 Hz
CT6 0.6 Hz
SOM6 19.3 Hz
PV6 14.23 Hz
VIP6 44.59 Hz
NGF6 30.33 Hz
TC 0.89 Hz
TCM 0.26 Hz
HTC 0.89 Hz
IRE 1.72 Hz
IREM 1.38 Hz
TI 3.04 Hz
TIM 4.23 Hz
IC 1.45 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may2_24may2_D0__rastC.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh)

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may2_24may2_D0__spikehistC.png]]

probably subject to noise / network conditions, but in this case not all the stimuli
reach L4

bbnT = np.arange(2000, 11000, 1500); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}
avgMUAAmp # {'TC': 3.89367816091954, 'HTC': 3.5526315789473686, 'TCM': 0.20430107526881722, 'IRE': 0.7096774193548386, 'IREM': 1.4731182795698927, 'TI': 2.156862745098039, 'ITP4': 1.4595778574273197, 'ITS4': 1.4356829948227798}

most populations are firing at higher rates than in the 500 and 1000 ms ISI conditions, though some interneurons are lower ... so that may be reason for larger excit activation/MUA

** same tests w/o the increased GABAB in Thal (90/10 GABAA vs GABAB)
*** 24may2_GBBase_500ISI_ : 500 ms ISI
*** 24may2_GBBase_1000ISI_ : 1000 ms ISI
*** 24may2_GBBase_1500ISI_ : 1500 ms ISI
* 24may3
** netpyne gather fix from vb

diff --git a/netpyne/sim/gather.py b/netpyne/sim/gather.py
index e5872147..566ba379 100644
--- a/netpyne/sim/gather.py
+++ b/netpyne/sim/gather.py
@@ -499,9 +499,9 @@ def gatherDataFromFiles(gatherLFP=True, saveFolder=None, simLabel=None, sim=None
                         for key in singleNodeVecs:
                             allSimData[key] = list(fileData['simData'][key])
                         allPopsCellGids = {popLabel: [] for popLabel in nodePopsCellGids}
-                    else:
-                        for popLabel, popCellGids in nodePopsCellGids.items():
-                            allPopsCellGids[popLabel].extend(popCellGids)
+
+                    for popLabel, popCellGids in nodePopsCellGids.items():
+                        allPopsCellGids[popLabel].extend(popCellGids)
 
                     mergedFiles.append(file)

on edge changed /opt/miniconda3/envs/py376/lib/python3.7/site-packages/netpyne/sim/gather.py line 511 to
remove the else and always run
                    for popLabel, popCellGids in nodePopsCellGids.items():
                        allPopsCellGids[popLabel].extend(popCellGids)

in gatherDataFromFiles function

** 24may3_A0_ : retest with cochlea to make sure have correct # of cells

./myrun 48

python -i simdat.py 24may3_A0_

simConfig['net']['pops']['cochlea']['numCells'] # 10000
len(simConfig['net']['pops']['cochlea']['cellGids']) # 10000

d = pickle.load(open('data/24may3_A0_synWeights.pkl','rb'))
d.keys() # dict_keys([])

** verify cochlear connections

cochGids = []
cochConns = []

for cell in sim.net.cells:
  if cell.tags['pop'] == 'cochlea':
    cochGids.append(cell.gid)

for cell in sim.net.cells:
  for conn in cell.conns:
    if conn['preGid'] in cochGids:
      cochConns.append(conn)

** check outputs from ISI tests
* 24may6
** info from vb re. cochlear wiring

vb: oh I see the error. Once you call sim.initialize(simConfig=cfg,
netParams=netParams), netParams object is no longer usable, because
netpyne instead creates sim.net.params.connParams which is different
from netParams.connParams. But in sim.py, you then add connParams
items for cochlea to netParams.connParams , and it doesn't have effect
(edited)

So, you have to completely populate netParams.connParams prior to calling sim.initialize()

well, technically you could add cochlear connParams after calling
sim.initialize(), if you add them directly to
sim.net.params.connParams, but this is not recommended, as it can have
some unclear side-effects

sn: interesting ... didn't realize that requirement in ordering of
code. reason i did initialize is that I needed to use the gids and
properties of the population to set the connectivity rules. this might
be a bug in other simulations i have too...
will check/update code anyway, thanks

sm: I actually split Sam's sim.py into netParams, cfg and init. My
init has nothing populating the cochlea connparams. I'll look around
for something else and try again.

** update sim.py to put all netParam connParam rules before sim.initialize -->> can see cochlear conns

./myrun 48

ok, now get printouts showing cochlear connectivity:
found  2640  source cochlear synaptic connections
found  2630  source cochlear synaptic connections

python -i simdat.py 

d = pickle.load(open('data/24may6_A0_synWeights.pkl','rb'))

len(d.keys()) # 10000
lk = list(d.keys())
d[lk[0]]

ok, looks populated now

** 24may6_A0_ : restore topographic/tonotopic conn for cochlea and test out a wav file input

./myrun 48

python -i simdat.py 24may6_A0_

NGF1 1.23 Hz
IT2 1.22 Hz
SOM2 35.8 Hz
PV2 5.77 Hz
VIP2 7.19 Hz
NGF2 16.55 Hz
IT3 1.0 Hz
SOM3 10.51 Hz
PV3 34.61 Hz
VIP3 5.44 Hz
NGF3 9.69 Hz
ITP4 0.34 Hz
ITS4 0.33 Hz
SOM4 1.92 Hz
PV4 1.56 Hz
VIP4 21.0 Hz
NGF4 11.79 Hz
IT5A 1.71 Hz
CT5A 0.64 Hz
SOM5A 16.37 Hz
PV5A 7.67 Hz
VIP5A 4.6 Hz
NGF5A 5.38 Hz
IT5B 1.03 Hz
CT5B 2.42 Hz
PT5B 0.24 Hz
SOM5B 26.88 Hz
PV5B 2.67 Hz
VIP5B 6.18 Hz
NGF5B 2.92 Hz
IT6 4.9 Hz
CT6 3.56 Hz
SOM6 21.17 Hz
PV6 14.58 Hz
VIP6 37.08 Hz
NGF6 55.47 Hz
TC 28.68 Hz
TCM 25.26 Hz
HTC 27.79 Hz
IRE 4.01 Hz
IREM 3.7 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may6_24may6_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['cochlea'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may6_24may6_A0__spikehist.png]]

some evidence of a response due to cochlear stim ... at least time-locked to onset of cochlear stim
but does not drive a sustained response in thalamus or A1, and there are larger responses in thal
and A1 outside of time of the auditory stimulation

try again w/o the background noise to thal ... 

lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])

drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehistB.png') # [[./gif/24may6_24may6_A0__spikehistB.png]]

** 24may6_B0_ : test cochlear stim w/o background thalamic inputs

  "EbkgThalamicGain": 0,
  "IbkgThalamicGain": 0,

./myrun 48

python -i simdat.py 24may6_B0_

NGF1 1.13 Hz
IT2 1.27 Hz
SOM2 45.0 Hz
PV2 5.85 Hz
VIP2 6.56 Hz
NGF2 16.36 Hz
IT3 0.96 Hz
SOM3 11.11 Hz
PV3 37.99 Hz
VIP3 4.99 Hz
NGF3 9.11 Hz
ITP4 0.37 Hz
ITS4 0.35 Hz
SOM4 1.88 Hz
PV4 2.03 Hz
VIP4 22.0 Hz
NGF4 12.0 Hz
IT5A 1.28 Hz
CT5A 0.79 Hz
SOM5A 17.21 Hz
PV5A 7.92 Hz
VIP5A 3.6 Hz
NGF5A 4.12 Hz
IT5B 1.36 Hz
CT5B 2.94 Hz
PT5B 0.26 Hz
SOM5B 29.82 Hz
PV5B 2.61 Hz
VIP5B 4.76 Hz
NGF5B 2.29 Hz
IT6 5.32 Hz
CT6 4.41 Hz
SOM6 30.1 Hz
PV6 7.74 Hz
VIP6 33.08 Hz
NGF6 76.16 Hz
TC 29.28 Hz
TCM 26.48 Hz
HTC 28.71 Hz
IRE 3.83 Hz
IREM 2.91 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may6_24may6_B0__rast.png]]

xlim((1e3,3e3)); ylim((dstartidx['cochlea'],0))
savefig(gifpath()+'_rastB.png') # [[./gif/24may6_24may6_B0__rastB.png]]

so the stimulus onset produces a strong response in thal but then much after the stimulus there's
a spontaneous and strong activation of thal, even without any background input

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may6_24may6_B0__spikehist.png]]

** check previous ISI sim outputs

make a figure showing the MUA amplitudes as a function of ISI and GABAB level in thal

these sims were using the IC inputs

*** higher GABAB within thal
 24may1_B0_ <- 500 ms ISI
  avgMUAAmp # {'TC': 2.4521072796934864, 'HTC': 2.39766081871345, 'TCM': 0.19713261648745517, 'IRE': 0.8172043010752688, 'IREM': 2.2867383512544803, 'TI': 1.6230936819172115, 'ITP4': 0.6876410460639852, 'ITS4': 0.6869772998805257}
 24may1_C0_ <- 1000 ms ISI
  avgMUAAmp # {'TC': 3.5249042145593865, 'HTC': 3.157894736842105, 'TCM': 0.3010752688172043, 'IRE': 0.6666666666666666, 'IREM': 2.086021505376344, 'TI': 1.9389978213507628, 'ITP4': 1.2504978096375945, 'ITS4': 1.318199920350458}
 24may2_D0_ <- 1500 ms ISI
  avgMUAAmp # {'TC': 3.89367816091954, 'HTC': 3.5526315789473686, 'TCM': 0.20430107526881722, 'IRE': 0.7096774193548386, 'IREM': 1.4731182795698927, 'TI': 2.156862745098039, 'ITP4': 1.4595778574273197, 'ITS4': 1.4356829948227798}

*** lower GABAB within thal

 24may2_GBBase_500ISI_sim.json
python -i simdat.py 24may2_GBBase_500ISI_

NGF1 0.3 Hz
IT2 2.92 Hz
SOM2 62.37 Hz
PV2 112.79 Hz
VIP2 0.67 Hz
NGF2 19.4 Hz
IT3 0.26 Hz
SOM3 8.44 Hz
PV3 33.58 Hz
VIP3 45.53 Hz
NGF3 8.92 Hz
ITP4 3.27 Hz
ITS4 2.61 Hz
SOM4 36.7 Hz
PV4 2.1 Hz
VIP4 4.48 Hz
NGF4 11.79 Hz
IT5A 2.33 Hz
CT5A 0.37 Hz
SOM5A 27.15 Hz
PV5A 0.3 Hz
VIP5A 0.89 Hz
NGF5A 0.21 Hz
IT5B 3.52 Hz
CT5B 0.16 Hz
PT5B 0.11 Hz
SOM5B 47.15 Hz
PV5B 0.23 Hz
VIP5B 0.11 Hz
NGF5B 0.29 Hz
IT6 1.11 Hz
CT6 3.98 Hz
SOM6 77.54 Hz
PV6 0.0 Hz
VIP6 1.61 Hz
NGF6 104.63 Hz
TC 8.17 Hz
TCM 4.61 Hz
HTC 7.28 Hz
IRE 3.74 Hz
IREM 2.52 Hz
TI 2.47 Hz
TIM 3.24 Hz
IC 4.34 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may6_24may2_GBBase_500ISI__rastC.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh)

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may6_24may2_GBBase_500ISI__spikehistC.png]]

bbnT = np.arange(2000, 11000, 500); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}
{'TC': 15.790229885057471, 'HTC': 14.195906432748538, 'TCM': 4.810035842293907, 'IRE': 5.275985663082438, 'IREM': 4.56989247311828, 'TI': 1.8300653594771243, 'ITP4': 3.9028275587415373, 'ITS4': 3.185317934421877}
rates within thal and in L4 are much higher without the GABAB increase in thal ; can also compare to background rate outside of stimulus interval
though that may be higher as well due to more active thal

 24may2_GBBase_1000ISI_sim.json
python -i simdat.py 24may2_GBBase_1000ISI_

NGF1 0.3 Hz
IT2 3.45 Hz
SOM2 72.56 Hz
PV2 111.59 Hz
VIP2 0.54 Hz
NGF2 19.28 Hz
IT3 0.32 Hz
SOM3 10.74 Hz
PV3 32.18 Hz
VIP3 40.2 Hz
NGF3 8.8 Hz
ITP4 3.15 Hz
ITS4 2.5 Hz
SOM4 35.98 Hz
PV4 1.94 Hz
VIP4 5.64 Hz
NGF4 11.74 Hz
IT5A 2.29 Hz
CT5A 0.18 Hz
SOM5A 28.5 Hz
PV5A 0.26 Hz
VIP5A 1.12 Hz
NGF5A 0.16 Hz
IT5B 3.08 Hz
CT5B 0.06 Hz
PT5B 0.08 Hz
SOM5B 45.44 Hz
PV5B 0.19 Hz
VIP5B 0.11 Hz
NGF5B 0.22 Hz
IT6 0.96 Hz
CT6 3.84 Hz
SOM6 73.76 Hz
PV6 0.0 Hz
VIP6 2.29 Hz
NGF6 95.6 Hz
TC 6.91 Hz
TCM 4.67 Hz
HTC 6.03 Hz
IRE 3.37 Hz
IREM 2.32 Hz
TI 2.71 Hz
TIM 3.42 Hz
IC 2.17 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may6_24may2_GBBase_1000ISI__rastC.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh)

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may6_24may2_GBBase_1000ISI__spikehistC.png]]

bbnT = np.arange(2000, 11000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}
{'TC': 18.553639846743295, 'HTC': 15.146198830409354, 'TCM': 4.43010752688172, 'IRE': 6.824372759856631, 'IREM': 3.7275985663082434, 'TI': 1.5250544662309367, 'ITP4': 4.217443249701315, 'ITS4': 3.5284747112704107}

 24may2_GBBase_1500ISI_sim.json
python -i simdat.py 24may2_GBBase_1500ISI_

NGF1 0.18 Hz
IT2 5.56 Hz
SOM2 78.42 Hz
PV2 62.05 Hz
VIP2 0.63 Hz
NGF2 15.25 Hz
IT3 0.66 Hz
SOM3 26.48 Hz
PV3 28.07 Hz
VIP3 19.4 Hz
NGF3 8.68 Hz
ITP4 2.81 Hz
ITS4 2.19 Hz
SOM4 32.28 Hz
PV4 2.86 Hz
VIP4 10.08 Hz
NGF4 12.15 Hz
IT5A 1.14 Hz
CT5A 0.06 Hz
SOM5A 32.95 Hz
PV5A 0.83 Hz
VIP5A 1.19 Hz
NGF5A 0.23 Hz
IT5B 1.06 Hz
CT5B 0.11 Hz
PT5B 0.04 Hz
SOM5B 47.55 Hz
PV5B 0.34 Hz
VIP5B 0.32 Hz
NGF5B 0.42 Hz
IT6 1.15 Hz
CT6 3.37 Hz
SOM6 63.69 Hz
PV6 1.99 Hz
VIP6 8.2 Hz
NGF6 78.31 Hz
TC 5.84 Hz
TCM 3.91 Hz
HTC 5.46 Hz
IRE 3.28 Hz
IREM 1.97 Hz
TI 2.91 Hz
TIM 3.6 Hz
IC 1.45 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rastC.png') # [[./gif/24may6_24may2_GBBase_1500ISI__rastC.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh)

savefig(gifpath()+'_spikehistC.png') # [[./gif/24may6_24may2_GBBase_1500ISI__spikehistC.png]]

bbnT = np.arange(2000, 11000, 1500); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
avgMUAAmp = {pop: np.mean( [np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] ) for pop in lpop}
{'TC': 18.175287356321835, 'HTC': 18.85964912280702, 'TCM': 4.139784946236559, 'IRE': 7.010752688172043, 'IREM': 3.43010752688172, 'TI': 2.0915032679738563, 'ITP4': 3.6081242532855438, 'ITS4': 3.15810434090004}

*** draw/compare MUA of diff pops in the diff ISI and GABAB conditions

dMUA = {}

# gabab low in thal
dMUA[0] = {500: {'TC': 15.790229885057471, 'HTC': 14.195906432748538, 'TCM': 4.810035842293907, 'IRE': 5.275985663082438, 'IREM': 4.56989247311828, 'TI': 1.8300653594771243, 'ITP4': 3.9028275587415373, 'ITS4': 3.185317934421877},
           1000: {'TC': 18.553639846743295, 'HTC': 15.146198830409354, 'TCM': 4.43010752688172, 'IRE': 6.824372759856631, 'IREM': 3.7275985663082434, 'TI': 1.5250544662309367, 'ITP4': 4.217443249701315, 'ITS4': 3.5284747112704107},
           1500: {'TC': 18.175287356321835, 'HTC': 18.85964912280702, 'TCM': 4.139784946236559, 'IRE': 7.010752688172043, 'IREM': 3.43010752688172, 'TI': 2.0915032679738563, 'ITP4': 3.6081242532855438, 'ITS4': 3.15810434090004}}

# gabab high in thal
dMUA[1] = {500: {'TC': 2.4521072796934864, 'HTC': 2.39766081871345, 'TCM': 0.19713261648745517, 'IRE': 0.8172043010752688, 'IREM': 2.2867383512544803, 'TI': 1.6230936819172115, 'ITP4': 0.6876410460639852, 'ITS4': 0.6869772998805257},
           1000: {'TC': 3.5249042145593865, 'HTC': 3.157894736842105, 'TCM': 0.3010752688172043, 'IRE': 0.6666666666666666, 'IREM': 2.086021505376344, 'TI': 1.9389978213507628, 'ITP4': 1.2504978096375945, 'ITS4': 1.318199920350458},
           1500: {'TC': 3.89367816091954, 'HTC': 3.5526315789473686, 'TCM': 0.20430107526881722, 'IRE': 0.7096774193548386, 'IREM': 1.4731182795698927, 'TI': 2.156862745098039, 'ITP4': 1.4595778574273197, 'ITS4': 1.4356829948227798}}

lisi = [500, 1000, 1500]

lpop = ['TC','HTC', 'ITP4', 'ITS4']
lclr = ['r','g','b','c']
lt = ['Thalamic GABAB low', 'Thalamic GABAB high']

for gblow in [0,1]:
  subplot(1,2,gblow+1); title(lt[gblow]); ylabel('Firing Rate (Hz)'); xlabel('ISI (ms)')
  for pop,clr in zip(lpop, lclr):
      lrate = [dMUA[gblow][isi][pop] for isi in lisi]
      plot(lisi,lrate,clr); plot(lisi,lrate,clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)

savefig('gif/24may6_compare_MUA_rate_ISI_thal_gabab_low_high_a0.png') # [[./gif/24may6_compare_MUA_rate_ISI_thal_gabab_low_high_a0.png]]

ok, interesting that see the increase in firing rate (MUA) only when have relatively high gabab in thal

** email dj

We can discuss this at tomorrow's meeting.

I ran some simulations varying the ratio of intra-Thalamic GABAB to
GABAA, and different ISIs. Higher GABAB tended to produce increasing
firing rate of thalamic and A1 L4 excitatory neurons during the BBN
stimulation. I attached a summary.

Overall, an effect consistent with the experimental data is seen when
the GABAB is elevated within Thalamus.  Note GABAB is present from
thalamic IRE and interneurons onto excitatory neurons, producing
overall suppressed firing rates within thalamus.

Also note that the GABAB decay time constant is ~260 ms, but still
seems to produce longer-lasting effects on stimulus-processing.

I'll probably also simulate effects of ketamine via NMDAR blockade
later on, to see if it impacts the results. Let me know if any
comments.

attachment: [[gif/24may6_compare_MUA_rate_ISI_thal_gabab_low_high_a0.png]]

** 24may6_C0_ : cochlear stim w/o background thalamic inputs AND stronger thalamic GABAB

syn:
      "Thal": {"I": {"E": [0.5, 0.5]}},

./myrun 48

python -i simdat.py 24may6_C0_

NGF1 1.15 Hz
IT2 2.13 Hz
SOM2 35.2 Hz
PV2 5.69 Hz
VIP2 6.75 Hz
NGF2 20.64 Hz
IT3 1.33 Hz
SOM3 16.59 Hz
PV3 10.54 Hz
VIP3 12.0 Hz
NGF3 11.45 Hz
ITP4 0.92 Hz
ITS4 0.78 Hz
SOM4 4.42 Hz
PV4 7.15 Hz
VIP4 27.31 Hz
NGF4 15.36 Hz
IT5A 1.55 Hz
CT5A 0.15 Hz
SOM5A 19.98 Hz
PV5A 6.19 Hz
VIP5A 4.4 Hz
NGF5A 5.75 Hz
IT5B 0.37 Hz
CT5B 0.58 Hz
PT5B 0.14 Hz
SOM5B 29.14 Hz
PV5B 3.99 Hz
VIP5B 7.47 Hz
NGF5B 3.71 Hz
IT6 5.57 Hz
CT6 3.05 Hz
SOM6 28.71 Hz
PV6 8.14 Hz
VIP6 34.33 Hz
NGF6 72.47 Hz
TC 19.84 Hz
TCM 18.7 Hz
HTC 17.97 Hz
IRE 2.64 Hz
IREM 2.26 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may6_24may6_C0__rast.png]]

xlim((1e3,3e3)); ylim((dstartidx['cochlea'],0))
savefig(gifpath()+'_rastB.png') # [[./gif/24may6_24may6_C0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may6_24may6_C0__spikehist.png]]

still get that really large 'spontaneous' thalamic spike near 3 s ... 

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,3e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24may6_24may6_C0__CSD__CSD_overlay_pad1_a1.png]]

even with the higher GABAB vs GABAA whithin thalamus still seeing the giant re-entrant spike in thal

also not seeing much difference between core and matrix activation during cochlear iputs

** 24may6_D0_ : reduce strength of cochlear -> thal, reduce activation of matrix vs core 

./myrun 48

python -i simdat.py 24may6_D0_

* 24may7
** check output from 24may6_D0_

python -i simdat.py 24may6_D0_

NGF1 1.75 Hz
IT2 0.29 Hz
SOM2 52.4 Hz
PV2 0.31 Hz
VIP2 4.5 Hz
NGF2 8.45 Hz
IT3 0.26 Hz
SOM3 0.16 Hz
PV3 0.26 Hz
VIP3 2.51 Hz
NGF3 4.26 Hz
ITP4 0.0 Hz
ITS4 0.01 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 12.15 Hz
NGF4 3.86 Hz
IT5A 1.58 Hz
CT5A 0.01 Hz
SOM5A 3.49 Hz
PV5A 0.55 Hz
VIP5A 2.6 Hz
NGF5A 6.5 Hz
IT5B 0.17 Hz
CT5B 0.0 Hz
PT5B 0.12 Hz
SOM5B 3.24 Hz
PV5B 0.77 Hz
VIP5B 6.41 Hz
NGF5B 5.12 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 1.29 Hz
PV6 7.48 Hz
VIP6 28.5 Hz
NGF6 4.97 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may7_24may6_D0__rast.png]]

seeing a thalamic activation from cochlear inputs and then when cochlear inputs turned off
another activation, but afterwards no more thalamic activations

xlim((0.5e3,3e3)); ylim((dstartidx['cochlea'],0))
savefig(gifpath()+'_rastB.png') # [[./gif/24may7_24may6_D0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may7_24may6_D0__spikehist.png]]

interesting that the thalamic activity after cochlear input turned off is larger
than the thalamic input when cochlear input turned on

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,3e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24may7_24may6_D0__CSD__CSD_overlay_pad1_a1.png]]

the post-stim response looks too large ... ?  ? ? 

** meet with dj, sd, sm, no, ab

biol psych MMN paper (lakatos, et al) did not show SSA in MGB
worth testing SSA using same paradigm/timing of stimuli (over ~4 s) should show
a decrementing response in A1 MUA amplitude (but not MGB) 
NO will check MGB data at best freq to see if see any SSA in MGB

N1 refrac - at long time intervals (~6 s) might depend on intracellular signaling cascades
associated with GABAB but first step taken towards replicating N1 refractoriness at shorter
ISIs still beneficial

also can check interneuron MUA to see if that's what is carrying the 'memory' since
MUA did not seem to return to baseline in MGB , A1 during SSA paradigm

for N1 refrac - the effect might be within A1, so check GABAB alterations there

also check NMDAR dependence, N1 refrac may ~disappear with NMDAR blockade

** test SSA with GABAB alteration in Thal and/or A1

for SSA used 1 s interval - see figure 1C in https://pdf.sciencedirectassets.com/271200/1-s2.0-S0006322319X00086/1-s2.0-S0006322319318517/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEIH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQCR6l4r6bMHrJYG061qWgrmh6BR%2F8pPTxuPLQA8n5OMeAIhANoCytldiHSB5wqkbdTSKfhZZOjVWyXqVlVd0IPiQXywKrwFCNn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQBRoMMDU5MDAzNTQ2ODY1IgxFkRwXkhaj%2BCilQcQqkAV55QvnpaxrGiI85zr8ulqjxqkQ1WG839ALsxNyq0uYzZ3APYCylZ1IYfqig2hKpPH8XsC4t6%2BWuyOBDWKEUz6G9EvERdSnwKbq9zW4vBZdGdssIyTmN98NYj%2B4Gx1Al7f9KdELLNv5Wy8KUWUC0Mr9DJp3Y6BiJeb8ltMG85TuKQXxJJV4X4I%2F7wNHx%2BkvWR1IP%2FMzDzx%2BK4470SKiEDaG9xMTg%2F1EBLGHj0W8YXgOZkhrqb931dAH%2FoKTslNL%2FaX%2Frbba7cgKJjSd94g7l1fLvfa4cSbHGypVuCTo2n4T1uDzDzIGQecemqks8ixJ5pOlm79krI87pvmzIpdxzKzw7v0z73IwQkqte56ADKcbEsT5vlGCgy9YZ0mD7uf1j9dU2y8LnbJtNpZFsL0h0YeBt04NrQOQQi8uUQjRI7x%2F9n00BCvzKt2LfMQALUdfS14L0X7YFTBLrxsnf95wpWwbsYBkrVXSos2kr4UJAaSu5cV%2BEq%2FbjjW81dcXpg5gtYZY11kYJhT7Mi1gy6IP6Vp7OCgz7eGo961W7iEbRIcGkNm39p%2BsgMgiC8B7%2B6D0ZHsXiWF7G%2Byx6V7x7tGifRJO%2FHkv9HOUrBpug8Vw1PRtqGWXQbL2C%2BG1zXAQ5FRMsdVDuhlhMRtj7Wd%2BCxHn30zwThOrRSOsQB%2F9VlTLRM4BppEZ2tQef8rmkdVtmn7kZp6AXpMlOl%2FGGpHMyeNGnN9k4NDJfzaGABqKpmuqtIhUFf0lXPz4AuFDo3yjp%2Bl%2BkMgixq6cAOZcq5zJPJrF3CHT2g5SpmZJ4KxUTqw0XnYnU1hNStxkiJ%2B6l58tHINR611FT4WQCHWWAr0DuW4j7Ow3cGESuL4ei0itUFIRIF0NLTDCpemxBjqwAbx%2FvITHAa0dCDJJOUQDHeApLa9m%2FiFwaZyP8HImopDSdD96o8iPA9wjGjeOaGaacWzQsDcTfqDJ7GD7TicthH1riADpTQrgruiojNwHaT6Xfanne3nmbW8YFe%2BHLZuphxGIrxQlbO%2B%2FNfm4pG3Ylscgv39N2mNjWaXQweLsTwd0CakibtEdJc12AEr6V1ar%2FZbmxFzlZf1OtMPSQ8J9pKydHPK53PzH2psVnYAV1HD%2B&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20240507T171841Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5F34X7PI%2F20240507%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=d1888d14852f40e9cf6cde745ed69c38fe33782c856514365e41ba24dbedf1f5&hash=254f981088644be1fc7c90031dde898f8ce67d565f2f26aaa4fcefb6d4a261cd&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0006322319318517&tid=spdf-d72e4a24-c4eb-46c7-9cf4-c7c4cffabfdf&sid=c3880d5d4ee2934d3f0925f05a63a900a358gxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=1b15585a5057010302&rr=8802dee3ba687285&cc=us

*** 24may7_IC_BBN_ISI1000ms_Thal_Ctx_GABAB_High_A0_ 

./myrun 48

*** 24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0_ 

./myrun 48

* 24may8
** 24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0_ 

./myrun 48

** 24may8_IC_BBN_ISI1000ms_base_A0_ 

./myrun 48

** check SSA simulations -->> ctx gabab having little effect (bug?), with gabab higher in thal flatter MUA TC,HTC compared to w/o higher GABAB in thal

24may8_IC_BBN_ISI1000ms_base_A0_ 
24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0_ 
24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0_ 
24may7_IC_BBN_ISI1000ms_Thal_Ctx_GABAB_High_A0_ 

*** 24may8_IC_BBN_ISI1000ms_base_A0_  -->> no decrementing response (SSA)

python -i simdat.py 24may8_IC_BBN_ISI1000ms_base_A0_

NGF1 1.42 Hz
IT2 0.31 Hz
SOM2 44.2 Hz
PV2 5.69 Hz
VIP2 4.94 Hz
NGF2 10.36 Hz
IT3 0.28 Hz
SOM3 0.14 Hz
PV3 0.34 Hz
VIP3 2.47 Hz
NGF3 5.01 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 10.23 Hz
NGF4 4.0 Hz
IT5A 1.64 Hz
CT5A 0.01 Hz
SOM5A 4.09 Hz
PV5A 0.48 Hz
VIP5A 4.1 Hz
NGF5A 4.38 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.14 Hz
SOM5B 3.83 Hz
PV5B 0.71 Hz
VIP5B 6.0 Hz
NGF5B 4.25 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 1.05 Hz
PV6 4.82 Hz
VIP6 35.08 Hz
NGF6 6.13 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_base_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_base_A0__spikehist.png]]

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

{'TC': [9.482758620689655, 9.482758620689655, 12.413793103448274, 11.637931034482758, 10.172413793103448, 10.517241379310345, 11.637931034482758], 'HTC': [10.263157894736842, 10.26315789473684, 11.578947368421051, 11.052631578947366, 10.26315789473684, 10.526315789473683, 11.578947368421051], 'TCM': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'IRE': [20.129032258064516, 20.32258064516129, 21.870967741935484, 21.548387096774196, 20.774193548387096, 20.967741935483872, 21.806451612903224], 'IREM': [1.6774193548387097, 2.193548387096774, 2.5161290322580645, 2.4516129032258065, 1.7419354838709677, 1.7419354838709677, 2.064516129032258], 'TI': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'ITP4': [6.7622461170848265, 9.1636798088411, 10.15531660692951, 10.10752688172043, 9.617682198327358, 9.39068100358423, 10.1194743130227], 'ITS4': [6.260454002389487, 8.960573476702509, 10.07168458781362, 10.119474313022701, 9.438470728793309, 9.402628434886498, 10.10752688172043]}

plot(MUAAmp['ITP4'])

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_base_A0__MUA_AMP_BBN_response_a0.png]]

ok, do not see a decreasing amplitude to MUA in this baseline sim

*** 24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0_ -->> no decrementing response (SSA) <<-- looks identical to other, must not be working right

python -i simdat.py 24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0_

NGF1 1.42 Hz
IT2 0.31 Hz
SOM2 44.2 Hz
PV2 5.69 Hz
VIP2 4.94 Hz
NGF2 10.36 Hz
IT3 0.28 Hz
SOM3 0.14 Hz
PV3 0.34 Hz
VIP3 2.47 Hz
NGF3 5.01 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 10.23 Hz
NGF4 4.0 Hz
IT5A 1.64 Hz
CT5A 0.01 Hz
SOM5A 4.09 Hz
PV5A 0.48 Hz
VIP5A 4.1 Hz
NGF5A 4.38 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.14 Hz
SOM5B 3.83 Hz
PV5B 0.71 Hz
VIP5B 6.0 Hz
NGF5B 4.25 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 1.05 Hz
PV6 4.82 Hz
VIP6 35.08 Hz
NGF6 6.13 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0__spikehist.png]]

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

{'TC': [9.482758620689655, 9.482758620689655, 12.413793103448274, 11.637931034482758, 10.172413793103448, 10.517241379310345, 11.637931034482758], 'HTC': [10.263157894736842, 10.26315789473684, 11.578947368421051, 11.052631578947366, 10.26315789473684, 10.526315789473683, 11.578947368421051], 'TCM': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'IRE': [20.129032258064516, 20.32258064516129, 21.870967741935484, 21.548387096774196, 20.774193548387096, 20.967741935483872, 21.806451612903224], 'IREM': [1.6774193548387097, 2.193548387096774, 2.5161290322580645, 2.4516129032258065, 1.7419354838709677, 1.7419354838709677, 2.064516129032258], 'TI': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'ITP4': [6.7622461170848265, 9.1636798088411, 10.15531660692951, 10.10752688172043, 9.617682198327358, 9.39068100358423, 10.1194743130227], 'ITS4': [6.260454002389487, 8.960573476702509, 10.07168458781362, 10.119474313022701, 9.438470728793309, 9.402628434886498, 10.10752688172043]}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may8_24may8_IC_BBN_ISI1000ms_Ctx_GABAB_High_A0__MUA_AMP_BBN_response_a0.png]]

hmm, something strange that get same exact responses with the different synweightFractionIE, which is supposed to modulate
the SOM GABAA vs GABAB fraction ... which should have an impact on the cells ... might want to do the same for NGF instead?? but
why is it apparently having no effect when applied for SOM ?? 

*** 24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0_ -->> successive TC,HTC MUA are flatter with the increased GABAB, but not decreasing, inc GABAB further?

python -i simdat.py 24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0_

NGF1 1.44 Hz
IT2 0.31 Hz
SOM2 42.0 Hz
PV2 5.15 Hz
VIP2 4.94 Hz
NGF2 10.0 Hz
IT3 0.27 Hz
SOM3 0.19 Hz
PV3 0.34 Hz
VIP3 2.53 Hz
NGF3 4.93 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 11.38 Hz
NGF4 4.07 Hz
IT5A 1.72 Hz
CT5A 0.01 Hz
SOM5A 3.72 Hz
PV5A 0.53 Hz
VIP5A 3.7 Hz
NGF5A 4.88 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.14 Hz
SOM5B 3.47 Hz
PV5B 0.99 Hz
VIP5B 6.24 Hz
NGF5B 4.25 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 1.03 Hz
PV6 5.55 Hz
VIP6 33.17 Hz
NGF6 6.16 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may8_24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may8_24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0__spikehist.png]]

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

{'TC': [9.482758620689655, 9.827586206896552, 10.344827586206899, 10.258620689655174, 10.258620689655174, 10.344827586206897, 10.258620689655173], 'HTC': [10.263157894736842, 9.473684210526315, 9.999999999999998, 10.263157894736842, 10.0, 10.0, 9.736842105263158], 'TCM': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'IRE': [20.129032258064516, 23.870967741935488, 24.903225806451616, 24.838709677419352, 24.387096774193548, 24.516129032258064, 24.322580645161292], 'IREM': [1.6774193548387097, 1.7419354838709677, 2.0, 2.2580645161290325, 1.8709677419354838, 2.3225806451612905, 1.935483870967742], 'TI': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'ITP4': [6.7622461170848265, 9.127837514934289, 10.05973715651135, 9.80884109916368, 9.94026284348865, 10.02389486260454, 9.498207885304659], 'ITS4': [6.260454002389487, 9.21146953405018, 10.035842293906809, 9.73715651135006, 9.820788530465949, 10.02389486260454, 9.61768219832736]}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may8_24may7_IC_BBN_ISI1000ms_Thal_GABAB_High_A0__MUA_AMP_BBN_response_a0.png]]

** 24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0_ : another test of SSA with even higher GABAB in Thal

      "Thal": {"I": {"E": [0.1, 0.9]}},

so much more GABAB than GABAA ; would be better if could keep the GABAA constant and just increase GABAB independently
might work out if can have fraction of synaptic weights > 1 - check netpyne docs later

./myrun 48

* 24may9
** check 24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0_ -->> no real dec in MUA AMP (no SSA)

python -i simdat.py 24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0_

NGF1 1.43 Hz
IT2 0.33 Hz
SOM2 45.4 Hz
PV2 5.0 Hz
VIP2 4.56 Hz
NGF2 10.36 Hz
IT3 0.28 Hz
SOM3 0.16 Hz
PV3 0.36 Hz
VIP3 2.44 Hz
NGF3 4.93 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.0 Hz
PV4 0.0 Hz
VIP4 10.62 Hz
NGF4 4.14 Hz
IT5A 1.67 Hz
CT5A 0.01 Hz
SOM5A 4.02 Hz
PV5A 0.66 Hz
VIP5A 3.9 Hz
NGF5A 4.62 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.13 Hz
SOM5B 3.61 Hz
PV5B 0.75 Hz
VIP5B 6.59 Hz
NGF5B 4.33 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 0.95 Hz
PV6 4.4 Hz
VIP6 32.33 Hz
NGF6 5.95 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may9_24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may9_24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0__spikehist.png]]

do not see SSA here ...

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

{'TC': [9.482758620689655, 13.10344827586207, 18.103448275862068, 19.310344827586206, 18.879310344827587, 18.448275862068964, 18.103448275862068], 'HTC': [10.263157894736842, 14.736842105263158, 19.473684210526315, 21.315789473684212, 20.0, 19.473684210526315, 19.473684210526315], 'TCM': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'IRE': [20.129032258064516, 27.548387096774192, 28.967741935483872, 29.03225806451613, 28.903225806451612, 29.032258064516128, 28.903225806451612], 'IREM': [1.6774193548387097, 3.548387096774194, 8.32258064516129, 8.70967741935484, 8.64516129032258, 8.580645161290324, 7.935483870967742], 'TI': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'ITP4': [6.7622461170848265, 9.856630824372761, 12.485065710872162, 10.669056152927121, 12.891278375149344, 12.616487455197133, 11.23058542413381], 'ITS4': [6.260454002389487, 9.84468339307049, 12.210274790919954, 10.04778972520908, 12.604540023894863, 12.162485065710872, 10.884109916367981]}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may9_24may8_IC_BBN_ISI1000ms_ultra_high_thal_GABAB_A0__MUA_AMP_BBN_response_a0.png]]

well, from stim #3 onward, there is some decrement in MUA amplitude
for first 3 stimuli there's an incrementing response - could that have to do with model not having yet reached steady-state?

** synMechWeightFactor and fraction code - bug in I->E ? looks like mistake, fix/adjust specification of synaptic weight fractions

  ## I -> E
  if cfg.IEGain > 0.0:
      if connDataSource['I->E/I'] == 'Allen_custom':
          for pre in Ipops:
              for preType in Itypes:
                  if preType in pre:  # only create rule if celltype matches pop
                      for post in Epops:
                          for l in layerGainLabels:  # used to tune each layer group independently                            
                              prob = '%f * exp(-dist_2D/%f)' % (pmat[pre][post], lmat[pre][post])                            
                              if 'SOM' in pre:
                                  synMech = SOMESynMech
                              elif 'PV' in pre:
                                  synMech = PVSynMech
                              elif 'VIP' in pre:
                                  synMech = VIPSynMech
                              elif 'NGF' in pre:
                                  synMech = NGFSynMech
                              netParams.connParams['IE_'+pre+'_'+preType+'_'+post+'_'+l] = { 
                                  'preConds': {'pop': pre}, 
                                  'postConds': {'pop': post, 'ynorm': layer[l]},
                                  'synMech': synMech,
                                  'probability': prob,
                                  'weight': wmat[pre][post] * cfg.IEGain * cfg.IECellTypeGain[preType] * cfg.IELayerGain[l], 
                                  'synMechWeightFactor': cfg.synWeightFractionEI,
                                  'delay': 'defaultDelay+dist_3D/propVelocity',
                                  'synsPerConn': 1,
                                  'sec': 'proximal'}                    

looks like it's using the wrong variable of cfg.synWeightFractionEI
it should use cfg.synWeightFractionIE for I -> E pathway

also do not see cfg.synWeightFractionNGF used anywhere

ok, fixing up specification of synweightfraction

allowing different values for Thal -> Ctx, Thal -> Thal for I->E, I->I
default for cortex I->I will be 1.0 for a single synapse type
but for I->E SOM and NGF will allow specifying the fractions independently

should also check synMechWeightFactor, do not see it in documentation or in netpyne code and unclear if allows
total values in the list to sum beyond 1.0

** 24may9_IC_BBN_ISI1000ms_GABABtest_A0_ -->> increasing amplitude of TC MUA for first 4 BBNs, then decrementing after

re-test with some elevation of GABAB within Thal and within Cortex

./myrun 48

python -i simdat.py 24may9_IC_BBN_ISI1000ms_GABABtest_A0_

NGF1 2.46 Hz
IT2 0.02 Hz
SOM2 23.8 Hz
PV2 0.0 Hz
VIP2 0.19 Hz
NGF2 7.64 Hz
IT3 0.13 Hz
SOM3 0.23 Hz
PV3 0.0 Hz
VIP3 0.91 Hz
NGF3 4.3 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.04 Hz
PV4 0.0 Hz
VIP4 1.77 Hz
NGF4 3.64 Hz
IT5A 0.01 Hz
CT5A 0.0 Hz
SOM5A 1.23 Hz
PV5A 0.16 Hz
VIP5A 0.8 Hz
NGF5A 4.5 Hz
IT5B 0.0 Hz
CT5B 0.01 Hz
PT5B 0.06 Hz
SOM5B 1.46 Hz
PV5B 0.04 Hz
VIP5B 0.65 Hz
NGF5B 3.58 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 0.13 Hz
PV6 0.0 Hz
VIP6 9.08 Hz
NGF6 4.55 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may9_24may9_IC_BBN_ISI1000ms_GABABtest_A0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may9_24may9_IC_BBN_ISI1000ms_GABABtest_A0__spikehist.png]]

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may9_24may9_IC_BBN_ISI1000ms_GABABtest_A0__MUA_AMP_BBN_response_a0.png]]

not seeing the right effect here ... still increasing amplitude of MUA

** 24may9_IC_BBN_ISI1000ms_GABABtest_B0_ : start BBN later after closer to steady-state

start BBN at 5 s, same # of BBNs, run sim for 13 s ... 

./myrun 48

* 24may10
** check 24may9_IC_BBN_ISI1000ms_GABABtest_B0_ -->> still wrong pattern, why no matrix activity?

python -i simdat.py 24may9_IC_BBN_ISI1000ms_GABABtest_B0_

NGF1 1.64 Hz
IT2 0.59 Hz
SOM2 24.11 Hz
PV2 0.54 Hz
VIP2 1.12 Hz
NGF2 10.38 Hz
IT3 0.64 Hz
SOM3 16.57 Hz
PV3 11.16 Hz
VIP3 4.79 Hz
NGF3 6.93 Hz
ITP4 0.64 Hz
ITS4 0.62 Hz
SOM4 6.36 Hz
PV4 2.4 Hz
VIP4 9.57 Hz
NGF4 8.82 Hz
IT5A 0.17 Hz
CT5A 0.4 Hz
SOM5A 12.83 Hz
PV5A 1.46 Hz
VIP5A 1.52 Hz
NGF5A 5.09 Hz
IT5B 0.01 Hz
CT5B 0.32 Hz
PT5B 0.09 Hz
SOM5B 14.56 Hz
PV5B 1.06 Hz
VIP5B 1.61 Hz
NGF5B 5.15 Hz
IT6 1.07 Hz
CT6 0.66 Hz
SOM6 19.69 Hz
PV6 6.04 Hz
VIP6 28.23 Hz
NGF6 26.7 Hz
TC 0.89 Hz
TCM 0.0 Hz
HTC 0.97 Hz
IRE 1.5 Hz
IREM 0.36 Hz
TI 0.0 Hz
TIM 0.0 Hz
IC 1.56 Hz

why no matrix activity?

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may10_24may9_IC_BBN_ISI1000ms_GABABtest_B0__rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
drawstimhist(sh,llk = [ ['IC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may10_24may9_IC_BBN_ISI1000ms_GABABtest_B0__spikehist.png]]

bbnT = np.arange(2000, 9000, 1000); dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may10_24may9_IC_BBN_ISI1000ms_GABABtest_B0__MUA_AMP_BBN_response_a0.png]]

* 24may14
** 24may14_A0_: back to cochlear activation, for test SSA
* 24may16
** code from sm for click gen

import numpy as np
import wave
import struct

# Parameters
sample_rate = 44100.0  # Sample rate in Hz
duration = 3.0  # Duration in seconds
click_duration = 0.5 # Duration of click train in seconds
silence_duration = 1.0  # Duration of silence in seconds
frequency = 40.0  # Frequency of the click train in Hz
amplitude = 500  # Amplitude
n_samples = int(sample_rate * duration)
n_click_samples = int(sample_rate * click_duration)
n_silence_samples = int(sample_rate * silence_duration)
n_initial_silence_samples = int(sample_rate * 3)  # 3 seconds of initial silence

# Function to generate a click train
def generate_click_train():
    t = np.linspace(0, click_duration, n_click_samples, False)
    click_train = np.sin(frequency * t * 2 * np.pi)
    return amplitude * click_train

# Function to generate silence
def generate_silence(duration_samples):
    return np.zeros(duration_samples)

# Generate the click train and silence
click_train = generate_click_train()
silence = generate_silence(n_silence_samples)
# initial_silence = generate_silence(n_initial_silence_samples)

# Combine the initial silence, click train and silence to create the desired pattern
pattern = np.concatenate(( click_train, silence, click_train, silence))

# Repeat the pattern to fill the duration of the .wav file
n_patterns = int(n_samples / len(pattern))
sound = np.tile(pattern, n_patterns)

# Ensure the sound array is within the correct range for a .wav file
sound = np.clip(sound, -1, 1)

# Convert to 16-bit data
sound = (sound * 32767).astype(np.int16)

# Write to .wav file
with wave.open('40Hz_500Amp.wav', 'w') as wav_file:
    # Set parameters
    wav_file.setparams((1, 2, int(sample_rate), n_samples, 'NONE', 'not compressed'))

    # Write frames
    for s in sound:
        wav_file.writeframes(struct.pack('h', s))

** adding code from sm for click gen into audioStim.py

will move jitterNoise.py -> audioStim.py

python -i audioStim.py

* 24may17
** translate BBN matlab code to Python in audioStim.py

clear all
fs          = 100000; 
wlength=100;
rftime=5;
amp=1;
rfs=1;
soa=624;

dt      = 1/fs;
t       = 0:dt:(wlength/1000);

trlength=2;

rf=linspace(0,1,(rftime/1000)/dt);

xsin    = randn(1,size(t,2));

if rfs==0
    xsin(1:size(rf,2))=xsin(1:size(rf,2)).*rf;
    xsin(end-size(rf,2)+1:end)=xsin(end-size(rf,2)+1:end).*fliplr(rf);
elseif rfs==1
end

xsin=xsin*amp*(1/pi);

%%%% This is if you want to make the sinal have an SOA of 624ms
% xsin0=[xsin, zeros(1,((soa-wlength)/1000)/dt)];
% 
% tr0=zeros(1,size(xsin0,2));
% tr0(1:(trlength/1000)/dt)=1;
% 
% xsin=[xsin0];
% tr=[tr0];
% for i=1:stnum-1
%     xsin=[xsin,xsin0];
%     tr=[tr,tr0];
% end

player = audioplayer(xsin, fs);
play(player); %to listen to sound

%compute & plot FFT  to make sure have an even amplitude distrib
Y=fft(xsin); % compute fft
Fs = fs;  % Sampling rate (taken from above)
L = length(xsin); % Signal length
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);

f = Fs*(0:(L/2))/L;
figure;plot(f,P1) 
title('Single-Sided Amplitude Spectrum ')
xlabel('f (Hz)')
ylabel('|P1(f)|') 

* 24may20
** check silent wav file input (audioStim.py has command line args now)

python -i audioStim.py silence

that produces silence.wav

python -i input.py

dat, sampr = readwav('silence.wav')

dat.shape # (97020,)
sampr # 44100
np.amax(dat) # 0.0
np.amin(dat) # 0.0

dat, sampr = readwav('output_sound.wav')

d = cochlearInputSpikes(fnwave='silence.wav')

/opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/__init__.py:72: RuntimeWarning: invalid value encountered in true_divide
  scalled = signal * 10**(dbspl/20) * p0 / rms
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "input.py", line 52, in cochlearInputSpikes
    species='human',
  File "/opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/zilany2014/__init__.py", line 82, in run_zilany2014
    assert np.max(sound) < 1000, "Signal should be given in Pa"
AssertionError: Signal should be given in Pa

dat, sampr = readwav('silence.wav')
np.max(dat) # 0.0

from scipy.signal import resample
N = int(len(dat) * 100e3 / sampr)
dat = resample(dat, N)
sampr = 100000

dat.shape # (220000,)

np.amax(dat) # 0.0

loudnessDBs = 50
import cochlea
s = cochlea.set_dbspl(dat, loudnessDBs) # is this needed?
s.shape # (220000,)
np.amax(s) # nan <<-- that can lead to an error

help(cochlea.set_dbspl)
Help on function set_dbspl in module cochlea:

set_dbspl(signal, dbspl)
    Rescale the signal to a new level in dB SPL.
    
    Parameters
    ----------
    signal : array_like
        Signal for scaling.
    dbspl : float
        Desired level of the output signal in dB SPL.
    
    Returns
    -------
    array_like
        Scaled version of the original signal.

** 24may20_A0_ : test silence.wav input -->> still activates cochlear spikes -->> problem

./myrun 48

python -i simdat.py 24may20_A0_

NGF1 1.95 Hz
IT2 0.0 Hz
SOM2 5.6 Hz
PV2 0.0 Hz
VIP2 0.0 Hz
NGF2 0.91 Hz
IT3 0.01 Hz
SOM3 5.04 Hz
PV3 0.0 Hz
VIP3 0.28 Hz
NGF3 3.03 Hz
ITP4 0.0 Hz
ITS4 0.0 Hz
SOM4 0.12 Hz
PV4 0.0 Hz
VIP4 0.31 Hz
NGF4 4.14 Hz
IT5A 0.0 Hz
CT5A 0.0 Hz
SOM5A 2.81 Hz
PV5A 0.0 Hz
VIP5A 0.1 Hz
NGF5A 3.25 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.02 Hz
SOM5B 2.33 Hz
PV5B 0.0 Hz
VIP5B 0.06 Hz
NGF5B 2.38 Hz
IT6 0.0 Hz
CT6 0.0 Hz
SOM6 0.05 Hz
PV6 3.63 Hz
VIP6 28.75 Hz
NGF6 3.11 Hz
TC 0.0 Hz
TCM 0.0 Hz
HTC 0.0 Hz
IRE 0.0 Hz
IREM 0.0 Hz
TI 0.0 Hz
TIM 0.0 Hz
cochlea 0.0 Hz

savefig(gifpath()+'_rast.png') # [[./gif/24may20_24may20_A0__rast.png]]

still get a lot of cochlear spikes ... should not! time to debug input.py

** check cochlear spikes from silence.wav input

there is an option for generating noise for the ANFs but that is off by default
see ffGn function in /opt/miniconda3/envs/py376/lib/python3.7/site-packages/cochlea/zilany2014/util.py

python -i input.py

dout = cochlearInputSpikes(fnwave='silence.wav')
s range: 0.0 0.0
sound range: 0.0 0.0

dout.keys() # dict_keys(['spkT', 'cf'])

dout['spkT'].shape
len(dout['spkT'][0]) # 158
dout['spkT'][0]

** discuss with sm

decide for now to have silent period implicitly via gaps in wave file presentation to cochlea 
can provide list of wave files with different onsets to allow max flexibility

eventualy may want to re-implement inferior colliculus population in the model to 'filter
out' baseline ANF spikes during silent periods

* 24may21
** list of wave files, offsets to avoid silent periods

can set reading up in sim.py

for all of the audioStim.py functions will have to create the wave files as a set instead of
1 continuous wave file

python -i input.py

dout = cochlearSpikes(lfnwave=['silence.wav'],lonset=[0])
dout.keys() # dict_keys(['spkT', 'cf'])

len(dout['spkT'][0]) # 158
dout['spkT'][0]

python -i audioStim.py bbn

ok, that creates bbn.wav

python -i input.py

lonset = [624.5*i for i in range(7)]
lonset # [0.0, 624.5, 1249.0, 1873.5, 2498.0, 3122.5, 3747.0]
lfnwave = ['bbn.wav' for i in range(7)]

dout = cochlearSpikes(lfnwave=lfnwave,lonset=lonset)
dout.keys() # dict_keys(['spkT', 'cf'])

dout['spkT'][0] # [4.459999999999987, 6.919999999999916, 11.629999999999756, 18.039999999999527, 20.779999999999443, 26.81999999999923, 28.52999999999919, 29.939999999999166, 35.43000000000042, 40.0500000000016, 47.40000000000363, 55.19000000000578, 56.46000000000594, 67.63000000000558, 80.4300000000009, 94.28999999999583, 96.78999999999515, 102.36999999999327, 104.27999999999282, 109.95999999999091, 628.96, 631.42, 636.1299999999998, 642.5399999999995, 645.2799999999994, 651.3199999999993, 653.0299999999992, 654.4399999999991, 659.9300000000004, 664.5500000000015, 671.9000000000036, 679.6900000000057, 680.960000000006, 692.1300000000056, 704.9300000000009, 718.7899999999959, 721.2899999999952, 726.8699999999933, 728.7799999999928, 734.4599999999909, 1253.46, 1255.9199999999998, 1260.6299999999997, 1267.0399999999995, 1269.7799999999995, 1275.8199999999993, 1277.5299999999993, 1278.9399999999991, 1284.4300000000005, 1289.0500000000015, 1296.4000000000037, 1304.1900000000057, 1305.460000000006, 1316.6300000000056, 1329.430000000001, 1343.2899999999959, 1345.7899999999952, 1351.3699999999933, 1353.279999999993, 1358.959999999991, 1877.96, 1880.4199999999998, 1885.1299999999997, 1891.5399999999995, 1894.2799999999995, 1900.3199999999993, 1902.0299999999993, 1903.4399999999991, 1908.9300000000005, 1913.5500000000015, 1920.9000000000037, 1928.6900000000057, 1929.960000000006, 1941.1300000000056, 1953.930000000001, 1967.7899999999959, 1970.2899999999952, 1975.8699999999933, 1977.779999999993, 1983.459999999991, 2502.46, 2504.92, 2509.6299999999997, 2516.0399999999995, 2518.7799999999993, 2524.8199999999993, 2526.5299999999993, 2527.939999999999, 2533.4300000000003, 2538.0500000000015, 2545.4000000000037, 2553.190000000006, 2554.460000000006, 2565.6300000000056, 2578.4300000000007, 2592.289999999996, 2594.789999999995, 2600.369999999993, 2602.279999999993, 2607.959999999991, 3126.96, 3129.42, 3134.1299999999997, 3140.5399999999995, 3143.2799999999993, 3149.3199999999993, 3151.0299999999993, 3152.439999999999, 3157.9300000000003, 3162.5500000000015, 3169.9000000000037, 3177.690000000006, 3178.960000000006, 3190.1300000000056, 3202.9300000000007, 3216.789999999996, 3219.289999999995, 3224.869999999993, 3226.779999999993, 3232.459999999991, 3751.46, 3753.92, 3758.6299999999997, 3765.0399999999995, 3767.7799999999993, 3773.8199999999993, 3775.5299999999993, 3776.939999999999, 3782.4300000000003, 3787.0500000000015, 3794.4000000000037, 3802.190000000006, 3803.460000000006, 3814.6300000000056, 3827.4300000000007, 3841.289999999996, 3843.789999999995, 3849.369999999993, 3851.279999999993, 3856.959999999991]

from pylab import *
ion()

for i,spkt in enumerate(dout['spkT']):
  plot(spkt,[i for j in range(len(spkt))], 'ko',markersize=1)

ok, can see the BBN activations periodically in cochlear spiking ... they seem to outlast the BBN duration slightly though

well the BBN audio signal itself lasts only 100 ms as specified (try python -i audioStim.py bbn)
so cochlea ANFs must have activity slightly outlasting the stimulus ... could cut out extra spikes
that go beyond stimulus duration ... it's probably due to padding ... may want to get rid of that

python -i input.py

lonset = [624.5*i for i in range(7)] # [0.0, 624.5, 1249.0, 1873.5, 2498.0, 3122.5, 3747.0]
lfnwave = ['bbn.wav' for i in range(7)] # ['bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav']

dout = cochlearSpikes(lfnwave=lfnwave,lonset=lonset)
dout.keys() # dict_keys(['spkT', 'cf'])

dout['spkT'][0] # [4.459999999999987, 6.919999999999916, 11.629999999999756, 18.039999999999527, 20.779999999999443, 26.81999999999923, 28.52999999999919, 29.939999999999166, 35.43000000000042, 40.0500000000016, 47.40000000000363, 55.19000000000578, 56.46000000000594, 67.63000000000558, 80.4300000000009, 94.28999999999583, 96.78999999999515, 628.96, 631.42, 636.1299999999998, 642.5399999999995, 645.2799999999994, 651.3199999999993, 653.0299999999992, 654.4399999999991, 659.9300000000004, 664.5500000000015, 671.9000000000036, 679.6900000000057, 680.960000000006, 692.1300000000056, 704.9300000000009, 718.7899999999959, 721.2899999999952, 1253.46, 1255.9199999999998, 1260.6299999999997, 1267.0399999999995, 1269.7799999999995, 1275.8199999999993, 1277.5299999999993, 1278.9399999999991, 1284.4300000000005, 1289.0500000000015, 1296.4000000000037, 1304.1900000000057, 1305.460000000006, 1316.6300000000056, 1329.430000000001, 1343.2899999999959, 1345.7899999999952, 1877.96, 1880.4199999999998, 1885.1299999999997, 1891.5399999999995, 1894.2799999999995, 1900.3199999999993, 1902.0299999999993, 1903.4399999999991, 1908.9300000000005, 1913.5500000000015, 1920.9000000000037, 1928.6900000000057, 1929.960000000006, 1941.1300000000056, 1953.930000000001, 1967.7899999999959, 1970.2899999999952, 2502.46, 2504.92, 2509.6299999999997, 2516.0399999999995, 2518.7799999999993, 2524.8199999999993, 2526.5299999999993, 2527.939999999999, 2533.4300000000003, 2538.0500000000015, 2545.4000000000037, 2553.190000000006, 2554.460000000006, 2565.6300000000056, 2578.4300000000007, 2592.289999999996, 2594.789999999995, 3126.96, 3129.42, 3134.1299999999997, 3140.5399999999995, 3143.2799999999993, 3149.3199999999993, 3151.0299999999993, 3152.439999999999, 3157.9300000000003, 3162.5500000000015, 3169.9000000000037, 3177.690000000006, 3178.960000000006, 3190.1300000000056, 3202.9300000000007, 3216.789999999996, 3219.289999999995, 3751.46, 3753.92, 3758.6299999999997, 3765.0399999999995, 3767.7799999999993, 3773.8199999999993, 3775.5299999999993, 3776.939999999999, 3782.4300000000003, 3787.0500000000015, 3794.4000000000037, 3802.190000000006, 3803.460000000006, 3814.6300000000056, 3827.4300000000007, 3841.289999999996, 3843.789999999995]

from pylab import *
ion()

for i,spkt in enumerate(dout['spkT']):
  plot(spkt,[i for j in range(len(spkt))], 'ko',markersize=1)

yeah, w/o pad it fits the duration properly

** meet with dj

NO found SSA even within MGB, using a 624 ms SOA 
can try to model thalamus separately to replicate SSA with that SOA
may have an interaction between GABAB and NMDARs contributing to SSA whereby GABAB
modulates NMDAR conductance, can test that in model as well

striatum will be important down the road, via corticostriatal -> striatum -> thalamic pathway
may want to include striatal (and/or PFC) circuits later on, PFC also related to CM
modeling anyway

** 24may21_A0_ : try list of wave files and onsets for train of BBNs -->> see some SSA in ITP4, ITS4

have this in sim.json :

  "CochlearThalInput" : {"lonset": [0.0, 624.5, 1249.0, 1873.5, 2498.0, 3122.5, 3747.0], "numCenterFreqs": 100, "freqRange": [125, 20000], "loudnessScale": 1, "lfnwave":['bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav', 'bbn.wav']},

./myrun 48

python -i simdat.py 24may21_A0_

NGF1 2.34 Hz
IT2 0.05 Hz
SOM2 23.8 Hz
PV2 0.23 Hz
VIP2 6.75 Hz
NGF2 3.82 Hz
IT3 0.08 Hz
SOM3 1.39 Hz
PV3 1.8 Hz
VIP3 2.73 Hz
NGF3 4.23 Hz
ITP4 0.05 Hz
ITS4 0.06 Hz
SOM4 0.71 Hz
PV4 0.01 Hz
VIP4 3.62 Hz
NGF4 5.36 Hz
IT5A 0.19 Hz
CT5A 0.0 Hz
SOM5A 1.7 Hz
PV5A 0.21 Hz
VIP5A 6.4 Hz
NGF5A 4.5 Hz
IT5B 1.32 Hz
CT5B 0.04 Hz
PT5B 0.0 Hz
SOM5B 5.78 Hz
PV5B 0.68 Hz
VIP5B 8.29 Hz
NGF5B 5.08 Hz
IT6 0.03 Hz
CT6 0.06 Hz
SOM6 1.24 Hz
PV6 54.92 Hz
VIP6 54.25 Hz
NGF6 5.79 Hz
TC 0.84 Hz
TCM 1.11 Hz
HTC 0.66 Hz
IRE 1.44 Hz
IREM 2.1 Hz
TI 0.82 Hz
TIM 0.88 Hz
cochlea 0.0 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may21_24may21_A0__rast.png]]

xlim((0,150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may21_24may21_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may21_24may21_A0__spikehist.png]]

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may21_24may21_A0__MUA_AMP_BBN_response_a0.png]]

interesting, ITP4, ITS4 MUA amplitude is decreasing, while TC, HTC, IRE increasing

have to check GABAB settings along with starting the stimuli later

** allow split up of noise inputs in create_sound_stream in audioStream.py (to prevent cochlear silent period issue)

ok, just add option to return output asList

python -i audioStim.py

fs = 44100
center_freq = 1000  # Center frequency of the noise
repetition_rate = 1.6  # Repetition rate in Hz
jitter = 0.1  # Standard deviation of the intervals in Sec., set to 0 for perfectly rhythmic. We used 0, 0.04,0.08,0.12. 
duration = 10  # Total duration of the sound stream in seconds
noise_duration = 0.025  # Duration of each noise burst in seconds
lnoise, intervals, sound_stream = create_sound_stream(center_freq, repetition_rate, jitter, duration, noise_duration, fs, rhythmic=False, asList=True)

len(lnoise) # 16
len(intervals) # 16

array([0.52533527, 0.50328766, 0.70883187, 0.60554346, 0.68590215,
       0.58681374, 0.41161417, 0.51854792, 0.45799587, 0.6839213 ,
       0.60736105, 0.57938649, 0.63831846, 0.65158328, 0.56927121,
       0.4553076 ])

len(lnoise[0]) # 1102
len(lnoise[1]) # 1102

plot(lnoise[0])

savefig('gif/24may21_test_jitter_noise_a0.png') # [[./gif/24may21_test_jitter_noise_a0.png]]

lfn = []
based = 'wav/jitternoise/'
for i,noise in enumerate(lnoise):
  fn = based + str(i) + '.wav'
  write(fn, fs, noise.astype(np.float32))
  lfn.append(fn)

lfn # ['wav/jitternoise/0.wav', 'wav/jitternoise/1.wav', 'wav/jitternoise/2.wav', 'wav/jitternoise/3.wav', 'wav/jitternoise/4.wav', 'wav/jitternoise/5.wav', 'wav/jitternoise/6.wav', 'wav/jitternoise/7.wav', 'wav/jitternoise/8.wav', 'wav/jitternoise/9.wav', 'wav/jitternoise/10.wav', 'wav/jitternoise/11.wav', 'wav/jitternoise/12.wav', 'wav/jitternoise/13.wav', 'wav/jitternoise/14.wav', 'wav/jitternoise/15.wav']

lonset = [1000]
for i in range(1,len(intervals),1):
  lonset.append(lonset[i-1] + intervals[i-1]*1e3)

lonset # [1000, 1773.7326554342305, 2318.598333167001, 3069.203071066093, 3754.6628282677393, 4626.857709542141, 5286.439006970395, 5970.651397257222, 6565.561437919312, 7100.8575926910635, 7816.766531097223, 8492.094641568216, 8911.338662677597, 9522.63337147328, 10131.823971763768, 10689.573944409447]

can use that later on in a test, along with those wave files above in lfn

** 24may21_B0_ : test SSA with starting BBNs later (+1s), and putting GABAB back to baseline in thal and cortex -->> some slight SSA, but overall very hyperexcitable, and too much delay to cortical activation

./myrun 48

python -i simdat.py 24may21_B0_

NGF1 6.87 Hz
IT2 0.0 Hz
SOM2 0.0 Hz
PV2 0.0 Hz
VIP2 0.0 Hz
NGF2 557.64 Hz
IT3 21.72 Hz
SOM3 0.0 Hz
PV3 0.0 Hz
VIP3 53.24 Hz
NGF3 342.59 Hz
ITP4 0.89 Hz
ITS4 0.96 Hz
SOM4 116.5 Hz
PV4 126.67 Hz
VIP4 0.0 Hz
NGF4 146.71 Hz
IT5A 0.72 Hz
CT5A 4.95 Hz
SOM5A 0.0 Hz
PV5A 0.0 Hz
VIP5A 0.0 Hz
NGF5A 226.62 Hz
IT5B 8.13 Hz
CT5B 28.37 Hz
PT5B 0.57 Hz
SOM5B 0.0 Hz
PV5B 0.0 Hz
VIP5B 0.0 Hz
NGF5B 298.04 Hz
IT6 4.66 Hz
CT6 10.14 Hz
SOM6 144.41 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 371.63 Hz
TC 47.02 Hz
TCM 38.15 Hz
HTC 46.11 Hz
IRE 8.75 Hz
IREM 4.78 Hz
TI 3.98 Hz
TIM 3.88 Hz
cochlea 23.17 Hz

most of these firing rates are out of control ... 

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may21_24may21_B0__rast.png]]

xlim((1000,1150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may21_24may21_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may21_24may21_B0__spikehist.png]]

now too much activation and also responses in thal and cortex look very delayed compared to cochlear activation

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may21_24may21_B0__MUA_AMP_BBN_response_a0.png]]

looks slightly like SSA but due to very high firing rates and delay in response (ITP4, ITS4 peaks are much later
than the cochlear activation), still seems incorrect overall 

well, the response amplitude does seem like it decreases somewhat even in ITP4, ITS4 (at time of peak
in ITP4, ITS4)

** 24may21_C0_ : re-increase the GABAB in thal and cortex and try with same delayed times for SSA -->> coch spikes at onset and offset of sound producing doublet in thal/A1, why?

./myrun 48

python -i simdat.py 24may21_C0_

NGF1 1.29 Hz
IT2 0.46 Hz
SOM2 59.4 Hz
PV2 2.46 Hz
VIP2 1.75 Hz
NGF2 5.27 Hz
IT3 0.18 Hz
SOM3 6.3 Hz
PV3 3.52 Hz
VIP3 1.53 Hz
NGF3 3.99 Hz
ITP4 0.31 Hz
ITS4 0.28 Hz
SOM4 2.71 Hz
PV4 0.04 Hz
VIP4 2.0 Hz
NGF4 5.43 Hz
IT5A 0.07 Hz
CT5A 0.0 Hz
SOM5A 4.72 Hz
PV5A 0.07 Hz
VIP5A 0.8 Hz
NGF5A 1.62 Hz
IT5B 0.68 Hz
CT5B 0.07 Hz
PT5B 0.03 Hz
SOM5B 12.95 Hz
PV5B 0.0 Hz
VIP5B 0.88 Hz
NGF5B 1.5 Hz
IT6 0.01 Hz
CT6 0.2 Hz
SOM6 0.19 Hz
PV6 74.94 Hz
VIP6 103.92 Hz
NGF6 5.39 Hz
TC 5.62 Hz
TCM 4.28 Hz
HTC 3.82 Hz
IRE 4.95 Hz
IREM 4.88 Hz
TI 4.55 Hz
TIM 4.61 Hz
cochlea 23.17 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may21_24may21_C0__rast.png]]

xlim((1000,1150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may21_24may21_C0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may21_24may21_C0__spikehist.png]]

looks like a strange doublet - first at onset of cochlear activation get a TC/HTC/TCM spike
producing TI/IRE/IREM and then ITP4,ITS4 spike. then at offset of cochlear activation get
a secondary spike in the same populations, but with lower inhibition within thalamus, which
might lead to the 2nd spike being higher in TC/HTC?

without understanding the response at offset, and why there
is a secondary spike, the MUA analysis is unlikely to be valuable/correct

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may21_24may21_C0__MUA_AMP_BBN_response_a0.png]]

* 24may23
** better params from sm

    params['cochlearThalInput','weightECore'] = [0.15]
    params['cochlearThalInput', 'weightICore'] = [0.09]
    params['cochlearThalInput', 'probECore'] = [0.3]

    netParams.probLambda = 100.0  # length constant (lambda) for connection probability decay (um)
    ThalamicCoreLambda = 50.0

** 24may23_A0_ : try sm revised params for re-test of SSA -->> have reduction in amp from first to second stim (so some SSA)

./myrun 48

python -i simdat.py 24may23_A0_

NGF1 1.93 Hz
IT2 0.02 Hz
SOM2 12.4 Hz
PV2 0.0 Hz
VIP2 0.69 Hz
NGF2 3.55 Hz
IT3 0.05 Hz
SOM3 2.36 Hz
PV3 0.07 Hz
VIP3 0.63 Hz
NGF3 3.61 Hz
ITP4 0.07 Hz
ITS4 0.08 Hz
SOM4 0.46 Hz
PV4 0.0 Hz
VIP4 0.23 Hz
NGF4 3.86 Hz
IT5A 0.0 Hz
CT5A 0.0 Hz
SOM5A 1.3 Hz
PV5A 0.03 Hz
VIP5A 0.4 Hz
NGF5A 3.88 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.03 Hz
SOM5B 3.45 Hz
PV5B 0.03 Hz
VIP5B 0.0 Hz
NGF5B 2.21 Hz
IT6 0.0 Hz
CT6 0.03 Hz
SOM6 3.83 Hz
PV6 13.62 Hz
VIP6 46.75 Hz
NGF6 4.71 Hz
TC 1.49 Hz
TCM 1.54 Hz
HTC 1.5 Hz
IRE 2.14 Hz
IREM 2.26 Hz
TI 3.1 Hz
TIM 3.12 Hz
cochlea 23.17 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may23_24may23_A0__rast.png]]

xlim((1000,1150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may23_24may23_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gifpath()+'_spikehist.png']]

there is a reduction from first to second stimulus in the thalamic and cortical responses

although cortical responses are completely missing sometimes

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may23_24may23_A0__MUA_AMP_BBN_response_a0.png]]

would this same effect occur if starting the BBN stimulation later?

also note that had thalamic background activation turned off:
  "EbkgThalamicGain": 0,
  "IbkgThalamicGain": 0,

** 24may23_B0_ : start BBN stim a little later to see if still get SSA -->> still get SSA from first to second BBN stimulus

./myrun 48

python -i simdat.py 24may23_B0_

NGF1 2.01 Hz
IT2 0.01 Hz
SOM2 8.2 Hz
PV2 0.0 Hz
VIP2 0.06 Hz
NGF2 2.36 Hz
IT3 0.04 Hz
SOM3 2.17 Hz
PV3 0.0 Hz
VIP3 0.31 Hz
NGF3 2.93 Hz
ITP4 0.01 Hz
ITS4 0.02 Hz
SOM4 0.38 Hz
PV4 0.0 Hz
VIP4 0.15 Hz
NGF4 3.29 Hz
IT5A 0.0 Hz
CT5A 0.0 Hz
SOM5A 1.33 Hz
PV5A 0.03 Hz
VIP5A 0.0 Hz
NGF5A 5.0 Hz
IT5B 0.0 Hz
CT5B 0.0 Hz
PT5B 0.03 Hz
SOM5B 2.45 Hz
PV5B 0.04 Hz
VIP5B 0.47 Hz
NGF5B 3.54 Hz
IT6 0.0 Hz
CT6 0.01 Hz
SOM6 3.27 Hz
PV6 14.79 Hz
VIP6 47.0 Hz
NGF6 5.97 Hz
TC 1.45 Hz
TCM 1.54 Hz
HTC 1.53 Hz
IRE 2.16 Hz
IREM 2.27 Hz
TI 3.1 Hz
TIM 3.18 Hz
cochlea 23.17 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may23_24may23_B0__rast.png]]

xlim((2000,2150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may23_24may23_B0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may23_24may23_B0__spikehist.png]]

stills ee initial SSA, so that's good...

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

bbnT # [2000.0, 2624.5, 3249.0, 3873.5, 4498.0, 5122.5, 5747.0]

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') # [[./gif/24may23_24may23_B0__MUA_AMP_BBN_response_a0.png]]

* 24may24
** alpha/beta vs delta/theta

when have the thalamic noise activated, that produces clear rhythms; how much
do those rhythms interfere with bottom-up activation of MUA from auditory stimuli (associated
with let's say a delta/theta rhythm) ? 

** 24may24_A0_ : test jitterNoise input into model

these go into json file CochlearThalInput dictionary
lfnwave = ['wav/jitternoise/0.wav', 'wav/jitternoise/1.wav', 'wav/jitternoise/2.wav', 'wav/jitternoise/3.wav', 'wav/jitternoise/4.wav', 'wav/jitternoise/5.wav', 'wav/jitternoise/6.wav', 'wav/jitternoise/7.wav', 'wav/jitternoise/8.wav', 'wav/jitternoise/9.wav', 'wav/jitternoise/10.wav', 'wav/jitternoise/11.wav', 'wav/jitternoise/12.wav', 'wav/jitternoise/13.wav', 'wav/jitternoise/14.wav', 'wav/jitternoise/15.wav']

lonset = [2000, 2773.7326554342305, 3318.598333167001, 4069.203071066093, 4754.6628282677393, 5626.857709542141, 6286.439006970395, 6970.651397257222, 7565.561437919312, 8100.8575926910635, 8816.766531097223, 9492.094641568216, 9911.338662677597, 10522.63337147328, 11131.823971763768, 11689.573944409447]

will have to run for 13.5 s to capture full duration 

and keeping the heightened GABAB here ... 

./myrun 48

python -i simdat.py 24may24_A0_

NGF1 1.54 Hz
IT2 0.8 Hz
SOM2 15.0 Hz
PV2 0.76 Hz
VIP2 1.32 Hz
NGF2 12.38 Hz
IT3 0.82 Hz
SOM3 22.58 Hz
PV3 11.46 Hz
VIP3 7.25 Hz
NGF3 8.17 Hz
ITP4 0.84 Hz
ITS4 0.82 Hz
SOM4 8.97 Hz
PV4 3.29 Hz
VIP4 11.65 Hz
NGF4 10.46 Hz
IT5A 0.15 Hz
CT5A 0.53 Hz
SOM5A 16.83 Hz
PV5A 1.99 Hz
VIP5A 1.64 Hz
NGF5A 4.69 Hz
IT5B 0.12 Hz
CT5B 0.59 Hz
PT5B 0.1 Hz
SOM5B 19.84 Hz
PV5B 1.47 Hz
VIP5B 1.55 Hz
NGF5B 5.95 Hz
IT6 1.42 Hz
CT6 0.84 Hz
SOM6 26.26 Hz
PV6 8.85 Hz
VIP6 29.59 Hz
NGF6 34.69 Hz
TC 1.87 Hz
TCM 1.92 Hz
HTC 2.06 Hz
IRE 2.84 Hz
IREM 2.9 Hz
TI 2.3 Hz
TIM 2.27 Hz
cochlea 6.26 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/24may24_24may24_A0__rast.png]]

xlim((2000,2150))
savefig(gifpath()+'_rastB.png') # [[./gif/24may24_24may24_A0__rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}      
lidx = [3400+dstartidx['cochlea'],4799+dstartidx['cochlea']] # cochlear cells projecting to thalamic core
sh['cochleaC'] = getspikehist(dspkT['cochlea'],dnumc['cochlea'],25,totalDur,lidx=lidx,spkID=dspkID['cochlea'])
drawstimhist(sh,llk = [ ['cochlea','cochleaC'], ['TC', 'HTC', 'TCM'], ['IRE', 'IREM','TI'], ['ITP4', 'ITS4'] ])

savefig(gifpath()+'_spikehist.png') # [[./gif/24may24_24may24_A0__spikehist.png]]

from conf import dconf
bbnT = dconf['CochlearThalInput']['lonset']; dt = 25; sampr = 40
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
lpop = ['TC', 'HTC', 'TCM', 'IRE', 'IREM', 'TI', 'ITP4', 'ITS4']
MUAAmp = {pop:[np.mean(sh[pop][1][x:x+4]) for x in bbnTrigIdx] for pop in lpop}

bbnT # [2000, 2773.7326554342303, 3318.598333167001, 4069.203071066093, 4754.662828267739, 5626.857709542141, 6286.439006970395, 6970.651397257222, 7565.561437919312, 8100.8575926910635, 8816.766531097222, 9492.094641568216, 9911.338662677597, 10522.63337147328, 11131.823971763768, 11689.573944409447]

lpop = ['TC','HTC','IRE','ITP4','ITS4']
lclr = ['r','g','b','c','m']
for pop,clr in zip(lpop,lclr):
  plot(MUAAmp[pop],clr); plot(MUAAmp[pop],clr+'o')

lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lpop)]
gca().legend(handles=lpatch,handlelength=1)
ylabel('MUA Freq (Hz)'); xlabel('BBN Stim Number')

savefig(gifpath()+'_MUA_AMP_BBN_response_a0.png') #
[[./gif/24may24_24may24_A0__MUA_AMP_BBN_response_a0.png]]

from netpyne import sim
fn = 'data/'+simstr+'/'+simstr+'_data.pkl'
sim.load(fn,instantiate=False) 

layerBounds = {'L1': [0,100], 'L2': [100,160], 'L3': [160,950], 'L4': [950,1250], 'L5A': [1250,1334], 'L5B': [1334,1550], 'L6': [1550,2000]}
sim.plotting.plotCSD(overlay='CSD',timeRange=[0e3,13.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds,pad=1) 

savefig(gifpath()+'_CSD__CSD_overlay_pad1_a1.png') # [[./gif/24may24_24may24_A0__CSD__CSD_overlay_pad1_a1.png]]

CSD probably still needs work, but interesting to see SSA with the jittered noise inputs ... that lasts
beyond the first few stimuli; also should take into account the interval between the stimuli

main effect was looking for here was whether matrix vs core entrain more / less to the jittered stimuli ... 

*** email cm

I finally ran some of your jittered noise through the auditory
model. The model has tonotopic frequency mapping between 1-2
kHz. Central frequency of the jittered noise is 1 kHz. Any of those
parameters could be adjusted.

I attached some of the output. I have heightened GABAB in this model,
which is for a different project, to recreate steady-state adaptation
(some is seen in decreasing MUA amplitude over the course of
stimulation).

Any suggestions for primary analysis to focus on? I think the idea was
to show that matrix is less sensitive to increases in jitter (more
broadly tuned), while core is more focused in tuning? So, I could vary
the jitter parameter and measure the MUA amplitude of thalamic core
neurons and thalamic matrix neurons - that seem like a reasonable
start? Open to other suggestions.

